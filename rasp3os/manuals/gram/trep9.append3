\addcontentsline{toc}{section}{Appendix 3: Grammar Listing}
{\large\bf Appendix 3: Grammar Listing}

\small
{\bf ; feature declarations}
\begin{verbatim}
FEATURE N{+, -}
FEATURE V{+, -}
FEATURE BAR{-1, 0, 1, 2}
FEATURE SUBJ{+, -}
FEATURE SUBCAT{ADL, ADVP, ADVP_PP, IT_WHS, LOC, MP, NP, NP_ADL, NP_ADVP, 
   NP_LOC, NP_MP, NP_NP, NP_NP_SFIN, NP_PP, NP_PP_PP, NP_SBSE, NP_SFIN, 
   NP_WHS, NP_WHVP, NULL, OC_AP, OC_BSE, OC_INF, OC_ING, OC_NP, OC_PASS, 
   OC_PP_BSE, OC_PP_INF, OC_PP_ING, PP, PPING, PPSING, PP_PP, PP_SBSE, 
   PP_SFIN, PP_SINF, PP_VPINF, PP_WHS, PP_WHVP, SBSE, SC_AP, SC_BSE, SC_INF, 
   SC_ING, SC_NP, SC_NP_AP, SC_NP_INF, SC_NP_NP, SC_PASS, SC_PP_INF, SFIN, 
   SINF, VPINF, WHS, WHVP, VPING, SING, AND, BOTH, BUT, EITHER, NEITHER, NOR, 
   OR, DETA, DETN, AS, FOR, IF, THAN, THAT, WHETHER, NOT, BE, DO, HAVE, 
   MODAL_BSE, MODAL_INF, TO, FUT, OFN1}
FEATURE CONJ{NULL, BOTH, NEITHER, EITHER, AND, OR, NOR, BUT}
FEATURE VFORM{BSE, ING, EN, TO, NOT}
FEATURE H{+, -}
FEATURE T{S, NP}
FEATURE BEGAP{+, -}
FEATURE FIN{+, -}
FEATURE PAST{+, -, FUT, NOT}
FEATURE PRD{+, -}
FEATURE AUX{+, -}
FEATURE INV{+, -}
FEATURE PSVE{+, -}
FEATURE NEG{+, -}
FEATURE COMP{THAT, FOR, IF, WHETHER, NORM, ER, AS}
FEATURE SLASH CAT
FEATURE NFORM{NORM, THERE, IT}
FEATURE PER{1, 2, 3}
FEATURE PLU{+, -}
FEATURE COUNT{+, -}
FEATURE CASE{NOM, ACC}
FEATURE PN{+, -}
FEATURE PRO{+, -}
FEATURE PROTYPE{NONE, COMPOUND, PMOD, PMOD+, THAT}
FEATURE PART{OF, OF2, NO_OF, -}
FEATURE SPEC{+, -}
FEATURE PFORM{ABOUT, ABOUT_TO, ABOUT_WITH, ABOVE, ACROSS, AFTER, AGAINST, 
   ALL, ALONG, AMONG, AMONGST, AROUND, AS, AS_TO, AT, AT_ABOUT, AT_FOR, AWAY, 
   BEFORE, BEHIND, BELOW, BESIDE, BETWEEN, BY, BY_FOR, DOWN, DOWN_TO, DURING, 
   FOR, FOR_TO, FOR_WITH, FROM, FROM_FOR, FROM_INTO, FROM_TO, IN, INTO, 
   INTO_WITH, IN_AT, IN_FAVOUR_OF, IN_FRONT_OF, IN_WITH, LIKE, OF, OFF, 
   OF_AS, OF_FOR, ON, ONTO, ON_AS, ON_BOARD, ON_FOR, ON_TO, ON_WITH, OUT, 
   OUT_OF, OVER, OVER_WITH, ROUND, THAN, THROUGH, THROUGHOUT, TILL, TO, 
   TOGETHER, TOWARD, TOWARDS, TO_AGAINST, TO_AS, TO_FOR, TO_FROM, UNDER, 
   UNTIL, UP, UPON, UP_TO, WITH, WITHOUT, WITH_ABOUT, WITH_AGAINST, WITH_AT, 
   WITH_FOR, WITH_ON, WITH_OVER, NORM, ER}
FEATURE LOC{+, -}
FEATURE GERUND{+, -}
FEATURE AFORM{ER, EST, NONE, AS}
FEATURE QUA{+, -}
FEATURE DEF{+, -}
FEATURE POSS{+, -}
FEATURE ADV{+, -}
FEATURE NUM{CARD, ORD, -, +}
FEATURE WH{+, -, NO}
FEATURE UB{R, Q, NO}
FEATURE EVER{+, -, NO}
FEATURE MOD{PRE, POST, NONE}
FEATURE CONJN{+, -}
FEATURE COORD{+, -}
FEATURE REFL{+, -}
FEATURE AT{+, -}
FEATURE LAT{-, +}
FEATURE FIX{PRE, SUF, NOT}
FEATURE INFL{-, +}
FEATURE STEM CAT
FEATURE COMPOUND{N, V, A, NOT}
FEATURE PRT{ABACK, ABOUT, ABOVE, ABROAD, ACROSS, AGAIN, AHEAD, ALONG, ALOUD, 
   APART, AROUND, ASIDE, AS, ASTRAY, AWAY, BACK, BEHIND, BY, DOWN, FAR, FLAT, 
   FOR, FORTH, FORWARD, FORWARDS, HOME, IN, INTO, LOOSE, LOW, OFF, ON, OPEN, 
   OUT, OVER, OVER_WITH, ROUND, THROUGH, TO, TOGETHER, UNDER, UP, UPON, 
   WASTE, WITH, WITHOUT}
FEATURE REG{+, -}
FEATURE ADDRESS{+, -}
FEATURE ARITY{0, 1, 2, 3, 4}
FEATURE COMPAR{INFL, YES, NO}
FEATURE DISTR{PRD, PST, ATT, PREPP}
FEATURE GROUP{+, -}
FEATURE ORDER{FREE, PRENP, POSTNP}
FEATURE PREMOD{+, -}
FEATURE PREP{ABOUT, AGAINST, AS, AT, BY, FOR, FROM, IN, OF, ON, OUT_OF, TO, 
   UPON, WITH, LOC}
FEATURE SUBTYPE{ASIF, IF, EQUI, EQU_EXTRAP, EXTRAP, PVERB, PVERB_OE, 
   PVERB_OR, RAIS, READY, SILLY, TOUGH, NONE, DMOVT, DEO}
FEATURE CN1{ZERO, TEN, TEEN, TY, HUN, THOU}
FEATURE CN2{BIG, SMALL, -}
FEATURE AND{+, -}
FEATURE TAG{VAL1, VAL2}
FEATURE AGR CAT
FEATURE NOSLASH{+, -}
FEATURE NULL{+, -}
FEATURE CN3{A, ONE}
FEATURE CN4{+, -}
FEATURE QFEAT{+, -, NO}
FEATURE UDC{+, -}
FEATURE CONEG{+, -}
FEATURE DEMON{+, -}
FEATURE ELLIP{+, -}
FEATURE RANGEOP{PRE, IN}
FEATURE MODTYPE{NML, VBL}
FEATURE COADV{+, -}
FEATURE KIND{+, -}
FEATURE FRACT{+, -}
FEATURE SO{+, -}
FEATURE GRADE{+, -}
FEATURE AFFREG{+, ODD1, ODD2}
\end{verbatim}
{\bf ; set declarations}
\begin{verbatim}
SET VERBALHEAD = {PRD, FIN, AUX, VFORM, PAST, AGR, PRO}
SET NOMINALHEAD = {PLU, POSS, CASE, PRD, PN, PRO, PROTYPE, COUNT, NFORM, PER, 
   REFL, NUM, DEMON, ADV, PART}
SET PREPHEAD = {PRO, PFORM, LOC, PRD, MODTYPE}
SET ADJHEAD = {PRD, QUA, ADV, NUM, NEG, AGR, DEF, PART, COADV, GRADE}
SET FOOT = {WH, UB, EVER}
SET AGRFEATS = {NFORM, PLU, COUNT, PER, CASE}
SET CONJ_NOMHEAD = {POSS, CASE, PRD, NFORM, DEF, PART, ADV, AFORM}
SET CONJ_ADJHEAD = {ADV, AGR, QUA, GRADE}
SET CONJ_VERBHEAD1 = {PRD, FIN, VFORM, AGR, PAST}
SET MORPHOLOGYONLY = {AT, LAT, COMPOUND, FIX, INFL, STEM, REG, ARITY, AFFREG, 
   COMPAR}
SET WHEAD = {N, V, INFL, PAST, AFORM, VFORM, PLU, AT, NUM, REG, LAT, PRD, 
   FIN, COUNT, QUA, PRO, PER, NFORM, POSS, PSVE, GRADE}
SET WDAUGHTER = {SUBCAT, AUX, PFORM, PRT, PREP, PROTYPE, ADV, AGR, SUBTYPE, 
   INV, NEG, CONJ, ORDER, ADDRESS, PN, PART}
SET CONJ_VERBHEAD2 = {PRD, FIN, VFORM, AGR, PRO}
\end{verbatim}
{\bf ; alias declarations}
\begin{verbatim}
ALIAS +N = [N +].
ALIAS +V = [V +].
ALIAS V = [V +, N -, BAR 0].
ALIAS N = [N +, V -, BAR 0].
ALIAS A = [V +, N +, BAR 0].
ALIAS P = [V -, N -, BAR 0].
ALIAS P1 = [N -, V -, BAR 1].
ALIAS N1 = [N +, V -, BAR 1].
ALIAS VP = [N -, V +, BAR 2, SUBJ -].
ALIAS A1 = [N +, V +, BAR 1].
ALIAS N2 = [N +, V -, BAR 2].
ALIAS A2 = [N +, V +, BAR 2].
ALIAS S = [N -, V +, BAR 2, SUBJ +].
ALIAS P2 = [N -, V -, BAR 2].
ALIAS V2 = [V +, N -, BAR 2].
ALIAS ADVP = [BAR 2, ADV +].
ALIAS DetN = [SUBCAT DETN, QUA +].
ALIAS DetA = [SUBCAT DETA].
ALIAS H = [H +, BAR 0].
ALIAS H1 = [BAR 1, H +].
ALIAS H2 = [BAR 2, H +].
ALIAS X = [].
ALIAS X0 = [BAR 0].
ALIAS X1 = [BAR 1].
ALIAS X2 = [BAR 2].
ALIAS BSE = [VFORM BSE].
ALIAS EN = [VFORM EN].
ALIAS TO = [VFORM TO].
ALIAS ING = [VFORM ING].
ALIAS PSP = [VFORM EN, PRD -].
ALIAS PAS = [VFORM EN, PRD +].
ALIAS PRP = [VFORM ING, PRD +].
ALIAS GER = [VFORM ING, PRD -].
ALIAS IMP = [FIN +, VFORM BSE].
ALIAS +PRD = [PRD +].
ALIAS -PRD = [PRD -].
ALIAS +GER = [GERUND +].
ALIAS -GER = [GERUND -].
ALIAS +POSS = [POSS +].
ALIAS -POSS = [POSS -].
ALIAS +ADV = [ADV +].
ALIAS -ADV = [ADV -].
ALIAS +INV = [INV +].
ALIAS -INV = [INV -].
ALIAS +NOM = [CASE NOM].
ALIAS +ACC = [CASE ACC].
ALIAS +NEG = [NEG +].
ALIAS -NEG = [NEG -].
ALIAS +FIN = [FIN +].
ALIAS -FIN = [FIN -].
ALIAS +SUBJ = [SUBJ +].
ALIAS -SUBJ = [SUBJ -].
ALIAS +LOC = [LOC +].
ALIAS -AUX = [AUX -].
ALIAS +AUX = [AUX +].
ALIAS +DEF = [DEF +].
ALIAS -DEF = [DEF -].
ALIAS +SPEC = [SPEC +].
ALIAS -SPEC = [SPEC -].
ALIAS +PLU = [PLU +].
ALIAS -PLU = [PLU -].
ALIAS +PRO = [PRO +].
ALIAS -PRO = [PRO -].
ALIAS +QUA = [QUA +].
ALIAS -QUA = [QUA -].
ALIAS +COUNT = [COUNT +].
ALIAS -COUNT = [COUNT -].
ALIAS CARD = [NUM CARD].
ALIAS ORD = [NUM ORD].
ALIAS -NUM = [NUM -].
ALIAS +R = [UB R].
ALIAS +Q = [UB Q].
ALIAS +WH = [WH +].
ALIAS -WH = [WH -].
ALIAS +EVER = [EVER +].
ALIAS -EVER = [EVER -].
ALIAS by = [PFORM BY].
ALIAS that = [COMP THAT].
ALIAS er = [AFORM ER].
ALIAS est = [AFORM EST].
ALIAS as = [AFORM AS].
ALIAS +PN = [PN +].
ALIAS NOSLASH = [NOSLASH +].
\end{verbatim}
{\bf ; category declarations}
\begin{verbatim}
CATEGORY VERB : [N -, V +] => VERBALHEAD.
CATEGORY V : V => {NEG, INV, PSVE, SUBTYPE, CONJ}.
CATEGORY VP : VP => {NEG, CONJ}.
CATEGORY NOUN : [N +, V -] => NOMINALHEAD.
CATEGORY PRONOUN : N[+PRO] => {DEF, AFORM, WH, UB, EVER}.
CATEGORY N : N => {CONJ}.
CATEGORY N1 : N1 => {MOD, WH, UB, EVER, CONJ, DEF, COADV}.
CATEGORY N2 : N2 => {SPEC, DEF, NEG, AFORM, CONJ, QFEAT, COADV, KIND}.
CATEGORY ADJ : [N +, V +] => ADJHEAD.
CATEGORY ADJ2 : [N +, V +] => {AFORM, DISTR, CONJ}.
CATEGORY A1 : A1 => {WH, UB, EVER}.
CATEGORY PREP : [N -, V -] => PREPHEAD.
CATEGORY PROPREP : P[+PRO] => {WH, UB, EVER}.
CATEGORY P : P => {SUBCAT, NEG, CONJ}.
CATEGORY P1 : P1 => {POSS, GERUND, WH, UB, EVER}.
CATEGORY P2 : P2 => {POSS, GERUND, NEG, CONJ}.
CATEGORY S : S => {COMP, INV, CONJ}.
CATEGORY DETN : [QUA +, SUBCAT DETN] => {DEF, POSS, AGR, WH, UB, EVER, DEMON}.
CATEGORY DETA : DetA => {AFORM, DISTR, WH, UB, EVER}.
CATEGORY AGR1 : (AGR) N2 => {PLU, PER, COUNT, NFORM, CASE}.
CATEGORY AGR2 : (AGR) V2 => {FIN, SUBJ, VFORM, UB}.
CATEGORY AGR3 : (AGR) [N +, V -] => {BAR, PLU, PER, COUNT, NFORM, CASE}.
CATEGORY AGR4 : (AGR) [CASE NOM] => {N, V, BAR}.
CATEGORY COORD : [BAR] => {COORD}.
CATEGORY SUBTYPE : [V +, BAR 0] => {SUBTYPE}.
CATEGORY X2a : [BAR 2, PRD +, ~N, ~ADV] => {NEG, AGR}.
CATEGORY X2b : [BAR 2, ~N, +ADV] => {NEG, PRD, QUA, LOC}.
CATEGORY NUM : [CN2 (BIG, SMALL, -, @)] => {AND, CN4}.
CATEGORY CFOOT1 : [BAR (2, 1), ~SUBJ] => FOOT.
CATEGORY CFOOT2 : S => FOOT.
CATEGORY CFOOT3 : [BAR 0, V -, PRO +] => FOOT.
CATEGORY CFOOT4 : [UB] => {WH, EVER}.
CATEGORY CSLASH : [BAR (1, 2)] => {SLASH}.
CATEGORY SLASH_X2 : (SLASH) X2
    => {N, V, PLU, COUNT, PER, NFORM, CASE, PFORM, LOC, GERUND, ADV, PRD, 
      QUA, SUBJ}.
CATEGORY MOD/ADV : [BAR 2, ADV +, ~N] => {CONJ}.
CATEGORY UDC : S => {UDC}.
CATEGORY CONEG : V[AUX +] => {CONEG}.
CATEGORY BEGAP : X2 => {BEGAP}.
CATEGORY CELLIP : V2 => {ELLIP}.
CATEGORY CELLIP2 : X2[~N] => {ELLIP}.
\end{verbatim}
{\bf ; top declaration}
\begin{verbatim}
TOP [T S], [T NP].
\end{verbatim}
{\bf ; propagation rules}
\begin{verbatim}
PROPRULE PROP_NV : ; copy value of V and N from mother to head daughter
   [V (+, -), N (+, -)] --> [H +], U. F(1) = F(0), F in {V, N}.
PROPRULE HFC_VERBAL : ; head feature propagation for verbal categories
   [N -, V +] --> [H +], U. F(0) = F(1), F in VERBALHEAD.
PROPRULE HFC_NOMINAL : ; head feature propagation for nominal categories
   [N +, V -] --> [H +], U. F(0) = F(1), F in NOMINALHEAD.
PROPRULE HFC_ADJ : ; head feature propagation for adjectival categories
   [N +, V +] --> [H +], U. F(0) = F(1), F in ADJHEAD.
PROPRULE DISTR/ADJ : ; DISTR propagates like a head feature except where it
                     ; is already mentioned in a rule (i.e. the A1/DEGMOD*
                     ; rules).
   [N +, V +, ~DISTR] --> [H +], U. DISTR(0) = DISTR(1).
PROPRULE HFC_PREP : ; head feature propagation for prepositional categories
   [N -, V -] --> [H +], U. F(0) = F(1), F in PREPHEAD.
PROPRULE SS : ; to pass nonhead features between S mother and S head
   S --> [H +, +SUBJ], U. F(0) = F(1), F in {COMP, INV}.
PROPRULE PP : ; POSS and GERUND not head features (only appear on P2 and P1)
              ; since the values come from the NP not from P. This passes
              ; them from a P2 mother to either a P1 or a P2 head daughter.
   P2 --> [H +, BAR (1, 2)], U. F(0) = F(1), F in {POSS, GERUND}.
PROPRULE VP/NEG : ; passes NEG (not a head feature) from a V to its mother
   VP --> H, U. NEG(0) = NEG(1).
PROPRULE LEX/SUBCAT : ; to propagate SUBCAT in rules with [BAR 0] mothers.
   [BAR 0, N @n, V @v] --> [BAR 0, N @n, V @v], U. SUBCAT(0) = SUBCAT(1).
PROPRULE LEX/SUBTYPE : ; to propagate SUBTYPE from lexical +V mothers to
                       ; their lexical heads.
   [V +, BAR 0] --> [V +, BAR 0, H +], U. SUBTYPE(0) = SUBTYPE(1).
PROPRULE COORD/NOMHEAD : ; propagates a subset of nominalhead features
                         ; between an N2 mother and its conjunct daughters -
                         ; in effect the conjuncts are partial heads.
   N2[COORD +] --> N2[CONJ], U. F(0) = F(1), F in CONJ_NOMHEAD.
PROPRULE COORD/ADJHEAD : ; passes CONJ_ADJHEAD features between a mother and
                         ; its adjectival conjunct daughters
   [N +, V +, COORD +] --> [CONJ], U. F(0) = F(1), F in CONJ_ADJHEAD.
PROPRULE COORD/PREPHEAD : ; propagates features between a prepositional
                          ; mother (P2, P) and its conjunct daughters - in
                          ; effect the conjuncts are partial heads
   [V -, N -, COORD +] --> [V -, N -, CONJ], U. 
   F(0) = F(1), F in {PFORM, PRD, LOC, MODTYPE}.
PROPRULE COORD/VERBHEAD1 : ; passes CONJ_VERBHEAD1 features between a V
                           ; mother and its conjunct daughters.
   V[COORD +] --> V[CONJ], U. F(0) = F(1), F in CONJ_VERBHEAD1.
PROPRULE COORD/VERBHEAD2 : ; passes CONJ_VERBHEAD2 features between a VP
                           ; mother and its conjunct daughters.
   VP[COORD +] --> VP[CONJ], U. F(0) = F(1), F in CONJ_VERBHEAD2.
PROPRULE COORD/S : ; to pass features between an S mother and its conjunct
                   ; daughters
   S[COORD +] --> S[CONJ], U. F(0) = F(1), F in {COMP, INV, FIN, VFORM}.
PROPRULE COORD/P2 : ; ensures that P2 conjuncts share POSS and GERUND with
                    ; their mother.
   P2[COORD +] --> P2[CONJ], U. F(0) = F(1), F in {POSS, GERUND}.
PROPRULE COORD/N : ; ensures that conjoined Ns have the same PN and PRO
                   ; values
   N[COORD +] --> N[CONJ], U. F(0) = F(1), F in {PN, PRO}.
PROPRULE COORD/A : ; ensures that conjoined As have the same AFORM value
   A[COORD +] --> A[CONJ], U. AFORM(0) = AFORM(1).
PROPRULE COORD/PRD : ; to propagate AGR in +PRD coordinations.
   X2[+PRD, COORD +] --> X2[+PRD, CONJ], U. AGR(0) = AGR(1).
PROPRULE CONJ/PRD : ; to propagate AGR in +V, +PRD conjuncts
   X2[PRD +, CONJ (NULL, @)] --> [BAR 2, V +, +PRD], U. AGR(0) = AGR(1).
PROPRULE PDEF1 : ; binds DEF and AFORM on N[+PRO] to mother N2[+SPEC]
   N2[+SPEC] --> H[PRO +]. F(0) = F(1), F in {DEF, AFORM}.
PROPRULE PDEF2 : ; binds DEF on the N2 heads of the partitive rules to their
                 ; mothers
   N2[+SPEC] --> N2[H +, SPEC +, PART (OF, NO_OF, OF2)], U. DEF(0) = DEF(1).
PROPRULE PDEF3 : ; binds DEF on [+QUA] (DetN or AP) to N2 mother
   N2 --> [+QUA], U. DEF(0) = DEF(1).
PROPRULE A2/AFORM : ; passes AFORM (er, as etc) from A1 to A2.
   A2 --> [H +], U. AFORM(0) = AFORM(1).
PROPRULE A1/AFORM1 : ; the AFORM value of an A1 mother in a lexical id rule
                     ; is passed from the head daughter
   A1 --> H, W. AFORM(0) = AFORM(1).
PROPRULE A1/AFORM2 : ; the AFORM value of an A1 mother in a non-lexical id
                     ; rule comes from the DetA (more stupid, as stupid)
   A1 --> DetA, H1. AFORM(0) = AFORM(1).
PROPRULE AGR/NP_VP : ; binds feature values on subject N2 to feature values
                     ; on the category that is the value of VP[AGR]
   S --> N2, H2[-SUBJ, AGR N2], U. F(1) = F(2[AGR]), F in AGRFEATS.
PROPRULE AGR/NP_VP2 : ; binds N2 and VP in N2+/FREEREL2
   N2 --> N2, VP[AGR N2, FIN +], U. F(1) = F(2[AGR]), F in AGRFEATS.
PROPRULE AGR/V2_VP : ; five kinds of V2 subject are possible (see id rules
                     ; S/V2_SUBJ1-S/V2_SUBJ5). This proprule binds the
                     ; appropriate features between V2 and AGR V2.
   S --> V2, H2[-SUBJ, AGR V2]. F(1) = F(2[AGR]), F in {FIN, SUBJ, VFORM}.
PROPRULE AGR/NOM : ; binds AGR features on +QUA categories to features on
                   ; their nominal head sisters.
   N2 --> [+QUA, AGR +N], [H +], U. F(1[AGR]) = F(2), F in {PLU, COUNT}.
PROPRULE AGR/NOM2 : ; specifiers which are sisters to N2[-SPEC] must also
                    ; agree with the QFEAT value of the N2[-SPEC].
   N2 --> [+QUA, AGR +N], H2[SPEC -], U. QFEAT(1[AGR]) = QFEAT(2).
PROPRULE SUBJ_CONTROL1 : ; establishes subject control agreement pattern for
                         ; subject raising and subject equi predicates by
                         ; binding AGR on the VP/AP complement to AGR on the
                         ; VP/AP mother.
   [V +] --> H[SUBTYPE (RAIS, EQUI)], [V +, BAR 2]. AGR(0) = AGR(2).
PROPRULE SUBJ_CONTROL2 : ; agreement binding for phrasal subject control
                         ; verbs.
   [V +] --> H[SUBTYPE (RAIS, EQUI, PVERB_OE)], [V +, BAR 2], [PRT @]. 
   AGR(0) = AGR(2).
PROPRULE SUBJ_CONTROL3 : ; agreement binding for prepositional subject
                         ; control verbs.
   [V +] --> H[SUBTYPE (RAIS, EQUI)], [V +, BAR 2], [PFORM @]. 
   AGR(0) = AGR(2).
PROPRULE SUBJ_CONTROL4 : ; subject control for various passive VPs -
                         ; VP/OR*/PASS and some outputs of PASSIVE.
   VP[PAS] --> H[SUBTYPE (EQUI, RAIS)], [V +, BAR 2], P2[by], W. 
   AGR(0) = AGR(2).
PROPRULE SUBJ_CONTROL5 : ; for verbs like 'promise' and 'strike as' which
                         ; appear with an object but are actually subject
                         ; control.
   VP --> H[SUBCAT (SC_NP_INF, SC_NP_AP)], [V +, BAR 2], W. AGR(0) = AGR(2).
PROPRULE SUBJ_CONTROL6 : ; subject control agreement pattern for auxiliary
                         ; rules.
   V2[+AUX] --> H, [V +, BAR 2, ~COMP]. AGR(0) = AGR(2).
PROPRULE AGR/INV : ; to bind subject NP to AGR value on verb in inverted
                   ; sentences.
   S[+INV] --> H, N2[+NOM], W. 
   F(1[AGR]) = F(2), F in {N, V, BAR, NFORM, PLU, COUNT, PER, CASE}.
PROPRULE OBJ_CONTROL : ; establishes object control agreement pattern by
                       ; binding AGR on the VP complement to the N2 object.
   VP --> H, N2, [V +, BAR 2, AGR N2[~NFORM]], W. 
   F(2) = F(3[AGR]), F in {PLU, PER, COUNT, NFORM}.
PROPRULE SLASH/AGR_NP1 : ; agreement between preposed N2 and the category
                         ; value of SLASH
   V2 --> N2, V2[SLASH N2]. 
   F(1) = F(2[SLASH]), F in {NFORM, PLU, COUNT, PER, CASE, PRD, ADV}.
PROPRULE SLASH/AGR_NP2 : ; to bind N2 and [SLASH N2] in N2+/FREEREL and
                         ; N2+/COMPAR3 -- they mustn't agree for CASE.
   N2 --> N2, V2[SLASH N2]. 
   F(1) = F(2[SLASH]), F in {NFORM, PLU, COUNT, PER, PRD, ADV}.
PROPRULE SLASH/AGR_NP3 : ; operates on the output of STM2a&b
   [V +, BAR (1, 2), SLASH N2] --> VP[SLASH NOSLASH, +FIN], W. 
   F(0[SLASH]) = F(1[AGR]), F in {N, V, BAR, NFORM, PLU, COUNT, PER, CASE}.
PROPRULE SLASH/AGR_PP1 : ; agreement between preposed P2 and the category
                         ; value of SLASH
   S --> P2, S[H +, SLASH P2]. 
   F(1) = F(2[SLASH]), F in {LOC, PFORM, GERUND, PRD}.
PROPRULE SLASH/AGR_PP2 : ; agreement between P2 and the value of SLASH in
                         ; VP/BE_CLEFT2
   V2 --> P2, S[+FIN, SLASH P2], W. 
   F(1) = F(2[SLASH]), F in {LOC, PFORM, GERUND, PRD}.
PROPRULE SLASH/AGR_AP : ; agreement between preposed A2/A1 and the category
                        ; value of SLASH
   X2 --> [N +, V +, BAR (1, 2)], S[SLASH A2]. 
   F(1) = F(2[SLASH]), F in {ADV, QUA, PRD}.
PROPRULE PFOOT1 : ; binds FOOT features between P1/N1 and their P2 or N2
                  ; complements.
   [V -, BAR 1, POSS (-, @)] --> H, [V -, BAR 2]. F(0) = F(2), F in FOOT.
PROPRULE PFOOT2 : ; binds FOOT features in rules for pro-N2 and pro-P2.
   [V -, BAR 2, PRO +] --> H. F(0) = F(1), F in FOOT.
PROPRULE PFOOT3 : ; binds FOOT features in finite S rules - they propagate
                  ; from the N2 subject.
   S[COMP NORM, FIN +] --> N2, U. F(0) = F(1), F in FOOT.
PROPRULE PFOOT4 : ; binds FOOT features in UDC S.
   S[UDC +] --> X2, H2. F(0) = F(1), F in FOOT.
PROPRULE PFOOT5 : ; propagates FOOT features between BAR 2 (non-verbal)
                  ; categories and their BAR 2 or BAR 1 heads.
   [BAR 2, ~SUBJ, ~T] --> [H +, BAR (1, 2), ~WH], U. F(0) = F(1), F in FOOT.
PROPRULE PFOOT6 : ; propagates FOOT features between [N +, BAR 1] categories
                  ; and their BAR 1 heads.
   [N +, BAR 1, ~WH] --> H1, U. F(0) = F(1), F in FOOT.
PROPRULE PFOOT7 : ; propagates FOOT features in (non-verbal, non-lexical)
                  ; coordinations.
   [BAR (1, 2), ~VFORM, COORD +] --> [CONJ], U. F(0) = F(1), F in FOOT.
PROPRULE PFOOT8 : ; binds FOOT features in S coordinations and conjuncts
   S[~WH, ~UB, ~EVER, COMP @] --> S[~WH, ~UB, ~EVER], [~ADV]. 
   F(0) = F(1), F in FOOT.
PROPRULE PSLASH1 : ; propagates SLASH between a mother and its BAR 1 or BAR
                   ; 2 head.
   [~SLASH, ~T] --> [H +, BAR (1, 2), ~SLASH], U. SLASH(0) = SLASH(1).
PROPRULE PSLASH2 : ; the purpose of PSLASH2-PSLASH6 is to set up SLASH
                   ; propagation in lexical idrules. For each non-lexical
                   ; idrule, just one complement daughter must be bound to
                   ; the mother. If a rule contains an N2 that will be the
                   ; complement that is bound; if there is no N2 then an A2
                   ; will be bound; if there's no N2 or A2 then P2 will be
                   ; bound; if there's no N2/A2/P2 then a V2 will be bound.
                   ; This proprule matches lexical rules which contain an
                   ; N2[-PRD] complement and propagates SLASH between the
                   ; mother and that complement. This only affects rules
                   ; where the N2 is stipulated to be [-PRD] rather than
                   ; ones where the N2 becomes [-PRD] by default (proprules
                   ; apply before defrules). In effect this picks up rules
                   ; with two N2s and chooses the N2 marked [-PRD] to be the
                   ; one that gets bound to the mother.
   [~SLASH] --> [H +, BAR 0], N2[-PRD], N2, W. SLASH(0) = SLASH(2).
PROPRULE PSLASH3 : ; matches lexical rules which contain an N2 complement
                   ; and propagates SLASH between the mother and that
                   ; complement. In effect this picks up rules where only
                   ; one of the complements is an N2. The [~SLASH] ensures
                   ; that rules affected by previous PSLASH proprules won't
                   ; match.
   [~SLASH] --> [H +, BAR 0], N2, W. SLASH(0) = SLASH(2).
PROPRULE PSLASH4 : ; matches lexical rules which contain an A2 complement
                   ; and propagates SLASH between the mother and that
                   ; complement. The [~SLASH] ensures that rules affected by
                   ; previous PSLASH proprules won't match so this won't
                   ; apply to rules with N2 daughters.
   [~SLASH] --> [H +, BAR 0], A2, W. SLASH(0) = SLASH(2).
PROPRULE PSLASH5 : ; matches lexical rules which contain an P2 complement
                   ; and propagates SLASH between the mother and that
                   ; complement. The [~SLASH] ensures that rules affected by
                   ; previous PSLASH proprules won't match so this won't
                   ; apply to rules with N2 or A2 daughters.
   [~SLASH] --> [H +, BAR 0], P2, W. SLASH(0) = SLASH(2).
PROPRULE PSLASH6 : ; matches lexical rules which contain an V2 complement
                   ; and propagates SLASH between the mother and that
                   ; complement. The [~SLASH] ensures that rules affected by
                   ; previous PSLASH proprules won't match so this won't
                   ; apply to rules with N2/A2/P2 daughters.
   [~SLASH] --> [H +, BAR 0], V2, W. SLASH(0) = SLASH(2).
PROPRULE PSLASH7 : ; propagates SLASH in CONJ/PRD* and CONJ/MOD*
   [~SLASH, CONJ (NULL, @)] --> [BAR 2, ~H], U. SLASH(0) = SLASH(1).
PROPRULE PSLASH8 : ; propagates SLASH in BAR 1 and BAR 2 coordinations
   [BAR (1, 2), COORD +] --> [CONJ, BAR (1, 2)], U. SLASH(0) = SLASH(1).
PROPRULE PSLASH9 : ; binds features on SLASH X2s introduced by SLASH
                   ; metarules.
   [SLASH X2] --> [SLASH X2], U. 
   F(0[SLASH]) = F(1[SLASH]), F in {N, V, NFORM, PER, PLU, COUNT, CASE, 
            PFORM, LOC, GERUND, ADV, PRD, QUA, SUBJ}.
PROPRULE PSLASH10 : ; operates on output of passive metarule - chooses the
                    ; P2[by] complement as the one to be bound to the
                    ; mother.
   VP[PAS, AGR N2[NFORM NORM], SLASH @] --> P2[by], W. SLASH(0) = SLASH(1).
PROPRULE SPEC/COORD : ; to make N2 conjuncts agree for SPEC and QFEAT
   N2[COORD +] --> N2[CONJ], U. F(0) = F(1), F in {SPEC, QFEAT}.
PROPRULE AUX/CONEG : ; binds CONEG on an aux to NEG on its complement -- to
                     ; ensure the proper distribution of "not".
   VP[+AUX] --> H[SUBCAT (DO, BE, HAVE, FUT)], X2. CONEG(1) = NEG(2).
PROPRULE COORD/MOD : ; to propagate QUA in +ADV coordinations.
   X2[+ADV, COORD +] --> X2[+ADV, CONJ], U. QUA(0) = QUA(1).
PROPRULE PRD/MOD/NEG : ; passes NEG in the PRD? rules and the X2/MOD? rules.
   X2[~N, ~T] --> X2[N (+, -)]. NEG(0) = NEG(1).
PROPRULE COADV1 : ; N1s with premodifiers have the same value for COADV and
                  ; ADV.
   N1[MOD PRE] --> U. COADV(0) = ADV(0).
PROPRULE COADV2 : ; N1s with postmodifiers have the same value for COADV and
                  ; ADV.
   N1[MOD POST] --> U. COADV(0) = ADV(0).
PROPRULE COADV3 : ; N2 inherits COADV from its head.
   N2 --> [H +, BAR (1, 2)], U. COADV(0) = COADV(1).
PROPRULE COADV4 : ; N1s must agree with A2 modifiers for ADV/COADV - ensures
                  ; that A2s like "ago" can only appear with +ADV nouns.
   N1 --> H1, A2. ADV(1) = COADV(2).
PROPRULE X2/NEG : ; to propagate NEG in CONJ/PRD and CONJ/MOD*
   X2[~N] --> [CONJN +], X2. NEG(0) = NEG(2).
\end{verbatim}
{\bf ; default rules}
\begin{verbatim}
DEFRULE DEF_BAR0 : ; lexical heads are BAR 0
   [] --> [H +, SUBCAT], U. BAR(1) = 0.
DEFRULE DSUBTYPE : ; SUBTYPE on verbs and adjs defaults to NONE.
   [V +, BAR (1, 2)] --> H[~SUBTYPE], W. SUBTYPE(1) = NONE.
DEFRULE S/SSUBJ : ; S with V2 subject is finite.
   S --> V2, H2. FIN(2) = +.
DEFRULE V2_VFORM : ; defaults -FIN onto rhs VPs and Ss which have a VFORM
                   ; value. Only imperatives are [VFORM BSE, FIN +] and the
                   ; imperative rule is marked as such.
   [] --> V2[VFORM (BSE, ING, EN, TO)], U. FIN(1) = -.
DEFRULE VFORM_NOT : ; defaults all finite VPs and S's to VFORM NOT except
                    ; the S dominated by T (since this could be imperative).
   [~T] --> V2[FIN +], U. VFORM(1) = NOT.
DEFRULE AUX : ; lhs VP defaults to [AUX -]
   VP --> W. AUX(0) = -.
DEFRULE VP/PRD : ; defaults rhs VP to -PRD so the only time passives or
                 ; present participles will appear is after 'be' (and as an
                 ; N modifier)
   [~CONJ] --> VP[~CONJ], W. PRD(1) = -.
DEFRULE DVP/PRO : ; lhs VPs default to PRO -.
   VP --> W. PRO(0) = -.
DEFRULE INV : ; VPs are not inverted by default.
   VP --> [H +, SUBCAT], W. INV(1) = -.
DEFRULE S/INV : ; rhs Ss default to -INV
   [] --> S, W. INV(1) = -.
DEFRULE V/PASS : ; defaults all passive verbs to PSVE +.
   VP --> H[VFORM EN, PRD +], W. PSVE(1) = +.
DEFRULE V/UNPASS : ; defaults all other verbs to PSVE -. (To ensure that
                   ; passive verbs won't match active rules.)
   VP --> H, W. PSVE(1) = -.
DEFRULE VP/AGR1 : ; non-aux, non-raising VPs default to AGR N2[NFORM NORM]
   VP[-AUX] --> 
   H[SUBTYPE (EQUI, EQU_EXTRAP, EXTRAP, PVERB, PVERB_OE, PVERB_OR, DMOVT, 
            NONE)], W. AGR(0) = N2[NFORM NORM].
DEFRULE VP/AGR2 : ; non-passive object raising verbs are AGR N2[NFORM NORM]
   VP --> 
   H[SUBCAT (OC_AP, OC_BSE, OC_INF, OC_ING, OC_NP, OC_PASS, OC_PP_BSE, 
            OC_PP_INF, OC_PP_ING), PSVE -], W. AGR(0) = N2[NFORM NORM].
DEFRULE AGRV2a : ; VPs which take V2 subjects don't usually agree with WH
                 ; V2s.
   S --> V2, H2[-SUBJ]. UB(2[AGR]) = -.
DEFRULE AGRV2b : ; [AGR V2] A1 and VP defaults to [AGR V2 [UB -]] - ie they
                 ; don't usually agree with WH V2s
   [V +, AGR V2[SUBJ]] --> W. UB(0[AGR]) = -.
DEFRULE A2/ADV : ; rhs A2s default to ADV -.
   [~COORD, ~COMP, ~GRADE] --> A2[~H], U. ADV(1) = -.
DEFRULE A2/PRD : ; A2 complements default to PRD +.
   [] --> A2[ADV -], W. PRD(1) = +.
DEFRULE A2/PART : ; rhs A2 defaults to -PART.
   [~COMP] --> A2, U. PART(1) = -.
DEFRULE A1/PRD1 : ; defaults all complement taking A1s to +PRD to prevent
                  ; them appearing in prenominal position.
   A1 --> H, X2, W. PRD(0) = +.
DEFRULE A1/PRD2 : ; defaults all AGR V2 A1s to +PRD to prevent them
                  ; appearing in prenominal position.
   A1[AGR V2] --> H, W. PRD(0) = +.
DEFRULE A1/DISTR1 : ; all complement taking rhs As are DISTR PRD.
   A1 --> H, [], W. DISTR(1) = PRD.
DEFRULE A1/DISTR2 : ; all AGR V2 As are DISTR PRD.
   A1[AGR V2] --> H, W. DISTR(1) = PRD.
DEFRULE A1/AGR : ; the AGR value of a non-raising, non-attributive A1
                 ; defaults to AGR N2[NFORM NORM].
   A1 --> 
   H[SUBTYPE (EQUI, EXTRAP, READY, SILLY, TOUGH, NONE), DISTR (PRD, PST, 
            PREPP)], [], W. AGR(0) = N2[NFORM NORM].
DEFRULE N2/CASE : ; defaults N2 complements (sisters of lexical heads) to
                  ; CASE ACC.
   [] --> N2, W. CASE(1) = ACC.
DEFRULE N2/POSS : ; defaults N2 daughters to POSS -.
   [] --> N2[~H], U. POSS(1) = -.
DEFRULE N2/SPEC : ; defaults N2 daughters to SPEC +.
   [] --> N2[~SPEC], U. SPEC(1) = +.
DEFRULE N2/ADV : ; defaults N2 daughters to ADV -.
   [~T, ~COORD] --> N2[~ADV], U. ADV(1) = -.
DEFRULE N2/PART1 : ; defaults N2 daughters to PART -.
   [~COORD] --> N2[~PART], U. PART(1) = -.
DEFRULE N2/PART2 : ; the N2 daughters in S1a and ELL/S1a default to PART -.
   [COORD (+, -)] --> N2[~PART, ~H], U. PART(1) = -.
DEFRULE NFORM1 : ; all N2s in non-agreement positions are NFORM NORM. This
                 ; and the next pick these out.
   [N +, V -] --> N2, U. NFORM(1) = NORM.
DEFRULE NFORM2 : ; N2 complements of (of non-raising) verbs default to NFORM
                 ; NORM
   VP --> H[SUBTYPE (@, NONE, EXTRAP, EQUI, PVERB_OE, EQU_EXTRAP, DMOVT)], 
   N2, W. NFORM(2) = NORM.
DEFRULE N2/AFORM1 : ; mothers in N2 rules default to [AFORM NONE].
   N2[~AFORM] --> U. AFORM(0) = NONE.
DEFRULE N2/AFORM2 : ; daughter N2s in [N +, V -] rules default to [AFORM
                    ; NONE].
   [N +, V -] --> N2[~AFORM], U. AFORM(1) = NONE.
DEFRULE N2/ADJ1 : ; for N2 mother in idrules N2/ADJ*
   N2 --> DetN, A2. 
   F(0) = -, F in {PN, PRO, POSS, NUM, COORD, REFL, PART, ADV}.
DEFRULE N2/ADJ2 : ; for A2 daughter in idrules N2/ADJ*
   N2 --> DetN, A2. F(2) = -, F in {PRD, NEG, QUA, NUM}.
DEFRULE N1/MOD : ; N1 has the feature MOD to control the order in which
                 ; modifiers attach. This defaults the MOD value to NONE
   N1 --> U. MOD(0) = NONE.
DEFRULE N1/PART : ; defaults the N1 pronoun rules to PART -.
   N1[PRO +] --> U. PART(0) = -.
DEFRULE N/POSS : ; defaults lhs nominal categories to -POSS (except mothers
                 ; of pronouns)
   [N +, V -, PRO (-, @)] --> U. POSS(0) = -.
DEFRULE N/PN : ; PN on mothers and heads in N rules defaults to -.
   [N +, V -, ~CONJ] --> [H +], U. PN(0) = -.
DEFRULE N/ADVPART : ; mothers in rules which build Ns default to -ADV,
                    ; -PART.
   N[~COORD] --> U. F(0) = -, F in {ADV, PART}.
DEFRULE NFEATS1 : ; defaults for various features in N rules (eg compounds,
                  ; names etc).
   N --> N, U. F(0) = -, F in {PRO, REFL, POSS, NUM}.
DEFRULE NFEATS2 : ; default for NFORM in N rules
   N --> N, U. NFORM(0) = NORM.
DEFRULE NFEATS3 : ; default for PER in N rules
   N --> N, U. PER(0) = 3.
DEFRULE CONJ/NUM : ; nominal conjuncts are -NUM.
   [N +, V -, CONJ (NULL, @)] --> U. NUM(0) = -.
DEFRULE BAR1/PRO : ; defaults -PRO onto N1 and P1 to prevent them from
                   ; dominating pro-forms.
   [V -, BAR 1] --> [H +, BAR 0], U. PRO(1) = -.
DEFRULE N2/PRO : ; defaults N2 to -PRO.
   N2 --> U. PRO(0) = -.
DEFRULE NEG1 : ; lhs NPs and PPs can only be negative if they appear in a
               ; coordinate structure
   [V -, BAR 2, ~CONJ] --> U. NEG(0) = -.
DEFRULE NEG2 : ; rhs NPs and PPs can only be negative if they appear in a
               ; coordinate structure
   [~CONJ] --> [V -, BAR 2, ~CONJ], U. NEG(1) = -.
DEFRULE NEG3 : ; rhs APs can only be negative if they appear in a coordinate
               ; structure.
   [~CONJ] --> A2[~CONJ], U. NEG(1) = -.
DEFRULE P/NEG1 : ; lhs Ps can only be negative if they appear in a
                 ; coordinate structure
   P[~CONJ] --> U. NEG(0) = -.
DEFRULE P/NEG2 : ; rhs Ps can only be negative if they appear in a
                 ; coordinate structure
   [~CONJ] --> P[~CONJ], U. NEG(1) = -.
DEFRULE P/SUBCAT : ; for the odd prepositions in some of the VP rules.
   [V +] --> P, V2, W. SUBCAT(1) = NP.
DEFRULE P2/POSS : ; rhs P2's default to -POSS
   [~NFORM] --> P2[~CONJ], U. POSS(1) = -.
DEFRULE P2/GER : ; ; rhs P2's default to -GERUND
   [~NFORM] --> P2[~GERUND, ~CONJ], U. GERUND(1) = -.
DEFRULE LOC/PFORM : ; PFORM on +LOC subcategorised P2 is NORM
   [] --> H, P2[+LOC], W. PFORM(2) = NORM.
DEFRULE P2/PRD : ; P2s default to +PRD.
   [] --> P2[PFORM NORM, ~H, ~PRD], U. PRD(1) = +.
DEFRULE DFOOT1 : ; nonverbal BAR 2 mothers that don't have FOOT features (ie
                 ; ones which haven't been affected by the FOOT proprules)
                 ; have value NO for all three FOOT features.
   X2[~SUBJ, ~WH, ~UB, ~EVER] --> U. F(0) = NO, F in FOOT.
DEFRULE DFOOT2 : ; nonverbal BAR 2 daughters that don't have FOOT features
                 ; (ie ones which haven't been affected by the FOOT
                 ; proprules) have value NO for all three FOOT features.
   [~T] --> X2[~SUBJ, ~WH, ~UB, ~EVER], U. F(1) = NO, F in FOOT.
DEFRULE DFOOT3 : ; S mothers that don't have FOOT features (ie ones which
                 ; haven't been affected by the FOOT proprules) have value
                 ; NO for all three FOOT features.
   S[~WH, ~UB, ~EVER, ~CONJ] --> U. F(0) = NO, F in FOOT.
DEFRULE DFOOT4 : ; S daughters that don't have FOOT features (ie ones which
                 ; haven't been affected by the FOOT proprules) have value
                 ; NO for all three FOOT features.
   [~CONJ] --> S[~WH, ~UB, ~EVER], U. F(1) = NO, F in FOOT.
DEFRULE DFOOT5 : ; BAR 1 mothers which haven't already acquired FOOT
                 ; features have value NO for all three.
   [BAR 1, ~WH, ~UB, ~EVER] --> H, U. F(0) = NO, F in FOOT.
DEFRULE DFOOT6 : ; BAR 1 daughters which haven't already acquired FOOT
                 ; features have value NO for all three.
   [] --> [BAR 1, ~WH, ~UB, ~EVER], U. F(1) = NO, F in FOOT.
DEFRULE DFOOT7 : ; defaults FOOT features on A2/COMPAR* and A2/NEG to NO.
   A2[~CONJ] --> H2, U. F(0) = NO, F in FOOT.
DEFRULE DSLASH1 : ; defaults NOSLASH onto mothers of the UDC rules -
                  ; prevents double extractions.
   S --> [BAR 2], S[SLASH X2]. SLASH(0) = NOSLASH.
DEFRULE DSLASH2 : ; all non-head daughters of non-lexical ID rules are SLASH
                  ; NOSLASH.
   [] --> [H +, BAR (1, 2)], X[BAR (1, 2), ~SLASH], U. SLASH(2) = NOSLASH.
DEFRULE DSLASH3 : ; block extraction out of whether and if clauses.
   [] --> [SUBCAT (WHETHER, IF)], U. SLASH(0) = NOSLASH.
DEFRULE DSLASH4 : ; defaults SLASH NOSLASH onto mothers of lexical unary
                  ; rules
   [BAR (1, 2)] --> [H +, BAR 0]. SLASH(0) = NOSLASH.
DEFRULE DSLASH5 : ; and ones with just a particle
   [] --> [H +, BAR 0], [PRT @]. SLASH(0) = NOSLASH.
DEFRULE DSLASH6 : ; UB Q and R daughters are SLASH NOSLASH
   [] --> [BAR (1, 2), UB (Q, R), SLASH @], U. SLASH(1) = NOSLASH.
DEFRULE DSLASH7 : ; UB Q and R daughters are SLASH NOSLASH
   [] --> [BAR (1, 2), UB (Q, R), ~SLASH], U. SLASH(1) = NOSLASH.
DEFRULE DSLASH8 : ; WH + mothers are SLASH NOSLASH.
   [WH +] --> U. SLASH(0) = NOSLASH.
DEFRULE DSLASH9 : ; daughters of T rules are SLASH NOSLASH.
   [T (S, NP)] --> []. SLASH(1) = NOSLASH.
DEFRULE DSLASH10 : ; complements which haven't received a SLASH value from
                   ; the proprules are SLASH NOSLASH.
   [SLASH @] --> [H +, BAR 0], [SLASH @], [BAR 2, ~SLASH], W. 
   SLASH(3) = NOSLASH.
DEFRULE DSLASH11 : ; blocks extractions out of AGR V2 categories - *who does
                   ; that Felix is a cat bother?
   [AGR V2] --> U. SLASH(0) = NOSLASH.
DEFRULE DSLASH12 : ; blocks extractions out of partitives with no "of".
   N2 --> X2[PART NO_OF], U. SLASH(0) = NOSLASH.
DEFRULE DUDC1 : ; defaults most S daughters to [UDC -] - restricts the
                ; distribution of subordinate S's with preposed elements.
   [~T, ~TAG, ~CONJ] --> S[UB (@, NO), ~CONJ], U. UDC(1) = -.
DEFRULE DUDC2 : ; defaults S mothers to UDC -.
   S[~UDC, ~CONJ, ~COORD] --> U. UDC(0) = -.
DEFRULE DPOST/PASS1 : ; the PASSIVE metarule binds SLASH between the mother
                      ; and the optional PP[by]. This means that when the
                      ; PP[by] is missing (as in *(PASSIVE/-)), there is no
                      ; proper SLASH propagation. The easiest solution is to
                      ; default the now unbound mother to SLASH NOSLASH and
                      ; then let metarules MSLASH4* pick up these rules and
                      ; create new slashed versions of them. This DEFRULE
                      ; and DPOST/PASS2 and DPOST/PASS3 pick out all the
                      ; *(PASSIVE/-) idrules (but not the *(PASSIVE/+)
                      ; ones).
   VP[PAS, SLASH @] --> [H +, BAR 0], X2[SLASH NOSLASH]. SLASH(0) = NOSLASH.
DEFRULE DPOST/PASS2 : VP[PAS, SLASH @] --> [H +, BAR 0], X2[SLASH NOSLASH], 
   [~SLASH]. SLASH(0) = NOSLASH.
DEFRULE DPOST/PASS3 : VP[PAS, AGR N2[NFORM NORM], SLASH @] --> [H +, BAR 0], 
   X2[SLASH NOSLASH], X2[SLASH NOSLASH]. SLASH(0) = NOSLASH.
DEFRULE DPOST/PASS4 : ; to control some of the ambiguity which would
                      ; otherwise arise from interactions of SLASH with the
                      ; multiple PPs in VP/NP_PP(PASSIVE/+),
                      ; VP/NP_PP_PHRA(PASSIVE/+), VP/NP_PP_PP(PASSIVE/+),
                      ; make all the PPs SLASH NOSLASH. Then a restricted
                      ; set of variants can be generated from these.
   VP[PAS] --> H[SUBCAT (NP_PP, NP_PP_PP)], P2[PFORM BY], W. 
   SLASH(2) = NOSLASH.
DEFRULE COORD1 : ; marks the mother of a coordinate structure as +COORD.
   X --> X[CONJ], X[CONJ (AND, OR, NOR, BUT)]. COORD(0) = +.
DEFRULE COORD2 : ; marks all other major category mothers as [COORD -].
   [BAR, ~COORD] --> U. COORD(0) = -.
DEFRULE COORD4 : ; makes daughters in unary rules [COORD -]. Cuts down on
                 ; spurious ambiguity by forcing coordination at the highest
                 ; possible BAR level.
   [BAR, ~T] --> [BAR]. COORD(1) = -.
DEFRULE CONJ1 : ; All BAR 2 major category mothers (except ones already
                ; marked for CONJ) are potential null-coordinator conjuncts.
                ; This marks them as such.
   [BAR 2, ~CONJ] --> U. CONJ(0) = NULL.
DEFRULE CONJ2 : ; all BAR 1 major category mothers (except P1 - no
                ; coordination of P1 exists) are potential null-coordinator
                ; conjuncts.
   [BAR 1, ~PFORM, ~CONJ] --> U. CONJ(0) = NULL.
DEFRULE CONJ3 : ; all [BAR 0] mothers are potential null-coordinator
                ; conjuncts.
   [BAR 0, ~CONJ] --> U. CONJ(0) = NULL.
DEFRULE CONJ4 : ; All BAR 2 major category daughters (except ones already
                ; marked for CONJ) must be CONJ NULL (ie conjuncts marked
                ; with 'and' etc can't turn up just anywhere).
   [] --> [BAR 2, ~CONJ], U. CONJ(1) = NULL.
DEFRULE CONJ5 : ; all BAR 1 major category daughters (except P1 - no
                ; coordination of P1 exists) must be CONJ NULL.
   [] --> [BAR 1, ~PFORM, ~CONJ], U. CONJ(1) = NULL.
DEFRULE CONJ6 : ; all [BAR 0] daughers must be CONJ NULL.
   [] --> [BAR 0, ~CONJ], U. CONJ(1) = NULL.
DEFRULE BEGAP1 : ; N2[-SPEC] can't be a gap.
   [] --> N2[-SPEC], U. BEGAP(1) = -.
DEFRULE BEGAP2 : ; conjuncts can't be gaps.
   [COORD +] --> X2[CONJ], U. BEGAP(1) = -.
DEFRULE BEGAP3 : ; the daughters of X2[+PRD] and X2[+MOD] can't be gaps.
   [BAR 2, ~N, ~V, CONJ (NULL, @)] --> X2, U. BEGAP(1) = -.
DEFRULE BEGAP4 : ; daughters which are required to be comparative can't be
                 ; gaps.
   [] --> X2[AFORM (ER, AS)], U. BEGAP(1) = -.
DEFRULE BEGAP5 : ; sisters of coordinators can't be gaps.
   X2[CONJ @x] --> [SUBCAT @x, CONJN +], X2. BEGAP(2) = -.
DEFRULE BEGAP6 : ; BAR 2 mothers default to [BEGAP -].
   [BAR 2, ~BEGAP, ~T] --> U. BEGAP(0) = -.
DEFRULE BEGAP7 : ; unslashed categories can't be gaps.
   [] --> [BAR 2, SLASH NOSLASH], U. BEGAP(1) = -.
DEFRULE BEGAP8 : ; Ss and VPs can't be gaps.
   [] --> V2, U. BEGAP(1) = -.
DEFRULE QFEAT1 : ; QFEAT indicates the presence of a quantifier attaching
                 ; under N2[-SPEC] -- lhs N2[+SPEC] is therefore marked as
                 ; [QFEAT NO].
   N2[+SPEC] --> U. QFEAT(0) = NO.
DEFRULE QFEAT2 : ; ditto for rhs N2[+SPEC].
   [] --> N2[+SPEC], U. QFEAT(1) = NO.
DEFRULE N2PRD : ; N2s tend to be non-predicatve.
   [] --> N2[~PRD], U. PRD(1) = -.
DEFRULE N2PRD2 : ; N2s with a possessive determiner are PRD -.
   N2 --> [POSS +], [H +]. PRD(0) = -.
DEFRULE N2PRD3 : ; partitive N2s are PRD -.
   N2[+SPEC] --> X2[PART (OF, OF2, NO_OF)], [PFORM OF], U. PRD(0) = -.
DEFRULE VPMOD/PRO : ; VP modifiers of N1 are PRO -.
   N1 --> H1, VP. PRO(2) = -.
DEFRULE DEMON1 : ; demonstratives can't be preposed.
   [] --> N2, S[SLASH (X2, @)], U. DEMON(1) = -.
DEFRULE DEMON2 : ; demonstrative pronouns can't be modified by V2s
   N1 --> H1, V2. DEMON(1) = -.
DEFRULE DELLIP1 : ; rhs V2s default to [ELLIP -].
   [] --> V2[~ELLIP], U. ELLIP(1) = -.
DEFRULE DELLIP2 : ; lhs V2s default to [ELLIP -].
   V2[~ELLIP, COORD -] --> U. ELLIP(0) = -.
DEFRULE DELLIP3 : ; coordinations of X2[+PRD] default to [ELLIP +].
   X2[+PRD, ~N, COORD +] --> U. ELLIP(0) = +.
DEFRULE DELLIP4 : ; other cases of X2[+PRD] default to [ELLIP -].
   X2[+PRD, ~ELLIP, ~N] --> U. ELLIP(0) = -.
DEFRULE N1/ADV : ; default some modified N1s to [ADV -], i.e. restrict the
                 ; type of postmodification that can occur with adverbial
                 ; nouns.
   N1 --> H1, VP. ADV(0) = -.
DEFRULE DCOADV : ; default N1 mothers of lexical id rules to [COADV -].
   N1 --> W. COADV(0) = -.
DEFRULE SLASH_QUA1 : ; for daughter categories which are [SLASH [QUA +]]
                     ; (see the comparative rules N2+/COMPAR* and
                     ; A2/COMPAR*) - add [BAR 2] to the SLASH specification.
   [] --> [SLASH [QUA +]], U. BAR(1[SLASH]) = 2.
DEFRULE SLASH_QUA2 : ; for mother categories which are [SLASH [QUA +]] (see
                     ; the comparative rules N2+/COMPAR* and A2/COMPAR*) -
                     ; add [BAR 2] to the SLASH specification.
   [SLASH [QUA +]] --> U. BAR(0[SLASH]) = 2.
DEFRULE SLASH_QUA3 : ; for daughter categories which are [SLASH X2] - add
                     ; [QUA -] to the SLASH specification.
   [] --> [SLASH X2[~QUA]], U. QUA(1[SLASH]) = -.
DEFRULE SLASH_QUA4 : ; for mother categories which are [SLASH X2] - add [QUA
                     ; -] to the SLASH specification.
   [SLASH X2[~QUA]] --> U. QUA(0[SLASH]) = -.
DEFRULE A/GRADE : ; mothers in A rules default to [GRADE -].
   A[COORD -, CONJ NULL] --> []. GRADE(0) = -.
\end{verbatim}
{\bf ; LP rules}
\begin{verbatim}
LPRULE LP1A : ; categories with either a concrete value or a variable value
              ; for the feature SUBCAT precede categories which don't have a
              ; SUBCAT specification. i.e. lexical heads precede their
              ; complements, complementisers precede S, conjunction words
              ; precede conjuncts, determiners and degree specifiers precede
              ; +N heads etc.
   [SUBCAT @s] < [~SUBCAT].
LPRULE LP1B : ; lprules LP1B and LP1C order categories which both have
              ; SUBCAT. This makes lexical heads precede non-head lexical
              ; categories except for the heads of compounds (SUBCAT NULL)
              ; which are final).
   V[H +] < H[N +, SUBCAT (OFN1, PPING, PPSING)] < [BAR 0, ~H] < 
   H[N +, SUBCAT NULL].
LPRULE LP1C : ; this ensures that conjunct words (~BAR) precede lexical
              ; conjuncts in idrules CONJ/A, CONJ/N, CONJ/P and CONJ/V
              ; (these conjuncts are not heads so lprule LP1b won't apply).
   [SUBCAT @, ~BAR] < [SUBCAT @, BAR].
LPRULE LP2 : ; as in GPSG85 - nominal categories precede PPs which precede
             ; VPs and Ss.
   [N +] < P2 < V2.
LPRULE LP3A : ; lprules LP3A - LP3C order adverbials with respect to other
              ; non-lexical categories. This one orders the X2[+ADV] after
              ; the VP in VP/MOD1.
   VP[H +] < [~N, ADV +].
LPRULE LP3B : ; this orders S/ADVBLa1, S/ADVBLa2, VP/BE_CLEFT3(*,*),
              ; VP/NP_ADVP(*,*) and S1b-S1e
   N2 < [BAR 2, ADV +] < S.
LPRULE LP3C : ; this orders A2/ADVMOD1, A2/ADVMOD2 and P2/ADVMOD.
   A2[+ADV] < [H +, BAR (1, 2)].
LPRULE LP4A : ; lprules LP4A - LP4F order +N BAR 2 categories with respect
              ; to one another. This one orders possessive NP before the
              ; nominal category it is a specifier of. It also orders the
              ; possessive morpheme (N1[POSS +]) after the N2 it attaches
              ; to.
   N2[+POSS] < [N +, V -, POSS -] < N1[POSS +].
LPRULE LP4B : ; non-predicative NPs precede predicative NPs or APs or XPs.
   N2[~H, PRD (-, @)] < X2[N +, PRD +] < X2[~N, PRD +].
LPRULE LP4C : ; this orders APs before nominal heads - except for [DISTR
              ; PRD] ones which come after (see idrule N1/POST_APMOD1).
   A2[DISTR (ATT, @)] < [N +, V -, H +, PRO (-, @)] < A2[DISTR PRD].
LPRULE LP4D : ; to order N1/POST_APMOD2 (a non-predicative AP follows a +PRO
              ; head ("someone stupid").
   N1[H +, PRO +] < A2.
LPRULE LP4E : ; to order the NPs in ditransitive phrasal VP rules -
              ; VP/NP_NP_PHRB and VP/NP_NP_PHRB(MSLASH1b).
   N2[PRO @, PART -] < N2[PRO -, PART -].
LPRULE LP4F : ; to order the NPs in ditransitive rules to ensure a correct
              ; distribution of gaps.
   N2[-PRD, SLASH @, CASE ACC] < N2[-PRD, SLASH NOSLASH, CASE ACC] < 
   N2[-PRD, SLASH X2, CASE ACC].
LPRULE LP4G : ; to order A2/COMPAR2
   A1 < A2[PFORM @a].
LPRULE LP5A : ; lprules LP5A-LP5C order PPs with respect to one another.
              ; this one ensures a correct distribution of gaps in
              ; complement PP sisters - the outputs of metarules (SLASH X2)
              ; have a different order from the inputs (SLASH @).
   P2[PFORM @, SLASH @] < P2[PFORM @, SLASH NOSLASH] < P2[PFORM @, SLASH X2].
LPRULE LP5B : ; this makes a gappy by-phrase follow another PP ("*who was
              ; the book given back by E to Kim").
   P2[PFORM @, SLASH NOSLASH] < P2[PFORM BY, SLASH X2].
LPRULE LP5C : ; this makes a by-phrase follow a gappy PP ("?who was the book
              ; given back by lee to E").
   P2[PFORM @, SLASH X2] < P2[PFORM BY, SLASH NOSLASH].
LPRULE LP6 : ; this orders V2s with respect to one another. Non-head V2s
             ; (i.e sentential and VP subjects) precede head VPs (idrule
             ; S/V2_SUBJ1 - S/V2_SUBJ5). The exception is tag questions
             ; where the non-head follows the head.
   V2[~H, ~TAG] < V2[H +] < V2[TAG, ~H].
LPRULE LP7A : ; lprules LP7A-LP7C order particles in phrasal verb rules.
              ; This one makes them precede all non-nominal BAR 2
              ; categories.
   [~BAR, PRT @] < X2[~NFORM].
LPRULE LP7B : ; this orders particles before -PRO and predicative NPs.
   [~BAR, PRT @] < N2[-PRD, -PRO] < N2[+PRD].
LPRULE LP7C : ; this orders non-predicative NPs before particles so long as
              ; they're not PRO -.
   N2[PRO @, PRD (-, @)] < [~BAR, PRT @].
LPRULE LP8A : ; lprules 8A and 8B order the word "not" ([NEG +]) with
              ; respect to its sisters. This one makes it precede everything
              ; that's not an NP and that's not specified for SUBCAT.
   [~BAR, NEG +] < [~CASE, ~SUBCAT].
LPRULE LP8B : ; this orders subject NP before "not" ("is Kim not singing" vs
              ; "*is not Kim singing) but all other NPs after it.
   N2[+NOM] < [~BAR, NEG +] < N2[CASE (ACC, @)].
LPRULE LP9 : ; this orders conjuncts with respect to one another (e.g.
             ; "either Kim or Sandy" vs "*or Sandy either kim".
   [CONJ (NULL, BOTH, EITHER, NEITHER)] < [CONJ (AND, OR, NOR, BUT)].
LPRULE LP10 : ; this orders the categories in the partitive rules N2+/PART1
              ; - N2+/PART6B.
   X2[N +, PART (OF, OF2, NO_OF)] < [~BAR, PFORM OF] < N2[PART -].
LPRULE LP11 : ; "so" precedes its S sister ("so he did").
   [SO +] < S.
\end{verbatim}
{\bf ; metarules}
\begin{verbatim}
METARULE PASSIVE : ; passive metarule. The [AGR N2[NFORM NORM]] restriction
                   ; prevents various VP rules with odd agreement properties
                   ; from matching. Passives for these are done directly
                   ; with idrules - see idrules VP/*/PASS*. The [PRO @]
                   ; restriction stops VP/NP_PHRB and VP/NP_PP_PHRB from
                   ; matching (only the PHRA variants need to match). The
                   ; SLASH @ blocks it from applying to VP/NP_NP_PHRA (it
                   ; matches VP/NP_NP_PHRB). The SUBCAT list stops it from
                   ; applying to various VP rules that don't passivise even
                   ; though they have an object NP, for example, the rule
                   ; VP/OE_BSE would otherwise match to give '*lee was heard
                   ; wash up'. The semantics part switches arguments and
                   ; defines two output semantics for the version with a
                   ; by-phrase (unslashed and slashed PP--the first two
                   ; conditions) and one output for the version without the
                   ; by-phrase (unslashed--the third condition) where an
                   ; interpretation for the missing agent is supplied.
   VP[AGR N2[NFORM NORM], SLASH @] --> 
   H[SUBCAT (NP, NP_NP, NP_PP, NP_PP_PP, NP_LOC, NP_ADVP, NP_SFIN, 
            NP_NP_SFIN, NP_SBSE, NP_WHS, NP_WHVP, OC_NP, OC_AP, OC_INF, 
            OC_ING, OC_PP_ING), SUBTYPE (NONE, DMOVT, EQUI), 
      AGR N2[NFORM NORM], PSVE -], N2[-PRD, PRO @, SLASH @], W. 
   ==> VP[EN, +PRD] --> H[PSVE +, EN, +PRD], ( P2[PFORM BY, PRD -] ), W : 
   2 = [SLASH NOSLASH], 6 = [SLASH NOSLASH], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q 
                           (lambda (e) (lambda (y) ((lambda (dsubj) 
                                       ((lambda (2) (prop e dsubj)) y)) 
                                    (2 (lambda (by) (lambda (np) np)))))) ta 
                           equa))))))) : 
   2 = [SLASH NOSLASH], 6 = [SLASH X2], (lambda (s) 
         (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (y) (lambda (wh) 
                                    ((lambda (dsubj) ((lambda (2) 
                                                (prop e dsubj)) y)) 
                                       (2 (lambda (by) (lambda (np) np)) 
                                          wh))))) ta equa))))))) : 
   2 = [SLASH NOSLASH], 
      (lambda (s) (s (lambda (prop) (lambda (ta) (lambda (equa) 
                     (lambda (Q) (Q 
                           (lambda (e) (lambda (y) ((lambda (2) (prop e 
                                          (uq (some (x1) (entity x1))))) y))) 
                           ta equa))))))).
METARULE PASSIVE2 : ; does PASSIVE for various object raising rules such as
                    ; VP/OR_INF in order to produces AGR @ passives. The
                    ; subject can be NFORM IT or THERE (there are believed
                    ; to be aliens on Mars) or it can be VP or S (that kim
                    ; is crazy is considered to be obvious).
   VP --> H[SUBCAT (OC_INF, OC_AP), SUBTYPE RAIS], N2[-PRD], X2, W. 
   ==> VP[PAS, AGR @a, SLASH @s] --> H[PAS, PSVE +, AGR @a], 
      X2[SLASH NOSLASH, AGR @a], ( P2[PFORM BY, PRD -, SLASH @s] ), W : 
   2 = [SLASH NOSLASH], 8 = [SLASH NOSLASH], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q 
                           (lambda (e) (lambda (y) ((lambda (dsubj) 
                                       ((lambda (2) (prop e dsubj)) y)) 
                                    (3 (lambda (by) (lambda (np) np)))))) ta 
                           equa))))))) : 
   2 = [SLASH NOSLASH], 8 = [SLASH X2], (lambda (s) 
         (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (y) (lambda (wh) 
                                    ((lambda (dsubj) ((lambda (2) 
                                                (prop e dsubj)) y)) 
                                       (3 (lambda (by) (lambda (np) np)) 
                                          wh))))) ta equa))))))) : 
   2 = [SLASH NOSLASH], 
      (lambda (s) (s (lambda (prop) (lambda (ta) (lambda (equa) 
                     (lambda (Q) (Q 
                           (lambda (e) (lambda (y) ((lambda (2) (prop e 
                                          (uq (some (x1) (entity x1))))) y))) 
                           ta equa))))))).
METARULE SAI : ; Subject Auxiliary Inversion metarule. Applies to all
               ; non-[ELLIP +] auxiliary rules except for VP/TO. The listing
               ; of possible input SUBCAT values excludes VP/TO. SLASH
               ; propagation is done here too.
   VP[+AUX, VFORM (@, NOT), ELLIP (-, @), COORD (-, @)] --> 
   H[SUBCAT (DO, MODAL_BSE, MODAL_INF, FUT, HAVE, BE)], 
   X2[~COMP, BEGAP (@, -)], W. 
   ==> S[+INV, +FIN, COMP NORM, SLASH @s] --> H[+INV], X2[SLASH @s], 
      N2[+NOM, -PRD, SLASH NOSLASH], W : 
   1 = [~PAST, NEG -], 5 = [PAST -, NEG -], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) 
                           (lambda (e2) (PRES (ta e2))) equa))))))) : 
   1 = [~PAST, NEG +], 5 = [PAST -, NEG +], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) 
                           (lambda (e2) (PRES (ta e2))) equa))))))) : 
   1 = [~PAST, NEG -], 5 = [PAST +, NEG -], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) 
                           (lambda (e2) (PAST (ta e2))) equa))))))) : 
   1 = [~PAST, NEG +], 5 = [PAST +, NEG +], 
      (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) 
                           (lambda (e2) (PAST (ta e2))) equa))))))) : 
   1 = [PAST FUT, NEG -], 5 = [PAST FUT, NEG -], 
      (lambda (s) (s (lambda (prop) 
               (lambda (ta) (lambda (equa) (lambda (Q) (Q 
                           (lambda (e) (prop e 3)) 
                           (lambda (e2) (FUT (ta e2))) equa))))))) : 
   1 = [PAST FUT, NEG +], 5 = [PAST FUT, NEG +], 
      (lambda (s) (s (lambda (prop) 
               (lambda (ta) (lambda (equa) (lambda (Q) (Q 
                           (lambda (e) (prop e 3)) 
                           (lambda (e2) (FUT (ta e2))) equa))))))).
METARULE ELL/SAI : ; [ELLIP +] version of SAI.
   VP[+AUX, VFORM (@, NOT)] --> 
   H[SUBCAT (DO, MODAL_BSE, MODAL_INF, FUT, HAVE, BE)], 
   X2[~COMP, BEGAP (@, -), ELLIP +], W. 
   ==> S[+INV, +FIN, COMP NORM, SLASH @s] --> H[+INV], X2[SLASH @s], 
      N2[+NOM, -PRD, SLASH NOSLASH], W : 
   1 = [NEG -, PAST -], 5 = [NEG -, PAST -], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) ta 
                           equa))))))) : 
   1 = [NEG -, PAST -], 5 = [NEG +, PAST -], 6 = [SLASH NOSLASH], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (NOT (prop e 3))) 
                           ta equa))))))) : 
   1 = [NEG -, PAST -], 5 = [NEG +, PAST -], 6 = [SLASH NOSLASH], 
      (lambda (s) 
            (((lambda (mod) (s mod some)) (lambda (prop1) (lambda (e1) 
                        (lambda (x1) (NOT (prop1 e1 x1)))))) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) ta 
                           equa))))))) : 
   1 = [NEG -, PAST -], 5 = [NEG +, PAST -], 6 = [SLASH X2], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (NOT (prop e 3 wh)))) ta 
                           equa))))))) : 
   1 = [NEG -, PAST -], 5 = [NEG +, PAST -], 6 = [SLASH X2], 
      (lambda (s) (((lambda (mod) (s mod some)) 
               (lambda (prop1) (lambda (e1) (lambda (x1) 
                        (lambda (wh1) (NOT (prop1 e1 x1 wh1))))))) 
            (lambda (prop) 
               (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (prop e 3 wh))) ta equa))))))) : 
   1 = [NEG -, PAST +], 5 = [NEG -, PAST +], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) ta 
                           equa))))))) : 
   1 = [NEG -, PAST +], 5 = [NEG +, PAST +], 6 = [SLASH NOSLASH], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (NOT (prop e 3))) 
                           ta equa))))))) : 
   1 = [NEG -, PAST +], 5 = [NEG +, PAST +], 6 = [SLASH NOSLASH], 
      (lambda (s) 
            (((lambda (mod) (s mod some)) (lambda (prop1) (lambda (e1) 
                        (lambda (x1) (NOT (prop1 e1 x1)))))) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) ta 
                           equa))))))) : 
   1 = [NEG -, PAST +], 5 = [NEG +, PAST +], 6 = [SLASH X2], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (NOT (prop e 3 wh)))) ta 
                           equa))))))) : 
   1 = [NEG -, PAST +], 5 = [NEG +, PAST +], 6 = [SLASH X2], 
      (lambda (s) (((lambda (mod) (s mod some)) 
               (lambda (prop1) (lambda (e1) (lambda (x1) 
                        (lambda (wh1) (NOT (prop1 e1 x1 wh1))))))) 
            (lambda (prop) 
               (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (prop e 3 wh))) ta equa))))))) : 
   1 = [NEG -, ~PAST], 5 = [NEG -], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 3)) ta 
                           equa))))))) : 
   1 = [NEG -, ~PAST], 5 = [NEG +], 6 = [SLASH NOSLASH], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) (NOT (prop e 3))) 
                           ta equa))))))) : 
   1 = [NEG -, ~PAST], 5 = [NEG +], 6 = [SLASH NOSLASH], 
      (lambda (s) (((lambda (mod) (s mod some)) 
               (lambda (prop1) (lambda (e1) (lambda (x1) 
                        (NOT (prop1 e1 x1)))))) 
            (lambda (prop) (lambda (ta) (lambda (equa) 
                     (lambda (Q) (Q (lambda (e) (prop e 3)) ta equa))))))) : 
   1 = [NEG -, ~PAST], 5 = [NEG +], 6 = [SLASH X2], 
      (lambda (s) ((s (lambda (prop1) prop1) some) 
            (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (NOT (prop e 3 wh)))) ta 
                           equa))))))) : 
   1 = [NEG -, ~PAST], 5 = [NEG +], 6 = [SLASH X2], 
      (lambda (s) (((lambda (mod) (s mod some)) 
               (lambda (prop1) (lambda (e1) (lambda (x1) 
                        (lambda (wh1) (NOT (prop1 e1 x1 wh1))))))) 
            (lambda (prop) 
               (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                              (lambda (wh) (prop e 3 wh))) ta equa))))))).
METARULE NEGATION : ; takes an aux or modal rule and returns a new version
                    ; with a "not" between head and complement. The
                    ; semantics of the new rules are equivalent to the [NEG
                    ; +] semantics on the input rules.
   V2[+AUX, FIN (@, +), PRO -, ~TAG] --> H[NEG @a, CONEG @b], W. 
   ==> V2[+AUX, +FIN] --> H[+FIN, NEG -, CONEG @c], [NEG +], W : 
   1 = [NEG +, ~PAST], (lambda (s) s) : 
   1 = [NEG +, PAST -], 4 = [PAST -], (lambda (s) s) : 
   1 = [NEG +, PAST +], 4 = [PAST +], (lambda (s) s) : 
   1 = [NEG +, PAST FUT], 4 = [PAST FUT], (lambda (s) s).
METARULE MSLASH1a : ; takes an input where mother and N2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the N2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-1.
   [SLASH @] --> [H +, BAR 0], N2[-PRD, SLASH @], X2[SLASH NOSLASH, ~UB], W. 
   
   ==> [SLASH X2] --> [H +, BAR 0], N2[-PRD, SLASH NOSLASH], X2[SLASH X2, 
         BEGAP @b], W : 2 = [SLASH NOSLASH], slash-operator-1.
METARULE MSLASH1b : ; takes an input where mother and N2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the N2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-2.
   [SLASH @, ~INV] --> [H +, BAR 0], N2[-PRD, SLASH @], 
   X2[SLASH NOSLASH, UB NO], W. 
   ==> [SLASH X2] --> [H +, BAR 0], N2[-PRD, SLASH NOSLASH], 
      X2[SLASH X2, BEGAP @b], W : 2 = [SLASH NOSLASH], slash-operator-2.
METARULE MSLASH2a : ; takes an input where mother and A2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the A2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-1.
   [SLASH @] --> [H +, BAR 0], A2[SLASH @], X2[SLASH NOSLASH, ~UB], W. 
   ==> [SLASH X2] --> [H +, BAR 0], A2[SLASH NOSLASH], 
      X2[SLASH X2, BEGAP @b], W : 2 = [SLASH NOSLASH], slash-operator-1.
METARULE MSLASH2b : ; takes an input where mother and A2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the A2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-2.
   [SLASH @, ~COMP] --> [H +, BAR 0], A2[SLASH @], X2[SLASH NOSLASH, UB NO], 
   W. 
   ==> [SLASH X2] --> [H +, BAR 0], A2[SLASH NOSLASH], X2[SLASH X2, BEGAP 
            @b], W : 2 = [SLASH NOSLASH], slash-operator-2.
METARULE MSLASH3a : ; takes an input where mother and P2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the P2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-1.
   [SLASH @] --> [H +, BAR 0], P2[SLASH @], X2[SLASH NOSLASH, ~UB], W. 
   ==> [SLASH X2] --> [H +, BAR 0], P2[SLASH NOSLASH], 
      X2[SLASH X2, BEGAP @b], W : 2 = [SLASH NOSLASH], slash-operator-1.
METARULE MSLASH3b : ; takes an input where mother and P2 share values for
                    ; SLASH and produces an output where mother and some
                    ; other [BAR 2] daughter are [SLASH X2] and the P2 is
                    ; [SLASH NOSLASH]. See file cmeta-ops for definition of
                    ; slash-operator-2.
   [SLASH @, ~COMP] --> [H +, BAR 0], P2[SLASH @], X2[SLASH NOSLASH, UB NO], 
   W. 
   ==> [SLASH X2] --> [H +, BAR 0], P2[SLASH NOSLASH], X2[SLASH X2, BEGAP 
            @b], W : 2 = [SLASH NOSLASH], slash-operator-2.
METARULE MSLASH4a : ; takes a passive VP input which is [SLASH NOSLASH] and
                    ; has one complement (i.e. some of idrules *(PASSIVE/-))
                    ; and returns one where mother and complement are [SLASH
                    ; X2]. See file cmeta-ops for definition of
                    ; slash-operator-3.
   [PAS, SLASH NOSLASH, AGR N2[NFORM NORM]] --> 
   [H +, BAR 0, SUBCAT (NP_NP, NP_PP, NP_LOC, NP_ADVP, NP_SFIN, NP_SBSE, 
            OC_NP, OC_AP, OC_INF, OC_ING)], X2[SLASH NOSLASH]. 
   ==> [PAS, SLASH X2] --> [H +, BAR 0, PAS], X2[SLASH X2, BEGAP @b] : 
   slash-operator-3.
METARULE MSLASH4b : ; like MSLASH4a except with a particle.
   [PAS, SLASH NOSLASH, AGR N2[NFORM NORM]] --> 
   [H +, BAR 0, SUBCAT (NP_NP, NP_PP, NP_SFIN, OC_AP, OC_INF)], 
   X2[SLASH NOSLASH], X[PRT @p]. 
   ==> [PAS, SLASH X2] --> [H +, BAR 0, PAS, PRT @p], X2[SLASH X2, BEGAP @b], 
      X : slash-operator-3.
METARULE MSLASH4c : ; like MSLASH4a except there are two nonhead daughters.
   [PAS, SLASH NOSLASH, AGR N2[NFORM NORM]] --> 
   [H +, BAR 0, SUBCAT (NP_NP_SFIN, NP_PP_PP, OC_AP)], X2[SLASH NOSLASH], 
   X[BAR (0, 2)]. 
   ==> [PAS, SLASH X2, AGR N2[NFORM NORM]] --> [H +, BAR 0, PAS, 
         AGR N2[NFORM NORM]], X2[SLASH X2, BEGAP @b], X : slash-operator-3.
METARULE MSLASH4d : ; like MSLASH4a except for raising VPs
   [PAS, SLASH NOSLASH] --> 
   [H +, BAR 0, SUBCAT (OC_NP, OC_AP, OC_INF), SUBTYPE RAIS], 
   X2[SLASH NOSLASH], W. 
   ==> [PAS, SLASH X2] --> [H +], X2[SLASH X2, BEGAP @b], W : 
   slash-operator-3.
METARULE STM2a : ; for embedded subject extractions (who does kim believe
                 ; left) - terminates SLASH without a gap by substituting a
                 ; finite VP complement for a finite S[SLASH N2] complement.
   [SLASH @, AGR N2] --> [H +, BAR 0], S[+FIN, SLASH @, COMP (@, THAT)], W. 
   ==> [SLASH N2[-PRD]] --> [H +, BAR 0], VP[+FIN, SLASH NOSLASH], W : 
   2 = [SLASH X2], (lambda (s) ((lambda (2) s) 2)).
METARULE STM2b : ; same as STM2a except inputs are outputs of previous
                 ; MSLASH metarules and are [SLASH X2] rather than [SLASH
                 ; @].
   [SLASH X2, AGR N2] --> [H +, BAR 0], S[+FIN, SLASH X2], W. 
   ==> [SLASH N2[-PRD]] --> [H +, BAR 0], VP[+FIN, SLASH NOSLASH], W : 
   (lambda (s) ((lambda (2) s) 2)).
METARULE STM3a : ; terminates the [SLASH S] introduced by N2+/COMPAR4 and
                 ; A2/COMPAR4a. Doesn't leave a gap - it just removes the
                 ; sentential complement.
   [SLASH @, AGR N2[NFORM NORM]] --> [H +, BAR 0], 
   S[+FIN, SLASH @, COMP (@, THAT)], W. ==> [SLASH S] --> [H +, BAR 0], W : 
   2 = [SLASH X2], 
      (lambda (s) (s (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                        (Q 
                           ((lambda (2) prop) (lambda (f) (f (lambda (lose1) 
                                          (lambda (lose2) wh)) NIL NIL))) ta 
                           equa))))))).
METARULE STM3b : ; same as STM3b except inputs are outputs of previous
                 ; MSLASH metarules and are [SLASH X2] rather than [SLASH
                 ; @].
   [SLASH X2, AGR N2[NFORM NORM]] --> [H +, BAR 0], S[+FIN, SLASH X2], W. 
   ==> [SLASH S] --> [H +, BAR 0], W : 
   (lambda (s) (s (lambda (prop) (lambda (ta) 
                  (lambda (equa) (lambda (Q) (Q ((lambda (2) prop) 
                              (lambda (f) 
                                 (f (lambda (lose1) (lambda (lose2) wh)) NIL 
                                    NIL))) ta equa))))))).
METARULE MSLASH5a : ; default rule DPOST/PASS4 makes all categories [SLASH
                    ; NOSLASH] in outputs of PASSIVE which have more than
                    ; one PP. This produces variants where the mother and
                    ; the PP which isn't the by-phrase are [SLASH X2].
   [PAS, SLASH NOSLASH, AGR N2[NFORM NORM]] --> 
   [H +, BAR 0, SUBCAT (NP_PP, NP_PP_PP), PFORM @p], P2[PFORM @p], 
   X2[PFORM BY], W. 
   ==> [PAS, SLASH X2, AGR N2[NFORM NORM]] --> [H +, BAR 0, PAS, 
         AGR N2[NFORM NORM], PFORM @p], P2[SLASH X2, BEGAP @b, PFORM @p], 
      X2[PFORM BY], W : 3 = [SLASH NOSLASH], slash-operator-3.
METARULE MSLASH5b : ; default rule DPOST/PASS4 makes all categories [SLASH
                    ; NOSLASH] in outputs of PASSIVE which have more than
                    ; one PP. This produces variants where the mother and
                    ; the PP which is the by-phrase are [SLASH X2].
   [PAS, SLASH NOSLASH, AGR N2[NFORM NORM]] --> 
   [H +, BAR 0, SUBCAT (NP_PP, NP_PP_PP)], P2[PFORM BY], W. 
   ==> [PAS, SLASH X2, AGR N2[NFORM NORM]] --> 
      [H +, BAR 0, PAS, AGR N2[NFORM NORM]], 
      P2[SLASH X2, BEGAP @b, PFORM BY], W : 
   2 = [SLASH NOSLASH], slash-operator-3.
\end{verbatim}
{\bf ; ID rules}

{\bf ; root sentence rules}
\begin{verbatim}
IDRULE T1 : ; root symbol for the parser. It is here that the information
            ; that root sentences are always finite is encoded. This means
            ; that the parser gives two parses for finite sentences (one as
            ; T, one as S) whilst only one parse for non-finite sentences
            ; (as S)
   [T S] --> S[H +, COMP NORM, +FIN] : 
   1 = [VFORM NOT, INV -], (DECL (1 (lambda (prop) 
               (lambda (ta) (lambda (equa) 
                     (prop (uqe ((equa some) (e) (ta e))))))))) : 
   1 = [VFORM NOT, INV +], 
      (YNQU (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                     (prop (uqe ((equa some) (e) (ta e))))))))) : 
   1 = [VFORM BSE], 
      (IMP (1 (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe 
                           ((equa some) (e) (ta e))))))))).
IDRULE T2 : ; all wh-questions to be recognised as root sentences
   [T S] --> S[H +, COMP NORM, +FIN, UB Q, WH +, EVER @ev, UDC @u, INV @u] : 
   (WHQU 
         (1 (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe ((equa some) 
                              (e) (ta e))))))))).
IDRULE T3 : ; tag questions
   [T S] --> S[TAG VAL1, INV -, SLASH NOSLASH] : 
   (YNQU (1 (lambda (prop) (lambda (ta) 
                  (lambda (equa) (prop (uqe ((equa some) (e) (ta e))))))))).
\end{verbatim}
{\bf ; trace rules}
\begin{verbatim}
IDRULE TRACE1 : ; an NP gap
   
   N2[+SPEC, -ADV, SLASH N2[NFORM NORM, -ADV, PLU @pl, COUNT @co, PER @pe, 
            CASE @ca, PRD @pr], NFORM NORM, PLU @pl, COUNT @co, PER @pe, 
      CASE @ca, PRD @pr, BEGAP +] --> [NULL +] : 
   0 = [PRD -], (lambda (wh) wh) : 
   0 = [PRD +], (lambda (x) (lambda (wh) (wh x))).
IDRULE TRACE2 : ; a PP gap
   
   P2[SLASH P2[PFORM @pf, LOC @lo, GERUND @ge, PRD @pr], PFORM @pf, LOC @lo, 
      GERUND @ge, PRD @pr, BEGAP +] --> [NULL +] : 
   (lambda (x) (lambda (wh) (wh x))).
IDRULE TRACE3 : ; an AP gap
   A2[SLASH A2[ADV @ad], ADV @ad, BEGAP +] --> [NULL +] : 
   (lambda (x) (lambda (wh) (wh x))).
IDRULE TRACE4 : ; X2[+ADV]/P2 - a gap in VP/BE_CLEFT3.
   X2[+ADV, SLASH P2[PRD +, PFORM NORM], WH @a, UB @b, EVER @c, BEGAP +] --> 
   [NULL +] : (lambda (a) (lambda (wh) (wh a))).
IDRULE TRACE5 : ; XP[+ADV]/A2[+ADV] - a gap in VP/BE_CLEFT3.
   X2[+ADV, SLASH A2[+ADV, QUA @q], QUA @q, BEGAP +] --> [NULL +] : 
   (lambda (wh) wh).
IDRULE TRACE6 : ; X2[+PRD]/N2
   
   X2[+PRD, SLASH N2[NFORM NORM, -ADV, PRD +, +ACC], AGR N2[NFORM NORM], 
      BEGAP +] --> [NULL +] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (BE e (wh x))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE TRACE7 : ; X2[+PRD]/P2.
   X2[+PRD, SLASH P2[PFORM NORM, PRD +], BEGAP +] --> [NULL +] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (BE e (wh x))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE TRACE8 : ; X2[+PRD]/A2.
   X2[+PRD, SLASH A2[+PRD, -ADV], BEGAP +] --> [NULL +] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (BE e (wh x))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
\end{verbatim}
{\bf ; S rules}
\begin{verbatim}
IDRULE S1a : ; split up ordinary S rules to allow for non-nominative
             ; subjects. This one = finite S.
   S[COMP NORM, -INV, +FIN, ELLIP -, COORD -, UDC -] --> N2[+NOM, -PRD], 
   H2[-SUBJ, AGR N2, ELLIP -, COORD -] : 
   2 = [SLASH NOSLASH, PAST (-, @)], 1 = [UB (Q, NO, @)], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [SLASH NOSLASH, PAST (-, @)], 1 = [UB R], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [SLASH X2, PAST (-, @)], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [SLASH NOSLASH, PAST +], 1 = [UB (Q, NO, @)], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [SLASH NOSLASH, PAST +], 1 = [UB R], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [SLASH X2, PAST +], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [SLASH NOSLASH, PAST FUT], 1 = [UB (Q, NO, @)], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [SLASH NOSLASH, PAST FUT], 1 = [UB R], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [SLASH X2, PAST FUT], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S1b : ; Same as S1a except [-QUA] adverb interposed between subject
             ; and VP.
   S[COMP NORM, -INV, +FIN] --> N2[+NOM, -PRD], A2[+ADV, -QUA], 
   H2[-SUBJ, AGR N2, COORD -, ELLIP -] : 
   3 = [SLASH NOSLASH, PAST -], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (and (prop e 1) (2 e))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   3 = [SLASH NOSLASH, PAST -], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e (1 x)) (2 e)))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   3 = [SLASH X2, PAST -], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (and (prop e 1 wh) (2 e)))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   3 = [SLASH NOSLASH, PAST +], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (and (prop e 1) (2 e))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   3 = [SLASH NOSLASH, PAST +], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e (1 x)) (2 e)))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   3 = [SLASH X2, PAST +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (and (prop e 1 wh) (2 e)))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   3 = [SLASH NOSLASH, PAST FUT], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (and (prop e 1) (2 e))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   3 = [SLASH NOSLASH, PAST FUT], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e (1 x)) (2 e)))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   3 = [SLASH X2, PAST FUT], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (and (prop e 1 wh) (2 e)))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S1c : ; Same as S1a except [+QUA] adverb interposed between subject
             ; and VP.
   S[COMP NORM, -INV, +FIN] --> N2[+NOM, -PRD], A2[+ADV, +QUA], 
   H2[-SUBJ, AGR N2, ELLIP -, COORD -] : 
   3 = [SLASH NOSLASH, PAST -], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (PRES (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH NOSLASH, PAST -], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (PRES (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH X2, PAST -], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (PRES (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH NOSLASH, PAST +], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (PAST (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH NOSLASH, PAST +], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (PAST (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH X2, PAST +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (PAST (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH NOSLASH, PAST FUT], 1 = [UB (Q, NO, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (FUT (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH NOSLASH, PAST FUT], 1 = [UB R], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) 
                        (lambda (e2) (FUT (ta e2))) 
                        (lambda (qu) (equa 2)))))))) : 
   3 = [SLASH X2, PAST FUT], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (FUT (ta e2))) 
                        (lambda (qu) (equa 2)))))))).
IDRULE S2 : ; base S
   S[COMP NORM, -INV, -FIN, BSE] --> N2[+NOM], H2[-SUBJ, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))) : 
   2 = [SLASH X2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q 
                        (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))).
IDRULE S3 : ; infinitival S. Accusative subject - 'for him to go'
   S[COMP NORM, -INV, -FIN, TO] --> N2[+ACC], H2[-SUBJ, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))) : 
   2 = [SLASH X2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q 
                        (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))).
IDRULE S4 : ; gerund S. Accusative subject - 'him going'
   S[COMP NORM, -INV, -FIN, ING, PRD -] --> N2[+ACC], H2[-SUBJ, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))) : 
   2 = [SLASH X2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q 
                        (lambda (e) (lambda (wh) (prop e 1 wh))) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))).
IDRULE S/V2_SUBJ1 : ; for finite sentential subjects eg 'that fido dances
                    ; bothers lee'
   S[COMP NORM, -INV] --> S[+FIN, that], H2[-SUBJ, AGR S, ELLIP @e] : 
   2 = [PAST -, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [PAST -, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/V2_SUBJ2 : ; for infinitival sentential subject eg 'for us to go
                    ; would be possible
   S[COMP NORM, -INV] --> S[COMP FOR, -FIN, TO], H2[-SUBJ, AGR S, ELLIP @e] : 
   2 = [PAST -, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [PAST -, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/V2_SUBJ3 : ; for infinitival VP subject eg 'to go would be
                    ; possible'
   S[COMP NORM, -INV] --> VP[-FIN, TO, AGR N2[NFORM NORM], ELLIP @e], 
   H2[-SUBJ, AGR VP] : 
   2 = [PAST -, ELLIP -], (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) (lambda (e2) (PRES (ta e2))) 
                        equa)))))) : 
   2 = [PAST +, ELLIP -], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) (lambda (e2) (PAST (ta e2))) 
                        equa)))))) : 
   2 = [PAST FUT, ELLIP -], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) (lambda (e2) (FUT (ta e2))) 
                        equa)))))) : 
   2 = [PAST -, ELLIP (+, @)], (2 (lambda (pp) pp) some 
         (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) (lambda (e2) (PAST (ta e2))) 
                        equa)))))) : 
   2 = [PAST FUT, ELLIP (+, @)], (2 (lambda (pp) pp) some 
         (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/V2_SUBJ4 : ; for BSE sentential subject eg 'that you answer is
                    ; necessary'
   S[COMP NORM, -INV] --> S[COMP THAT, -FIN, BSE], 
   H2[-SUBJ, AGR S, ELLIP @e] : 
   2 = [PAST -, ELLIP -], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [PAST -, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/V2_SUBJ5 : ; for S[+Q] subjects eg 'whether we should go is not
                    ; clear' and 'what we should do is not clear'
   S[COMP NORM, -INV] --> S[+Q], H2[-SUBJ, AGR S[+Q], ELLIP @e] : 
   2 = [PAST -, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (prop e (1 (lambda (prop2) (lambda (ta2) (lambda 
                                          (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))) : 
   2 = [PAST -, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   2 = [PAST +, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (PAST (ta e2))) equa)))))) : 
   2 = [PAST FUT, ELLIP (+, @)], 
      (2 (lambda (pp) pp) some (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e (1 (lambda (prop2) 
                                    (lambda (ta2) (lambda (equa2) 
                                          (prop2 (uqe ((equa2 some) (e3) 
                                                   (ta2 e3)))))))))) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/THAT1 : ; introduces 'that' complementiser. +FIN version
   S[that] --> [SUBCAT THAT], S[H +, COMP NORM, -INV, +FIN] : 2.
IDRULE S/THAT2 : ; introduces 'that' complementiser. BSE version
   S[that] --> [SUBCAT THAT], S[H +, COMP NORM, -INV, BSE] : 2.
IDRULE S/FOR : ; introduces 'for' complementiser. Restricts the S to [VFORM
               ; TO]
   S[COMP FOR, TO] --> [SUBCAT FOR], S[H +, COMP NORM, -INV] : 2.
IDRULE S/Q1 : ; for embedded whether-clauses. The S is +Q and [WH NO, EVER
              ; NO]. This differentiates it from embedded wh questions and
              ; from root ([T +]) wh questions.
   S[+Q, WH NO, EVER NO, +FIN, COMP WHETHER] --> [SUBCAT WHETHER], 
   S[H +, COMP NORM, -INV] : 2.
IDRULE S/Q2 : ; same as S/Q1 but for embedded if-clauses
   S[+Q, WH NO, EVER NO, +FIN, COMP IF] --> [SUBCAT IF], 
   S[H +, COMP NORM, -INV] : 2.
IDRULE S/THAN : ; introduces 'than' sentences. Semantics must be left open
                ; when SLASH is instantiated to VP ([SUBJ -]) or to NOSLASH,
                ; since an event quantifier might be involved.
   S[COMP ER] --> [SUBCAT THAN], S[H +, COMP NORM, +FIN] : 
   2 = [SLASH [SUBJ (+, @)]], 
      (lambda (c) (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                     (prop (uqe ((equa some) (e3) (ta e3))) c)))))) : 
   2 = [SLASH [SUBJ -]], 2 : 2 = [SLASH NOSLASH], 2.
IDRULE S/AS : ; introduces 'as' sentences. Semantics must be left open when
              ; SLASH SLASH is instantiated to VP ([SUBJ -]) or to NOSLASH,
              ; since an event quantifier might be involved.
   S[COMP AS] --> [SUBCAT AS], S[H +, COMP NORM, +FIN] : 
   2 = [SLASH [SUBJ (+, @)]], 
      (lambda (c) (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                     (prop (uqe ((equa some) (e3) (ta e3))) c)))))) : 
   2 = [SLASH [SUBJ -]], 2 : 2 = [SLASH NOSLASH], 2.
IDRULE S/NP_UDC1 : ; preposed NP. The features on the [SLASH N2] get bound
                   ; to the N2 by proprule SLASH/AGR_NP1
   S[-INV, UDC +] --> N2[NFORM NORM, PROTYPE NONE], 
   S[H +, COMP NORM, SLASH N2, +FIN] : 
   1 = [UB (Q, NO, @)], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) ta equa)))))) : 
   1 = [UB R], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda 
                           (e) (lambda (x) (prop e (1 x)))) ta equa)))))).
IDRULE S/NP_UDC2 : ; +INV version - can only be +Q, not +R or WH NO.
   S[+INV, +Q, UDC +] --> N2[NFORM NORM, +Q], 
   S[H +, COMP NORM, SLASH N2, +FIN] : 
   (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e 1)) ta equa)))))).
IDRULE S/PP_UDC1 : ; preposed PP. Features get bound by SLASH/AGR_PP1. +INV
                   ; version is S/PP_UDC2
   S[-INV, UDC +] --> P2, S[H +, COMP NORM, SLASH P2, +FIN] : 
   1 = [UB (Q, NO, @)], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (prop e 1)) ta equa)))))) : 
   1 = [UB R], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda 
                           (e) (lambda (x) (prop e (1 x)))) ta equa)))))).
IDRULE S/PP_UDC2 : ; +INV version - can only be +Q, not +R or WH NO.
   S[+INV, +Q, UDC +] --> P2[+Q], S[H +, COMP NORM, SLASH P2, +FIN] : 
   (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 
                              1)) ta equa)))))).
IDRULE S/AP_UDC1 : ; preposed AP. Features get bound by SLASH/AGR_AP
   S[-INV, UDC +] --> A2[PRD +, AGR N2[NFORM NORM]], 
   S[H +, COMP NORM, SLASH A2, +FIN] : 
   1 = [ADV -], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) ta 
                        equa)))))) : 
   1 = [ADV +, AFORM (ER, EST, AS)], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e (1 degree))) ta 
                        equa)))))) : 
   1 = [ADV +, AFORM NONE, DISTR PRD], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e (1 degree))) ta 
                        equa)))))) : 
   1 = [ADV +, AFORM NONE, DISTR (ATT, @)], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e 1)) ta equa)))))).
IDRULE S/AP_UDC2 : ; +INV version - can only be +Q, not +R or WH NO.
   S[+INV, +Q, UDC +] --> A2[PRD +, +Q, AGR N2[NFORM NORM]], 
   S[H +, COMP NORM, SLASH A2, +FIN] : 
   1 = [ADV -], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 1)) ta 
                        equa)))))) : 
   1 = [ADV +], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e (1 degree))) 
                        ta equa)))))).
IDRULE S/IMPER : ; imperative S. Imperatives are distinguished by being both
                 ; VFORM BSE and +FIN. All other +FIN forms are VFORM NOT.
   S[SLASH NOSLASH, COMP NORM] --> 
   H2[-SUBJ, BSE, FIN +, AGR N2[NFORM NORM], SLASH NOSLASH] : 
   (1 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 
                              (pro (the (y) (hearer y))))) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))).
IDRULE S/ADVBLa1 : ; allows for sentence initial adverbials. The ADVP can be
                   ; expanded as an AP[+ADV] or as a PP or by the MOD/COORD*
                   ; rules. -INV version.
   S[WH @a, UB @b, EVER @c, UDC +] --> ADVP[WH @a, UB @b, EVER @c], 
   S[H +, INV -, ELLIP -, COORD -] : 
   0 = [UB (NO, Q, @), SLASH NOSLASH], 1 = [QUA -], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (and (prop e) (1 e))) ta equa)))))) : 
   0 = [UB (NO, @), SLASH X2], 1 = [QUA -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (wh) (and (prop e wh) (1 e)))) ta 
                        equa)))))) : 
   0 = [UB R, SLASH NOSLASH], 1 = [QUA -], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e) (1 e x)))) ta 
                        equa)))))) : 
   0 = [UB (NO, Q, @), SLASH NOSLASH], 1 = [QUA +], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e)) ta 
                        (lambda (qu) (equa 1)))))))) : 
   0 = [UB (NO, @), SLASH X2], 1 = [QUA +], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (wh) (prop e wh))) ta 
                        (lambda (qu) (equa 1)))))))).
IDRULE S/ADVBLa2 : ; +INV version - can only be [UB Q].
   S[WH +, UB Q, EVER @c, UDC +] --> ADVP[WH +, UB Q, EVER @c], 
   S[H +, INV +, SLASH NOSLASH, ELLIP -, COORD -] : 
   1 = [QUA -], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (and (prop e) (1 e))) ta equa)))))) : 
   1 = [QUA +], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda 
                           (e) (prop e)) ta (lambda (qu) (equa 1)))))))).
IDRULE S/THATLESSREL : ; (the cat) fido attacked e. This S[+R] matches the
                       ; S[+R] in N1/REL.
   S[+R, -WH, -EVER, -INV, SLASH NOSLASH] --> 
   S[H +, COMP NORM, FIN +, SLASH N2[PRD -]] : 1.
IDRULE S/TAG : ; tags "doesn't he" "is he" etc
   
   S[TAG VAL2, INV +, AUX +, FIN +, VFORM NOT, AGR N2[NFORM NORM], SLASH 
         NOSLASH] --> H[SUBCAT @s, SUBTYPE NONE, AUX +], 
   N2[+NOM, SLASH NOSLASH].
IDRULE S/TAGQUESTION : ; tag questions - "he's a fool, isn't he?"
   S[TAG VAL1, -INV, +FIN, COMP NORM] --> S[H +, AGR @a], 
   S[TAG VAL2, AGR @a] : 1.
IDRULE S/PRO1 : ; to deal with apparently inverted +PRO sentences with "so"
                ; and "neither" -- "so did kim", "neither has lee".
   S[COMP NORM, -INV, +FIN] --> H[+AUX, SUBCAT NULL, +INV, +PRO], 
   N2[+NOM, -PRD] : 
   1 = [PAST -], (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e 2)) 
                        (lambda (e2) (PRES (ta e2))) equa)))))) : 
   1 = [PAST +], 
      (1 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda 
                           (e) (prop e 2)) (lambda (e2) (PAST (ta e2))) 
                        equa)))))) : 
   1 = [PAST FUT], (1 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (prop e 2)) 
                        (lambda (e2) (FUT (ta e2))) equa)))))).
IDRULE S/PRO2 : ; so he did, so there were.
   
   S[+FIN, +AUX, -INV, COMP NORM, SLASH NOSLASH, +PRO, WH NO, UB NO, EVER NO, 
      AGR N2] --> [SO +, NEG -, CONEG -], H2[+SUBJ, SLASH NOSLASH, COORD -] : 
   2.
\end{verbatim}
{\bf ; X2[+ADV] rules}
\begin{verbatim}
IDRULE X2/MOD1 : ; an adverbial modifier can be an AP[+ADV].
   X2[+ADV, CONJ NULL, WH @a, UB @b, EVER @c, QUA @q] --> 
   A2[+ADV, WH @a, UB @b, EVER @c, QUA @q] : 
   1 = [AFORM (ER, EST, AS)], (lambda (x) (1 x)) : 
   1 = [AFORM NONE, DISTR PRD], (lambda (x) (1 degree x)) : 
   1 = [QUA -, AFORM NONE, DISTR (ATT, @)], (lambda (x) (1 x)) : 
   1 = [QUA +, AFORM NONE, DISTR (ATT, @)], 1.
IDRULE X2/MOD2 : ; an adverbial modifier can be a PP.
   X2[+ADV, CONJ NULL, WH @a, UB @b, EVER @c, PRD +, QUA -, LOC @l] --> 
   P2[PFORM NORM, NEG -, WH @a, UB @b, EVER @c, PRD +, GERUND @g, LOC @l] : 1.
IDRULE X2/MOD3 : ; an adverbial modifier can be an N2[+ADV]. these are -QUA
                 ; although some provision ought to be made for
                 ; quantificational ones like "three times".
   X2[+ADV, CONJ NULL, WH @a, UB @b, EVER @c, QUA -] --> 
   N2[+ADV, +SPEC, -PRD, WH @a, UB @b, EVER @c] : (lambda (e) (AT-TIME e 1)).
IDRULE X2/MOD4 : ; an adverbial modifer can be a gerund VP: 'having helped
                 ; kim, lee left', 'wanting to help, lee washed up'.
   X2[+ADV, CONJ NULL, WH NO, UB NO, EVER NO, QUA -] --> 
   VP[GER, AGR N2[NFORM NORM]] : 
   (lambda (e) (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                     ((lambda (event) (and 
                              (prop event (pro (the (z) (entity z)))) 
                              (CAUSAL-RELN e event))) 
                        (uqe ((equa some) (e3) (NOTENSE (ta e3)))))))))).
\end{verbatim}
{\bf ; PP rules}
\begin{verbatim}
IDRULE P2/ADVMOD : ; right behind the house. Restricted to [PFORM NORM] PPs
                   ; to prevent spurious parses but this may be overly
                   ; restrictive.
   P2[PFORM NORM, PRD +] --> A2[+ADV, -QUA], H1[PRD -] : 
   (lambda (x) (2 (lambda (p) (lambda (np) (p x np (degree 1)))))).
IDRULE P2/P1 : P2 --> H1 : 1.
IDRULE P2/NEG : ; not in the kennel. (+NEG PPs will only be able to appear
                ; in conjoined PPs - 'put the dog in the garden but not in
                ; the kennel' vs '* put the dog not in the kennel' - see
                ; defrules NEG1 and NEG2)
   P2[NEG +, WH NO, UB NO, EVER NO] --> [NEG +], H2[NEG -] : 
   2 = [SLASH NOSLASH], (lambda (x) (NOT (2 x))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) (NOT (2 x wh)))).
IDRULE P2/PRO1 : ; for wh pro-PPs eg 'when, where, why' and for non-wh
                 ; adverbials such as 'too' which can't be modified (*very
                 ; too, *so too) and which cannot therefore be treated as
                 ; simple adverbs.
   P2[+PRO, -POSS] --> H[SUBCAT NULL] : 1.
IDRULE P2/PRO2 : ; for pro-forms such as "here", "then" etc.
   P2[+PRO, -POSS, PFORM NORM, PRD +, SLASH NOSLASH] --> 
   N2[+SPEC, PRO +, PRD +, SLASH NOSLASH] : 1.
IDRULE P1/PPa : ; prepositions taking PP complements headed by a particular
                ; preposition (encoded as value of PREP). 'Because of the
                ; weather' etc.
   P1[-POSS, -GER, WH NO, UB NO, EVER NO] --> H[SUBCAT PP, PREP @p], 
   P2[PFORM @p, PRD -] : 
   2 = [SLASH NOSLASH], (lambda (x) (2 (lambda (prep) (lambda (np) 
                  ((CP 1 prep) x np))))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) 
            (2 (lambda (prep) (lambda (np) ((CP 1 prep) x np))) wh))).
IDRULE P1/PPb : ; prepositions taking locative PP complements (PREP LOC).
                ; 'down in the cellar', 'out from under the floorboards'
                ; etc.
   P1[-POSS, -GER, WH NO, UB NO, EVER NO] --> H[SUBCAT PP, PREP LOC], 
   P2[PFORM NORM, LOC +, PRD -] : 
   0 = [PRD (+, @)], 2 = [SLASH NOSLASH], (lambda (x) 
         (2 (lambda (prep) (lambda (np) ((CP 1 prep) x np))))) : 
   0 = [PRD (+, @)], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (2 (lambda (prep) 
                  (lambda (np) ((CP 1 prep) x np))) wh))) : 
   0 = [PRD -], 2 = [SLASH NOSLASH], 
      (2 (lambda (prep) (lambda (np) (lambda (Q) (Q (1 prep) np))))).
IDRULE P1/NPa : ; Separate rule for possessive 'of' PP means that -POSS has
                ; to appear on P1. To prevent PP[UB R, WH -] from occurring
                ; - for example in "*the table on that I put the book, *the
                ; man a book about that I read" - this rule has to be split
                ; into two. This is a non-wh version; P1/NPb is a [WH +]
                ; version.
   P1[-POSS, -GER, WH NO, UB NO, EVER NO] --> H[SUBCAT NP], 
   N2[-POSS, NFORM NORM, PRD -, ADV -] : 
   1 = [PRD +], 2 = [SLASH NOSLASH], (lambda (x) (1 x 2)) : 
   1 = [PRD +], 2 = [SLASH X2], (lambda (x) (lambda (wh) (1 x (2 wh)))) : 
   1 = [PRD -], 2 = [SLASH NOSLASH], (lambda (Q) (Q 1 2)) : 
   1 = [PRD -], 2 = [SLASH X2], (lambda (Q) (lambda (wh) (Q 1 (2 wh)))).
IDRULE P1/NPb : ; [WH +] version of P1/NPa.
   P1[-POSS, -GER, WH +] --> H[SUBCAT NP], 
   N2[-POSS, NFORM NORM, PRD -, ADV -] : 
   1 = [PRD +], 2 = [UB Q], (lambda (x) (1 x 2)) : 
   1 = [PRD +], 2 = [UB R], (lambda (z) (lambda (x) (1 x (2 z)))) : 
   1 = [PRD -], 2 = [UB Q], (lambda (Q) (Q 1 2)) : 
   1 = [PRD -], 2 = [UB R], (lambda (x) (lambda (Q) (Q 1 (2 x)))).
IDRULE P1/NPc : ; for date PPs - 'on tuesday'. The NP is [ADV +] and the P1
                ; is [MODTYPE VBL] (*the hospital on tuesday).
   P1[-POSS, -GER, WH NO, UB NO, EVER NO, MODTYPE VBL] --> 
   H[SUBCAT NP, PRD +, PFORM NORM], N2[-POSS, NFORM NORM, PRD -, ADV +] : 
   2 = [SLASH NOSLASH], (lambda (e) (AT-TIME e 2)) : 
   2 = [SLASH X2], (lambda (e) (lambda (wh) (AT-TIME e (2 wh)))).
IDRULE P1/POSS : ; of fido 's. Possessive P1. Preposition must be 'of'.
   P1[+POSS, -GER, PFORM NORM, WH NO, UB NO, EVER NO] --> 
   H[PFORM OF, SUBCAT NP], N2[+POSS, SLASH NOSLASH, NFORM NORM] : 2.
IDRULE P1/SFIN : ; before he went to bed
   P1[-POSS, -GER] --> H[SUBCAT SFIN], S[+FIN, COMP NORM, -INV] : 
   (lambda (e) (2 
            (lambda (prop) (lambda (ta) (lambda (equa) ((lambda (event) (and 
                              (prop event) (1 e event))) 
                        (uqe ((equa some) (e3) (ta e3))))))))).
IDRULE P1/VPING : ; after talking to John
   P1[-POSS, +GER] --> H[SUBCAT VPING], VP[GER, AGR N2[NFORM NORM]] : 
   (lambda (e) 
         (2 (lambda (prop) (lambda (ta) (lambda (equa) ((lambda (event) (and 
                              (prop event (pro (the (z) (entity z)))) 
                              (1 e event))) 
                        (uqe ((equa some) (e3) (ta e3))))))))).
IDRULE P1/SING : ; despite lee having abdicated
   P1[-POSS, +GER] --> H[SUBCAT SING], S[COMP NORM, GER] : 
   (lambda (e) (2 (lambda (prop) 
               (lambda (ta) (lambda (equa) ((lambda (event) (and (prop event) 
                              (1 e event))) 
                        (uqe ((equa some) (e3) (ta e3))))))))).
\end{verbatim}
{\bf ; VP rules}
\begin{verbatim}
IDRULE VP/INTR : ; he sings, it rains (either NORM or IT subject)
   VP[AGR N2] --> H[SUBCAT NULL] : 
   0 = [AGR N2[NFORM NORM]], (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   0 = [AGR N2[NFORM IT]], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/INTR_PHR : ; he falls over, it buckets down (either NORM or IT
                     ; subject)
   VP[AGR N2] --> H[SUBCAT NULL, PRT @p], [PRT @p] : 
   0 = [AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   0 = [AGR N2[NFORM IT]], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 2) e))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP : ; abandons his friends
   VP --> H[SUBCAT NP], N2[-PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PHRA : ; turn the light off / turn it off. Linearises so NP
                    ; preceds Prt. Idrule VP/NP_PHRB deals with the other
                    ; linearisation where NP must be -PRO.
   VP --> H[SUBCAT NP, PRT @p], N2[-PRD], [PRT @p] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 3) e x 2))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 3) e x (2 wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_PHRB : ; turn off the light (*turn off it). Prt precedes NP.
   VP --> H[SUBCAT NP, PRT @p], N2[-PRD, -PRO, BEGAP -], [PRT @p] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 3) e x 2))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e x (2 wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_NP : ; sends fido a book. The -PRD NP is the one affected by
                  ; passive
   VP --> H[SUBCAT NP_NP], N2[-PRD, BEGAP -], N2 : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 3 2))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x 3 (2 wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_NP_PHRA : ; bring me a book back/bring me it back. Linearises
                       ; so both NPs precede Prt. Idrule VP/NP_NP_PHRB deals
                       ; with the other linearisation where the second NP
                       ; must be -PRO. Both NPs are specified as SLASH
                       ; NOSLASH - this cuts down on spurious ambiguity
                       ; which would result if SLASH interacted with both
                       ; this rule and VP/NP_NP_PHRB. It also means the
                       ; PASSIVE won't apply which cuts down on more
                       ; ambiguity. There is one passive variant of this
                       ; rule which is OK - see VP/NP_NP_PHRA/PASS.
   VP --> H[SUBCAT NP_NP, PRT @p], N2[SLASH NOSLASH, -PRD], 
   N2[SLASH NOSLASH], [PRT @p] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 4) e x 3 2))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_NP_PHRB : ; bring me back a book (*bring me back it) Prt
                       ; precedes second (non-pro) NP.
   VP --> H[SUBCAT NP_NP, PRT @p], N2[-PRD], N2[-PRO], [PRT @p] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 4) e x 3 2))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 4) e x 3 (2 wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PPa : ; kim looks at sandy - [SUBTYPE PVERB] The PP is [PRD -] and
                ; in effect has the same translation as its NP object. The
                ; preposition combines with the verb to make a complex
                ; predicate. The semantics happens to give the right
                ; translation whether the PP is [SLASH NOSLASH] or [SLASH
                ; X2] so there is no need for the usual conditions.
   VP --> H[SUBCAT PP, PFORM @pf, SUBTYPE PVERB], P2[PRD -, PFORM @pf] : 
   (lambda (Q) 
         (Q (lambda (e) (lambda (x) (2 (lambda (prep) (lambda (y) ((CP 1 
                                 prep) e x y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/PPb : ; for non-[SUBTYPE PVERB] verbs. "kim abdicates from the
                ; abbey". The PP is [PRD +] and behaves semantically like a
                ; VP modifier.
   VP --> H[SUBCAT PP, PFORM @pf, SUBTYPE NONE], P2[PRD +, PFORM @pf] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x) (2 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and (1 e x (2 e wh)))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PPa_PHR : ; make off with the butter - [SUBTYPE PVERB] The
                    ; semantics happens to give the right translation
                    ; whether the PP is [SLASH NOSLASH] or [SLASH X2] so
                    ; there is no need for the usual conditions.
   VP --> H[SUBCAT PP, PFORM @pf, PRT @p, SUBTYPE PVERB], [PRT @p], 
   P2[PRD -, PFORM @pf] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (3 (lambda (prep) 
                        (lambda (y) ((CP 1 2 prep) e x y)))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PPb_PHR : ; for non-[SUBTYPE PVERB] verbs. "kim breaks away from
                    ; the abbey".
   VP --> H[SUBCAT PP, PFORM @pf, PRT @p, SUBTYPE NONE], [PRT @p], 
   P2[PRD +, PFORM @pf] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (and ((CP 1 2) e x) (3 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and ((CP 1 2) e x (3 e wh)))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PPa : ; "give a book to him" - Dative-shift verbs where the
                   ; preposition plays no semantic role. The PP is [PRD -]
                   ; and in effect has the same translation as its NP
                   ; object. The preposition disappears.
   VP --> H[SUBCAT NP_PP, PFORM @pf, SUBTYPE DMOVT], N2[-PRD], 
   P2[PFORM @pf, PRD -] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e x 2 (3 (lambda (prep) (lambda (y) y)))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prep) (lambda (y) y))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PPb : ; for non-Dative-shift verbs. The PP is [PRD +] and
                   ; behaves semantically like a VP modifier.
   VP --> H[SUBCAT NP_PP, PFORM @pf, SUBTYPE NONE], N2[-PRD], 
   P2[PFORM @pf, PRD +] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (and (1 e x 2) (3 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and (1 e x (2 wh)) (3 e))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_PPa_PHRA : ; bring a book back for me / bring it back for me.
                        ; Linearises so NP preceds Prt. Idrule VP/NP_PP_PHRB
                        ; deals with the other linearisation where NP must
                        ; be -PRO. Dative shift verbs where the preposition
                        ; plays no semantic role.
   VP --> H[SUBCAT NP_PP, PFORM @pf, PRT @p, SUBTYPE DMOVT], N2[-PRD], 
   [PRT @p], P2[PFORM @pf, PRD -] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 3) e x 2 
                     (4 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 3) e x (2 wh) 
                        (4 (lambda (prep) (lambda (y) y))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PPb_PHRA : ; for non-Dative-shift verbs. The PP is [PRD +] and
                        ; behaves semantically like a VP modifier.
   VP --> H[SUBCAT NP_PP, PFORM @pf, PRT @p, SUBTYPE NONE], N2[-PRD], 
   [PRT @p], P2[PFORM @pf, PRD +] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (and ((CP 1 3) e x 2) (4 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and ((CP 1 3) e x (2 wh)) (4 e))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PPa_PHRB : ; bring back a book for me (*bring back it for me).
                        ; Prt precedes NP. Dative shift verbs where the
                        ; preposition plays no semantic role.
   VP --> H[SUBCAT NP_PP, PFORM @pf, PRT @p, SUBTYPE DMOVT], N2[-PRD, -PRO], 
   [PRT @p], P2[PFORM @pf, PRD -] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 3) e x 2 
                     (4 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 3) e x (2 wh) 
                        (4 (lambda (prep) (lambda (y) y))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_PPb_PHRB : ; for non-Dative-shift verbs. The PP is [PRD +] and
                        ; behaves semantically like a VP modifier.
   VP --> H[SUBCAT NP_PP, PFORM @pf, PRT @p, SUBTYPE NONE], N2[-PRD, -PRO], 
   [PRT @p], P2[PFORM @pf, PRD +] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (and ((CP 1 3) e x 2) (4 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and ((CP 1 3) e x (2 wh)) (4 e))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_PP : ; account/answer for it to him, appeal to him against it
   VP[SLASH @s] --> H[SUBCAT PP_PP, PFORM @pf, SUBTYPE @su], 
   P2[PFORM @pf, SLASH @s, +PRD], P2[PFORM @pf, +PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (and (1 e x) (2 e) (3 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and (1 e x) (2 e wh) 
                        (3 e))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_PP_PHR : ; come down on him for his bad behaviour
   VP[SLASH @s] --> H[SUBCAT PP_PP, PFORM @pf, PRT @p, SUBTYPE @su], 
   [PRT @p], P2[PFORM @pf, SLASH @s, +PRD], P2[PFORM @pf, +PRD] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and ((CP 1 2) e x) (3 e) 
                     (4 e)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (and ((CP 1 2) e x) 
                        (3 e wh) (4 e))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_PP_PP : ; he turned it from a disaster into a victory
   VP --> H[SUBCAT NP_PP_PP, PFORM @pf], N2[-PRD], P2[PFORM @pf, +PRD], 
   P2[PFORM @pf, +PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (and (1 e x 2) (3 e) (4 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and (1 e x (2 wh)) (3 e) (4 e))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/LOC : ; he fell through the floor, he got into bed
   VP --> H[SUBCAT LOC], P2[+LOC] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e x (2 x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 x wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/LOC_PHR : ; he ended up on the floor below
   VP --> H[SUBCAT LOC, PRT @p], [PRT @p], P2[+LOC] : 
   3 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 2) e x (3 x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 2) e x (3 x wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_LOC : ; puts the book on the desk
   VP --> H[SUBCAT NP_LOC], N2[-PRD], P2[+LOC] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 2 (3 2)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) (3 (2 wh)))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/MEASP : ; fido cost ten pounds.
   VP --> H[SUBCAT MP], N2 : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e x (amount 2)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (1 e x (amount 
                           (2 wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_MEASP : ; it cost him $5
   VP --> H[SUBCAT NP_MP], N2[-PRD], N2 : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e x 2 (amount 3)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) (amount 3))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_MEASP_PHR : ; it set him back $5
   VP --> H[SUBCAT NP_MP, PRT @p], N2[-PRD], N2[PRO -], [PRT @p] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 4) e x 2 (amount 3)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 4) e x (2 wh) 
                        (amount 3))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/ADVP : ; augur well, act badly
   VP --> H[SUBCAT ADVP], A2[ADV +] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (and (1 e x) (2 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and (1 e x) (2 e wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/ADVP_PHR : ; he came off badly
   VP --> H[SUBCAT ADL, PRT @p], [PRT @p], A2[ADV +] : 
   3 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (and ((CP 1 2) e x) (3 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and ((CP 1 2) e x) 
                        (3 e wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/ADVP_PP : ; things augur well for him
   VP --> H[SUBCAT ADVP_PP, PFORM @pf], A2[ADV +], P2[PFORM @pf, PRD +] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x) (2 e) (3 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and (1 e x) (2 e wh) 
                        (3 e))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_ADVP : ; acquit/carry oneself well, put it well
   VP --> H[SUBCAT NP_ADVP], N2[-PRD], A2[ADV +] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (and (1 e x 2) (3 e)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (and (1 e x (2 wh)) (3 e))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN1 : ; believes (that) he can do it
   VP --> H[SUBCAT SFIN, SUBTYPE NONE], S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN1_PHR : ; let out that he can do it.
   VP --> H[SUBCAT SFIN, SUBTYPE NONE, PRT @p], [PRT @p], S[+FIN] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x (3 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 2) e x 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN2 : ; it seems (that) he can do it
   VP[AGR N2[NFORM IT]] --> H[SUBCAT SFIN, SUBTYPE NONE], S[+FIN] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN2_PHR : ; it turns out that he can do it
   VP[AGR N2[NFORM IT]] --> H[SUBCAT SFIN, SUBTYPE NONE, PRT @p], [PRT @p], 
   S[+FIN] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e 
                     (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN3A : ; that he's not here matters
   VP[AGR S[FIN +]] --> H[SUBCAT SFIN, SUBTYPE EXTRAP] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SFIN3B : ; it matters that he wasn't there (extraposed)
   VP[AGR N2[NFORM IT]] --> H[SUBCAT SFIN, SUBTYPE EXTRAP], S[+FIN] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_SFIN1 : ; tells her (that) he can do it
   VP --> H[SUBCAT NP_SFIN, SUBTYPE NONE], N2[-PRD, NFORM NORM], S[+FIN] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta 
                           e3)))))))))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_SFIN1_PHR : ; have her on that he can do it
   VP --> H[SUBCAT NP_SFIN, SUBTYPE NONE, PRT @p], [PRT @p], 
   N2[-PRD, NFORM NORM], S[+FIN] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x 3 
                     (4 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 2) e x (3 wh) 
                        (4 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta 
                                                e3)))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_SFIN2A : ; that she wouldn't help bothers lee. The mother and
                      ; NP default to [SLASH NOSLASH] because of the [AGR S]
                      ; so there's no need for conditions in the semantics.
   VP[AGR S[FIN +]] --> H[SUBCAT NP_SFIN, SUBTYPE EXTRAP], 
   N2[-PRD, NFORM NORM] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_SFIN2B : ; it bothers lee that she wouldn't help (extrap)
   VP[AGR N2[NFORM IT]] --> H[SUBCAT NP_SFIN, SUBTYPE EXTRAP], 
   N2[-PRD, NFORM NORM], S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e 2 (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (2 wh) 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta 
                           e3)))))))))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SFIN1a : ; she acknowledges to him that ...
   VP --> H[SUBCAT PP_SFIN, SUBTYPE NONE, PFORM TO], P2[PRD -, PFORM TO], 
   S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 
                     (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SFIN1b : ; she agrees with him that ...
   VP --> H[SUBCAT PP_SFIN, SUBTYPE NONE, PFORM WITH], P2[PRD +, PFORM WITH], 
   S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3))))))))) 
                     (2 e)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (ta e3))))))))) (2 e wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SFIN1a_PHR : ; she gets through to him that he should help
   VP --> H[SUBCAT PP_SFIN, SUBTYPE NONE, PFORM TO, PRT @p], [PRT @p], 
   P2[PRD -, PFORM TO], S[+FIN] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x (4 
                        (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta e3)))))))) 
                     (3 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((CP 1 2) e x 
                        (4 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (3 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SFIN2A : ; that lee helps matters to her. No conditions in the
                      ; semantics because the rule defaults to [SLASH
                      ; NOSLASH] because of [AGR S].
   VP[AGR S[FIN +]] --> H[SUBCAT PP_SFIN, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (2 (lambda (prep) 
                           (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/PP_SFIN2B : ; it matters to her that lee helps (extrap)
   VP[AGR N2[NFORM IT]] --> H[SUBCAT PP_SFIN, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -], S[FIN +] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e3) (ta e3)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SFIN3 : ; Non-extraposable AGR IT ones - it appears to him that
                     ; .. it dawned on him that ..
   VP[AGR N2[NFORM IT]] --> H[SUBCAT PP_SFIN, SUBTYPE NONE, PFORM @pf], 
   P2[PFORM @pf, PRD -], S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e3) (ta e3)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_NP_SFIN : ; he bet her $5 that he could do it
   VP --> H[SUBCAT NP_NP_SFIN], N2[-PRD], N2, S[+FIN] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 2 (amount 3) 
                     (4 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) (amount 3) 
                        (4 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta 
                                                e3)))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SINF : ; arrange for him to do it
   VP --> H[SUBCAT SINF], S[TO, COMP FOR] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/PP_SINF : ; she arranged with him for them to help
   VP --> H[SUBCAT PP_SINF, PFORM @pf], P2[PFORM @pf, PRD +], 
   S[TO, COMP FOR] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (and (1 e x (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop 
                                       (uqe ((equa some) (e3) (ta e3))))))))) 
                     (2 e)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (ta e3))))))))) (2 e wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SBSE : ; advise that he do it
   VP --> H[SUBCAT SBSE], S[BSE, that] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_SBSE : ; he petitioned them that he be allowed to do it
   VP --> H[SUBCAT NP_SBSE], N2[-PRD], S[BSE] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta 
                           e3)))))))))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_SBSE : ; arrange with lee that he do it
   VP --> H[SUBCAT PP_SBSE, PFORM @pf], P2[PFORM @pf, PRD +], S[BSE, that] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x (3 (lambda (prop) 
                              (lambda (ta) 
                                 (lambda (equa) (prop (uqe ((equa some) (e3) 
                                             (ta e3))))))))) (2 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (ta e3))))))))) (2 e wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/WHS : ; embedded wh questions - wonders who he abandoned (S[+Q]
                ; expanded by S/UDC), wonders who abandoned him (S[+Q]
                ; expanded by normal S rule); asks whether/if fido is a dog.
                ; S[+Q] expanded by idrules S/Q1 and S/Q2. No conditions in
                ; the semantics because the rule defaults to [SLASH NOSLASH]
                ; (no extraction out of a wh complement).
   VP --> H[SUBCAT WHS], S[+Q, -INV] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 
                     (2 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/WHS_PHR : ; figure out where he went/whether he went. No
                    ; extraction out of the wh complement.
   VP --> H[SUBCAT WHS, PRT @p], [PRT @p], S[+Q, -INV] : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta 
                                             e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/WHS_PREP : ; knows about what he did/whether he did it. No
                     ; extraction out of the wh complement.
   VP --> H[SUBCAT WHS, PREP @pf], P[PFORM @pf], S[+Q, -INV] : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta 
                                             e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_WHS : ; advise/ask him where he might stay/ whether he is
                   ; staying
   VP --> H[SUBCAT NP_WHS], N2[-PRD], S[+Q, -INV] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta 
                           e3)))))))))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/IT_WHS : ; I would appreciate it if you could send me that book
   VP --> H[SUBCAT IT_WHS, SUBTYPE IF], N2[NFORM IT, SLASH NOSLASH], 
   S[COMP IF, +Q, WH NO, EVER NO] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 
                     (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/PP_WHS1a : ; dictate to him where they should meet / whether they
                     ; should meet.
   VP --> H[SUBCAT PP_WHS, PFORM TO], P2[PFORM TO, PRD -], S[+Q, -INV] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_WHS1b : ; arrange with him where they should meet / whether
                     ; they should meet.
   VP --> H[SUBCAT PP_WHS, PFORM WITH], P2[PFORM WITH, PRD +], S[+Q, -INV] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x (3 (lambda (prop) 
                              (lambda (ta) 
                                 (lambda (equa) (prop (uqe ((equa some) (e3) 
                                             (ta e3))))))))) (2 e)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (ta e3))))))))) (2 e wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_WHS2 : ; AGR IT - it dawned on him what he should do
   VP[AGR N2[NFORM IT]] --> H[SUBCAT PP_WHS, PFORM @pf], 
   P2[PFORM @pf, PRD -], S[+Q, -INV, +WH, -EVER] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta e3)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (ta e3)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/WHVP : ; wonders what to attack e (VP[+Q] expanded by idrule
                 ; VP/WH2; asks whether to go (VP[+Q] expanded by idrule
                 ; VP/WH1). No extraction out of the wh complement.
   VP --> H[SUBCAT WHVP], VP[+Q, WH @w, EVER @e] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e x (2 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e3) (ta e3))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/WHVP_PHR : ; figure out what to do/whether to leave. No extraction
                     ; out of the wh complement.
   VP --> H[SUBCAT WHVP, PRT @p], [PRT @p], VP[+Q] : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta e3))) 
                                    x)))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/WHVP_PREP : ; know about what to do; reflect on whether to help.
                      ; No extraction out of the wh complement.
   VP --> H[SUBCAT WHVP, PREP @pf], P[PFORM @pf], VP[+Q] : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta e3))) 
                                    x)))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/NP_WHVP : ; advise/ask him where to go/whether to go
   VP --> H[SUBCAT NP_WHVP], N2[-PRD], VP[+Q] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e3) (ta e3))) 
                                    (pro (the (z) (entity z))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3))) 
                                       (pro (the (z) (entity z)))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_WHVPa : ; dictate to him where to meet / whether to meet
   VP --> H[SUBCAT PP_WHVP, PFORM TO], P2[PFORM TO, PRD -], VP[+Q] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (ta e3))) 
                                    (pro (the (z) (entity z)))))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e3) (ta e3))) 
                                       (pro (the (z) (entity z)))))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_WHVPb : ; arrange with him where to meet / whether to meet
   VP --> H[SUBCAT PP_WHVP, PFORM WITH], P2[PFORM WITH, PRD +], VP[+Q] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x (3 (lambda (prop) 
                              (lambda (ta) 
                                 (lambda (equa) (prop (uqe ((equa some) (e3) 
                                             (ta e3))) 
                                       (pro (the (z) (entity z))))))))) 
                     (2 e)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) (ta e3))) 
                                          (pro (the (z) (entity z))))))))) 
                        (2 e wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_NP : ; appear a fool
   VP --> H[SUBCAT SC_NP, SUBTYPE RAIS], N2[+PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e (BE (uqe ((equa some) (e1) 
                              (NOTENSE e1))) (2 x))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (2 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_NP_PHR : ; turn out a fool
   VP --> H[SUBCAT SC_NP, PRT @p, SUBTYPE RAIS], [PRT @p], N2[+PRD] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (3 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_NP : ; look a fool
   VP --> H[SUBCAT SC_NP, SUBTYPE EQUI], N2[+PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (2 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (BE 
                           (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (2 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_NP_PHR : ; end up a fool
   VP --> H[SUBCAT SC_NP, PRT @p, SUBTYPE EQUI], [PRT @p], N2[+PRD] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (3 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_AP : ; he seems/appears clever. It seems/appears obvious that
                  ; .... Subject Raising.
   VP --> H[SUBCAT SC_AP, SUBTYPE RAIS], A2 : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e (BE (uqe ((equa some) (e1) 
                              (NOTENSE e1))) (2 x))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (2 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_AP_PHR : ; he started out poor (subject rais)
   VP --> H[SUBCAT SC_AP, SUBTYPE RAIS, PRT @p], [PRT @p], A2 : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (3 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_AP : ; feel/become intelligent. (subject equi)
   VP --> H[SUBCAT SC_AP, SUBTYPE EQUI], A2 : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (2 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (BE 
                           (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (2 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_AP_PHR : ; he ended up even poorer than before (subject equi)
   VP --> H[SUBCAT SC_AP, SUBTYPE EQUI, PRT @p], [PRT @p], A2 : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (3 x))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 x wh)))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_INF : ; appear to be crazy (subject raising).
   VP --> H[SUBCAT SC_INF, SUBTYPE RAIS], VP[TO] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_INF_PHR : ; he turned out to be a crook (subject raising).
   VP --> H[SUBCAT SC_INF, SUBTYPE RAIS, PRT @p], [PRT @p], VP[TO] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SE_INF : ; try to dance (subject equi)
   VP --> H[SUBCAT SC_INF, SUBTYPE EQUI], VP[TO] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_INF_PHR : ; he set out to win (subject equi)
   VP --> H[SUBCAT SC_INF, SUBTYPE EQUI, PRT @p], [PRT @p], VP[TO] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x (3 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SR_ING : ; start moving (subject raising).
   VP --> H[SUBCAT SC_ING, SUBTYPE RAIS], VP[ING, +PRD] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_ING_PHR : ; he carried on doing it (subject raising).
   VP --> H[SUBCAT SC_ING, SUBTYPE RAIS, PRT @p], [PRT @p], VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SR_ING_PREP : ; there could do with being less people (subject
                        ; raising).
   VP --> H[SUBCAT SC_ING, SUBTYPE RAIS, PREP @pf], P[PFORM @pf], 
   VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SE_ING : ; he anticipated having to leave (subject equi)
   VP --> H[SUBCAT SC_ING, SUBTYPE EQUI], VP[ING, +PRD] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_ING_PHR : ; he put off leaving (subject equi)
   VP --> H[SUBCAT SC_ING, SUBTYPE EQUI, PRT @p], [PRT @p], VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) ((CP 1 2) e x (3 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SE_ING_PREP : ; he was banking on leaving (subject equi)
   VP --> H[SUBCAT SC_ING, SUBTYPE EQUI, PREP @pf], P[PFORM @pf], 
   VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e x (3 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/SE_ING_PREP_PHR : ; he never got around to leaving (subject equi)
   VP --> H[SUBCAT SC_ING, SUBTYPE EQUI, PREP @pf, PRT @p], 
   [PRT @p, PREP @pf], VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((2 1) e x (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((2 1) e x 
                        (3 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_PAS : ; get arrested (subject raising)
   VP[AGR N2] --> H[SUBCAT SC_PASS, SUBTYPE RAIS], VP[PAS] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_BSE : ; dare dance (subject equi)
   VP --> H[SUBCAT SC_BSE, SUBTYPE EQUI], VP[BSE] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_PP_INF : ; seems (to fido) to be clever (subject raising)
   VP --> H[SUBCAT SC_PP_INF, SUBTYPE RAIS, PFORM @pf], P2[PFORM @pf, PRD -], 
   VP[TO] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) (1 e (3 
                        (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x))))) 
                     (2 (lambda (prep) (lambda (y) y)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e1) (NOTENSE (ta 
                                                   e1)))) x))))) 
                        (2 (lambda (prep) (lambda (y) y)) wh))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_PP_INF : ; he conspired with them to do it
   VP --> H[SUBCAT SC_PP_INF, SUBTYPE EQUI, PFORM @pf], P2[PFORM @pf, PRD +], 
   VP[TO] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) (and (1 e x 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x)))))) 
                     (2 e)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) (and (1 e x 
                           (3 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e1) 
                                                (NOTENSE (ta e1)))) x)))))) 
                        (2 e wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SE_NP_INF : ; promise kim to go (subject equi) in spite of the NP
                      ; object.
   VP --> H[SUBCAT SC_NP_INF, SUBTYPE EQUI], N2[-PRD, NFORM NORM], VP[TO] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_NP_AP : ; he strikes me as foolish, it strikes me as likely
                     ; that .. subject control - this patterns like
                     ; 'promise' (the NP object isn't the controller)
   VP --> H[SUBCAT SC_NP_AP, SUBTYPE RAIS, PREP @p], N2[-PRD, NFORM NORM], 
   [PRT @p], A2[-ADV, +PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 3) e (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                        (4 x)) 2))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) (4 x)) 
                        (2 wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SR_NP_NP : ; he strikes me as a fool subject control - but no
                     ; binding as there's no point syntactically
   VP[AGR N2] --> H[SUBCAT SC_NP_NP, SUBTYPE RAIS, PREP @p], 
   N2[-PRD, NFORM NORM], [PRT @p], N2[+PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 3) e (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (4 x)) 2))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) (4 x)) 
                        (2 wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OR_NP : ; consider fido a fool. 1st NP = -PRD (passivisable),
                  ; second NP = +PRD (not passivisable)
   VP --> H[SUBCAT OC_NP, SUBTYPE RAIS], N2[-PRD], N2[+PRD] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (3 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (BE 
                           (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_NP : VP --> H[SUBCAT OC_NP, SUBTYPE EQUI], N2[-PRD], N2[+PRD] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (3 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_AP : ; consider fido clever. Object Raising - see proprule
                  ; OBJ_CONTROL.
   VP --> H[SUBCAT OC_AP, SUBTYPE RAIS], N2[-PRD], A2[-ADV, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (3 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (BE 
                           (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_AP_PHR : ; make him out crazy
   VP --> H[SUBCAT OC_AP, SUBTYPE RAIS, PRT @p], N2[-PRD], [PRT @p], 
   A2[-ADV, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 3) e x (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                        (4 2))))) (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e x 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (4 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_AP : ; count him absent
   VP --> H[SUBCAT OC_AP, SUBTYPE EQUI], N2[-PRD], A2[-ADV, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (BE (uqe 
                           ((equa some) (e1) (NOTENSE e1))) (3 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (3 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_AP_PHR : ; sand it down smooth
   VP --> H[SUBCAT OC_AP, SUBTYPE EQUI, PRT @p], N2[-PRD], [PRT @p], 
   A2[-ADV, AGR N2, +PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 3) e x 2 
                     (BE (uqe ((equa some) (e1) (NOTENSE e1))) (4 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e x (2 wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (4 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_AP_PREP : ; condemn him as stupid
   VP --> H[SUBCAT OC_AP, SUBTYPE EQUI, PREP @p], N2[-PRD], [PRT @p], 
   A2[-ADV, AGR N2, +PRD] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 3) e x 2 
                     (BE (uqe ((equa some) (e1) (NOTENSE e1))) (4 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e x (2 wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (4 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_AP_PREP_PHR : ; put him down as stupid
   VP --> H[SUBCAT OC_AP, SUBTYPE EQUI, PREP @pf, PRT @p], N2[-PRD], 
   [PRT @p, PREP @pf], A2[-ADV, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((3 1) e x 2 (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (4 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((3 1) e x (2 wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) 
                           (4 (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_INF : ; believe fido to be an idiot (object raising)
   VP --> H[SUBCAT OC_INF, SUBTYPE RAIS], N2[-PRD], VP[TO, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) (2 wh)))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OR_INF_PHR : ; make him out to be crazy
   VP --> H[SUBCAT OC_INF, SUBTYPE RAIS, PRT @p], [PRT @p], N2[-PRD], 
   VP[TO, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e x (4 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_INF_PREP : ; allow for there to be traffic jams
   VP --> H[SUBCAT OC_PP_INF, PFORM @pf, SUBTYPE PVERB_OR], P[PFORM @pf], 
   N2[-PRD], VP[TO, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e x (4 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_INF1 : ; persuade fido to dance (object equi)
   VP --> H[SUBCAT OC_INF, SUBTYPE EQUI], N2[-PRD], VP[TO, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_INF1_PHR : ; spur them on to try harder
   VP --> H[SUBCAT OC_INF, SUBTYPE EQUI, PRT @p], N2[-PRD], [PRT @p], 
   VP[TO, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 3) e x 2 
                     (4 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 3) e x (2 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_INF1_PREP : ; look to him to help us
   VP --> H[SUBCAT OC_PP_INF, PFORM @pf, SUBTYPE PVERB_OE], P[PFORM @pf], 
   N2[-PRD], VP[TO, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e x 3 
                     (4 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x (3 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_PP_INF_PHR : ; keep on at him to join in
   VP --> H[SUBCAT OC_PP_INF, PFORM @pf, PRT @p, SUBTYPE PVERB_OE], [PRT @p], 
   P2[PFORM @pf, PRD -], VP[TO, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (3 (lambda (prep) 
                        (lambda (y) ((CP 1 2 prep) e x y (4 
                                 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) (prop 
                                             (uqe ((equa some) (e1) 
                                                   (NOTENSE (ta e1)))) 
                                             y))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (3 (lambda (prep) (lambda (y) 
                           ((CP 1 2 prep) e x y (4 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) (prop (uqe ((equa some) 
                                                   (e1) (NOTENSE (ta e1)))) 
                                             y))))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_INF2A : ; to go to the opera amuses him. No [SLASH X2] version
                     ; of the semantics because the NP and the mother are
                     ; [SLASH NOSLASH] by default because extractions out of
                     ; [AGR V2] VPs are ill-formed - *who does to go to the
                     ; opera amuse.
   VP[AGR VP[-FIN]] --> H[SUBCAT OC_INF, SUBTYPE EQU_EXTRAP], N2[-PRD] : 
   (lambda (Q) 
         (Q (lambda (e) (lambda (VP) (1 e (VP (lambda (prop) (lambda (ta) 
                              (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) (NOTENSE 
                                             (ta e1)))) 2))))) 2))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_INF2B : ; it amuses him to go to the opera (extrap)
   VP[AGR N2[NFORM IT]] --> H[SUBCAT OC_INF, SUBTYPE EQU_EXTRAP], N2[-PRD], 
   VP[TO, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                       ((equa some) (e1) (NOTENSE (ta e1)))) 
                                    2))))) 2))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (3 
                           (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e1) (NOTENSE (ta 
                                                   e1)))) (2 wh)))))) 
                        (2 wh))))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_INF3 : ; it behoves you to make amends
   VP[AGR N2[NFORM IT]] --> H[SUBCAT OC_INF, SUBTYPE EQUI], N2[-PRD], 
   VP[TO, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e 2 (3 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                       ((equa some) (e1) (NOTENSE (ta e1)))) 
                                    2)))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (1 e (2 wh) 
                        (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e1) (NOTENSE (ta 
                                                   e1)))) (2 wh)))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_INF3_PREP : ; it falls to you to help us
   VP[AGR N2[NFORM IT]] --> H[SUBCAT OC_PP_INF, PFORM @pf, SUBTYPE PVERB_OE], 
   P[PFORM @pf], N2[-PRD], VP[TO, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q 
            (lambda (e) (lambda (x) ((CP 1 2) e 3 (4 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e (3 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_ING : ; he anticipated them leaving (object raising)
   VP --> H[SUBCAT OC_ING, SUBTYPE RAIS], N2[-PRD], VP[ING, +PRD, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) (2 wh)))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OR_ING_PHR : ; stop there from being a riot (object raising)
   VP --> H[SUBCAT OC_PP_ING, PFORM @p, SUBTYPE PVERB_OR, ORDER POSTNP], 
   [PRT @p], N2[-PRD], VP[ING, +PRD, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 2) e x (4 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_ING_PREP : ; depend on there being something to eat
   VP --> H[SUBCAT OC_PP_ING, PFORM @pf, SUBTYPE PVERB_OR, ORDER PRENP], 
   P[PFORM @pf], N2[-PRD], VP[ING, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q 
            (lambda (e) (lambda (x) ((CP 1 2) e x (4 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_ING : ; their claim set him thinking (object equi)
   VP --> H[SUBCAT OC_ING, SUBTYPE EQUI], N2[-PRD], VP[ING, +PRD, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_ING_PHR : ; prevent him from leaving (object equi)
   VP --> H[SUBCAT OC_PP_ING, PFORM @p, SUBTYPE PVERB_OE, ORDER POSTNP], 
   [PRT @p], N2[-PRD], VP[ING, +PRD, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((CP 1 2) e x 3 
                     (4 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x (3 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_ING_PREP : ; look at them working
   VP --> H[SUBCAT OC_PP_ING, PFORM @pf, SUBTYPE PVERB_OE, ORDER PRENP], 
   P[PFORM @pf], N2[-PRD], VP[ING, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q 
            (lambda (e) (lambda (x) ((CP 1 2) e x 3 
                     (4 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x (3 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_ING_PREP_PHR : ; talk him out of leaving
   VP --> H[SUBCAT OC_PP_ING, PFORM @pf, SUBTYPE PVERB_OE, PRT @p], N2[-PRD], 
   [PRT @p, PREP @pf], VP[ING, AGR N2] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((3 1) e x 2 (4 
                        (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((3 1) e x (2 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_BSE : ; let/make lee wash up (object raising)
   VP --> H[SUBCAT OC_BSE, SUBTYPE RAIS], N2[-PRD], VP[BSE, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) (2 wh)))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_BSE : ; hear/see/help lee leave (object equi)
   VP --> H[SUBCAT OC_BSE, SUBTYPE EQUI], N2[-PRD], VP[BSE, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OE_BSE_PREP : ; look at him leave
   VP --> H[SUBCAT OC_PP_BSE, PFORM @pf, SUBTYPE PVERB_OE], P[PFORM @pf], 
   N2[-PRD], VP[BSE, AGR N2] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((CP 1 2) e x 3 
                     (4 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 3)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e x (3 wh) 
                        (4 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (3 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_PAS : ; get lee arrested (object raising)
   VP --> H[SUBCAT OC_PASS, SUBTYPE RAIS], N2[-PRD], VP[PAS, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (3 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) (2 wh)))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_PAS : ; see lee arrested
   VP --> H[SUBCAT OC_PASS, SUBTYPE EQUI], N2[-PRD], VP[PAS, AGR N2] : 
   2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (1 e x 2 (3 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 2)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 wh) 
                        (3 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) 
                                             (NOTENSE (ta e1)))) 
                                       (2 wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/INFA : ; to see them hurts (arbitrary control)
   VP[AGR VP[-FIN]] --> H[SUBCAT VPINF, SUBTYPE EXTRAP] : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e (x (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop 
                                    (uqe ((equa some) (e1) (NOTENSE (ta 
                                             e1)))) 
                                    (pro (the (z) (entity z))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/INFB : ; it hurts to see them (arbitrary control) (extrap)
   VP[AGR N2[NFORM IT]] --> H[SUBCAT VPINF, SUBTYPE EXTRAP], 
   VP[TO, AGR N2[NFORM NORM]] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (1 e (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) 
                                    (pro (the (z) (entity z))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) 
                                       (pro (the (z) (entity z))) wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/TO : ; to + base VP - infinitival VP of the kind which occurs in
               ; infinitival S and in numerous control constructions.
   VP[+AUX, VFORM TO, -FIN, ELLIP -, COORD -] --> H[SUBCAT TO], 
   VP[BSE, ELLIP -, COORD -] : 2.
IDRULE VP/MODAL1a : ; can dance, may be dancing etc. For (SUBTYPE NONE)
                    ; entries - ones which are ambiguous between epistemic
                    ; and deontic readings. The ambiguity is only available
                    ; in the case where the VP is AGR N2[NFORM NORM]. In
                    ; other cases, only the epistemic reading is possible.
   VP[+AUX, +FIN] --> H[SUBCAT MODAL_BSE, SUBTYPE NONE], VP[BSE] : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) ((1 (lambda (epi) (lambda (deo) epi))) 
                                 (prop e x)))) ta equa)))))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((1 (lambda (epi) (lambda (deo) deo))) e x 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                          (NOTENSE (ta e3)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) 
                                 ((1 (lambda (epi) (lambda (deo) epi))) 
                                    (prop e x wh))))) ta equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) ((1 (lambda (epi) (lambda (deo) 
                                 deo))) e x 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (NOT ((1 (lambda (epi) 
                                          (lambda (deo) epi))) (prop e x))))) 
                        ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (NOT ((1 (lambda (epi) (lambda (deo) deo))) e x 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                             (NOTENSE (ta e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) 
                                 (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                                       (prop e x wh)))))) ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (NOT ((1 (lambda (epi) 
                                 (lambda (deo) deo))) e x 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM (IT, THERE)]], 
      (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) 
                              ((1 (lambda (epi) (lambda (deo) epi))) (prop e 
                                    x)))) ta equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM (IT, THERE)]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) 
                                 ((1 (lambda (epi) (lambda (deo) epi))) 
                                    (prop e x wh))))) ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM (IT, THERE)]], 
      (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) 
                              (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                                    (prop e x))))) ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM (IT, THERE)]], 
      (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) 
                                 (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                                       (prop e x wh)))))) ta equa)))))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR V2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) ((1 (lambda (epi) (lambda (deo) epi))) 
                                 (prop e x)))) ta equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR V2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) ((1 (lambda (epi) 
                                          (lambda (deo) epi))) 
                                    (prop e x wh))))) ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR V2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (NOT ((1 (lambda (epi) 
                                          (lambda (deo) epi))) (prop e x))))) 
                        ta equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR V2], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT ((1 
                                          (lambda (epi) (lambda (deo) epi))) 
                                       (prop e x wh)))))) ta equa)))))).
IDRULE VP/MODAL1b : ; mustn't dance etc. For (SUBTYPE DEO) entries - ones
                    ; which can only have a deontic reading and can only be
                    ; [AGR N2[NFORM NORM]].
   VP[+AUX, +FIN, AGR N2[NFORM NORM]] --> H[SUBCAT MODAL_BSE, SUBTYPE DEO], 
   VP[BSE] : 
   1 = [NEG -], 2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e x 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe 
                                       ((equa some) (e3) (NOTENSE (ta e3)))) 
                                    x)))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) 
                     (1 e x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop 
                                       (uqe ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (NOT 
                     (1 e x (2 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop 
                                       (uqe ((equa some) (e3) (NOTENSE 
                                                (ta e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) 
                     (NOT (1 e x (2 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) 
                                       (prop (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/MODAL2 : ; ought to dance, have to dance. In the case of AGR
                   ; N2[NFORM NORM] the interpretation is ambiguous between
                   ; an epistemic and a deontic reading. In other cases,
                   ; only the epistemic reading is possible. It's not clear
                   ; whether any of this kind of modal can only be deontic
                   ; or not. If so, then a second version of this rule will
                   ; be needed along the lines of VP/MODAL1b.
   VP[+AUX, +FIN] --> H[SUBCAT MODAL_INF, SUBTYPE NONE], VP[TO, +AUX] : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((1 (lambda (epi) (lambda (deo) epi))) 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                          (NOTENSE (ta e3)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((1 (lambda (epi) (lambda (deo) deo))) e x 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                          (NOTENSE (ta e3)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) ((1 (lambda (epi) (lambda (deo) 
                                 epi))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) ((1 (lambda (epi) (lambda (deo) 
                                 deo))) e x 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                             (NOTENSE (ta e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (NOT ((1 (lambda (epi) (lambda (deo) deo))) e x 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                             (NOTENSE (ta e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (NOT ((1 (lambda (epi) 
                                 (lambda (deo) epi))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM NORM]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (NOT ((1 (lambda (epi) 
                                 (lambda (deo) deo))) e x 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR N2[NFORM (IT, THERE)]], 
      (lambda (Q) (Q 
            (lambda (e) (lambda (x) ((1 (lambda (epi) (lambda (deo) epi))) 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                          (NOTENSE (ta e3)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR N2[NFORM (IT, THERE)]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) ((1 (lambda (epi) (lambda (deo) 
                                 epi))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR N2[NFORM (IT, THERE)]], 
      (lambda (Q) (Q 
            (lambda (e) (lambda (x) (NOT ((1 (lambda (epi) (lambda (deo) 
                                 epi))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e3) (NOTENSE (ta 
                                                   e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR N2[NFORM (IT, THERE)]], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (NOT ((1 (lambda (epi) 
                                 (lambda (deo) epi))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, AGR V2], (lambda (Q) 
         (Q (lambda (e) (lambda (x) 
                  ((1 (lambda (epi) (lambda (deo) epi))) (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e3) 
                                          (NOTENSE (ta e3)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2, AGR V2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) ((1 (lambda (epi) (lambda (deo) epi))) 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                             (NOTENSE (ta e3)))) x 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, AGR V2], (lambda (Q) 
         (Q (lambda (e) (lambda (x) 
                  (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) 
                                             (NOTENSE (ta e3)))) x))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2, AGR V2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (NOT ((1 (lambda (epi) (lambda (deo) epi))) 
                           (2 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e3) 
                                                (NOTENSE (ta e3)))) x 
                                          wh)))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/DO1 : ; does dance.
   VP[+AUX, +FIN, VFORM NOT, ELLIP -, COORD -] --> H[SUBCAT DO], 
   VP[AUX -, BSE, ELLIP -, COORD -] : 2 = [SLASH NOSLASH], 1 = [NEG -], 2 : 
   2 = [SLASH NOSLASH], 1 = [NEG +], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e x)))) 
                        ta equa)))))) : 
   2 = [SLASH X2], 1 = [NEG -], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (lambda (wh) (prop e x wh)))) 
                        ta equa)))))) : 
   2 = [SLASH X2], 1 = [NEG +], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) 
                              (lambda (wh) (NOT (prop e x wh))))) ta 
                        equa)))))).
IDRULE VP/DO2 : ; for imperatives with 'do' and 'don't' - unlike the normal
                ; case (*fido does be a nice dog), 'do' can be followed by a
                ; +AUX VP in the imperative (do be a nice dog!).
   VP[AUX +, +FIN, BSE, AGR N2[NFORM NORM]] --> H[SUBCAT DO, AUX +], 
   VP[BSE] : 1 = [NEG -], 2 : 
   1 = [NEG +], (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e x)))) 
                        ta equa)))))).
IDRULE VP/HAVE : ; have, has, had (gone etc).
   VP[+AUX, ELLIP -, COORD -] --> H[SUBCAT HAVE], 
   VP[EN, PRD -, ELLIP -, COORD -] : 
   2 = [SLASH NOSLASH], 1 = [NEG -], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q prop (lambda (e2) (PERF (ta e2))) 
                        equa)))))) : 
   2 = [SLASH NOSLASH], 1 = [NEG +], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e x)))) 
                        (lambda (e2) (PERF (ta e2))) equa)))))) : 
   2 = [SLASH X2], 1 = [NEG -], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (lambda (wh) (prop e x wh)))) 
                        (lambda (e2) (PERF (ta e2))) equa)))))) : 
   2 = [SLASH X2], 1 = [NEG +], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop e x wh))))) 
                        (lambda (e2) (PERF (ta e2))) equa)))))).
IDRULE VP/WILL : ; will/shall dance - future tense. The [PAST FUT] condition
                 ; in the semantics is redundant but needed to get the right
                 ; conditions in the ouput of the metarules.
   VP[+AUX, +FIN, VFORM NOT, ELLIP -, COORD -] --> H[SUBCAT FUT], 
   VP[BSE, ELLIP -, COORD -] : 
   2 = [SLASH NOSLASH], 1 = [NEG -, PAST FUT], 2 : 
   2 = [SLASH NOSLASH], 1 = [NEG +, PAST FUT], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e x)))) 
                        ta equa)))))) : 
   2 = [SLASH X2], 1 = [NEG -, PAST FUT], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (prop e x wh)))) ta 
                        equa)))))) : 
   2 = [SLASH X2], 1 = [NEG +, PAST FUT], (2 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop e x wh))))) ta 
                        equa)))))).
IDRULE VP/BE_PRD : ; "be" followed by a predicative complement - this could
                   ; be any of NP, PP, AP, VP[VFORM ING], VP[PAS] - see id
                   ; rules PRD1-PRD4.
   VP[+AUX, ELLIP -, COORD -, SLASH @s, AGR @a] --> H[SUBCAT BE], 
   X2[+PRD, ELLIP -, COORD -, SLASH @s, AGR @a] : 
   2 = [SLASH NOSLASH], 1 = [NEG -], 2 : 2 = [SLASH X2], 1 = [NEG -], 2 : 
   2 = [SLASH NOSLASH], 1 = [NEG +], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e x)))) 
                        ta equa)))))) : 
   2 = [SLASH X2], 1 = [NEG +], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) 
                              (lambda (wh) (NOT (prop e x wh))))) ta 
                        equa)))))).
IDRULE VP/BE_NP : ; kim is my brother. Here the NP is -PRD and the semantics
                  ; asserts an equality between the subject and object NPs.
   VP[+AUX, AGR N2[NFORM NORM]] --> H[SUBCAT BE], N2[-PRD] : 
   1 = [NEG -], 2 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (BE e (equal x 2)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) 
                     (BE e (equal x (2 wh)))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (NOT (BE e (equal x 2))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (lambda (wh) 
                     (NOT (BE e (equal x (2 wh))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/BE_THERE : ; (there) is a mouse in the bathtub
   VP[+AUX, AGR N2[NFORM THERE, PLU @pl]] --> H[SUBCAT BE], 
   N2[PLU @pl, -DEF, PRD -, KIND -] : 
   1 = [NEG -], 2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (EXIST e 2))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SLASH X2], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (EXIST e (2 wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (NOT (EXIST e 2)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SLASH X2], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (NOT (EXIST e (2 wh)))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/BE_CLEFT1 : ; it is lee who/that relies on kim, it is lee who/that
                      ; kim relies on. This is equivalent to the first of
                      ; the it-cleft rules in GPSG85.
   VP[+AUX, AGR N2[NFORM IT]] --> H[SUBCAT BE], N2[-PRD, NFORM NORM], 
   S[+R, COMP NORM] : 
   1 = [NEG -], 2 = [SLASH NOSLASH], (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e 2))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (prop e (2 wh))))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e 2)))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop e (2 wh)))))) 
                        (lambda (e2) e2) equa)))))).
IDRULE VP/BE_CLEFT2 : ; it is on lee (that) kim relies. Partially equivalent
                      ; to second of the it-cleft rules in GPSG85. The P2 is
                      ; bound to the SLASH P2 by proprule SLASH/AGR_PP2.
   VP[+AUX, AGR N2[NFORM IT]] --> H[SUBCAT BE], P2, S[+FIN, SLASH P2] : 
   1 = [NEG -], 2 = [SLASH NOSLASH], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e 2))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, BEGAP -], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (prop e (2 wh))))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, BEGAP +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (prop e wh)))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e 2)))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, BEGAP -], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop e (2 wh)))))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, BEGAP +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop e wh))))) 
                        (lambda (e2) e2) equa)))))).
IDRULE VP/BE_CLEFT3 : ; it is in the abbey (that) kim helps them. Same as
                      ; VP/BE_CLEFT2 except the X2 after 'be' is an
                      ; adverbial modifier and not extracted.
   VP[+AUX, AGR N2[NFORM IT], SLASH @sl] --> H[SUBCAT BE], 
   X2[ADV +, CONJ NULL, SLASH @sl], S[+FIN, SLASH NOSLASH] : 
   1 = [NEG -], 2 = [SLASH NOSLASH, QUA (-, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e) (2 e)))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG -], 2 = [SLASH X2, QUA (-, @)], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (and (prop e) 
                                    (2 e wh))))) (lambda (e2) e2) 
                        equa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, QUA (-, @)], 
      (3 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (NOT (and (prop e) (2 e))))) 
                        (lambda (e2) e2) equa)))))) : 
   1 = [NEG +], 2 = [SLASH X2, QUA (-, @)], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (and (prop e) 
                                       (2 e wh)))))) (lambda (e2) e2) 
                        equa)))))) : 
   1 = [NEG -], 2 = [SLASH NOSLASH, QUA +], (3 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e))) 
                        (lambda (e2) e2) (lambda (qu) 2))))))) : 
   1 = [NEG -], 2 = [SLASH X2, QUA +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (prop (uqe 
                                       ((2 wh) (e1) (ta e1))))))) lta 
                        lequa)))))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH, QUA +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (prop e)))) 
                        (lambda (e2) e2) (lambda (qu) 2))))))) : 
   1 = [NEG +], 2 = [SLASH X2, QUA +], 
      (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (lambda (wh) (NOT (prop 
                                       (uqe ((2 wh) (e1) (ta e1)))))))) lta 
                        lequa)))))).
IDRULE VP/PP/PASS : ; This and the next few rules to do some kinds of
                    ; passive not produced by the passive metarule. This one
                    ; does prepositional passives - he hates being looked at
                    ; - the verb has to be SUBTYPE PVERB.
   VP[PAS, SLASH NOSLASH] --> H[SUBCAT PP, PFORM @pf, SUBTYPE PVERB], 
   P[SUBCAT NP, PFORM @pf], ( P2[by, PRD -, SLASH NOSLASH] ) : 
   (lambda (Q) (Q (lambda (e) 
               (lambda (y) ((CP 1 2) e (3 (lambda (prep) (lambda (x) x))) 
                     y))) (lambda (e2) e2) (lambda (qu) qu))) : 
   (lambda (Q) (Q 
            (lambda (e) (lambda (y) ((CP 1 2) e (uq (some (x) (entity x))) 
                     y))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/SFIN/PASS : ; 'that kim drinks is believed by lee'.
   VP[PAS, AGR S[+FIN]] --> H[SUBCAT SFIN, SUBTYPE NONE], ( P2[by, PRD -] ) : 
   (lambda (Q) 
         (Q (lambda (e) (lambda (x) (1 e (2 (lambda (prep) (lambda (y) y))) 
                     x))) (lambda (e2) e2) (lambda (qu) qu))) : 
   (lambda (Q) (Q 
            (lambda (e) (lambda (x) (1 e (uq (some (y) (entity y))) x))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/NP_SFIN2B/PASS : ; passive version of VP/NP_SFIN2B - 'fido is
                           ; bothered that lee attacks cats'.
   VP[PAS, AGR N2[NFORM NORM]] --> H[SUBCAT NP_SFIN, SUBTYPE EXTRAP], 
   S[+FIN, that] : 
   2 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (1 e x (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                       ((equa some) (e3) (ta e3))))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   2 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) (1 e x (2 
                           (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e3) (ta e3))) 
                                       wh))))))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE VP/OR_NP/PASS : ; he is considered a hero. (Not produced by PASSIVE2
                       ; because it puts AGR on the controlled complement
                       ; and NP doesn't have AGR).
   VP[PAS, SLASH @s] --> H[SUBCAT OC_NP, SUBTYPE RAIS], 
   N2[+PRD, SLASH NOSLASH], ( P2[by, PRD -, SLASH @s] ) : 
   3 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (y) (1 e (3 (lambda (prep) 
                           (lambda (x) x))) 
                     (BE (uqe ((equa some) (e1) (NOTENSE e1))) (2 y))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (y) (lambda (wh) (1 e (3 
                           (lambda (prep) (lambda (y) y)) wh) 
                        (BE (uqe ((equa some) (e1) (NOTENSE e1))) (2 y)))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   (lambda (Q) (Q (lambda (e) (lambda (y) 
                  (1 e (uq (some (x1) (entity x1))) (BE 
                        (uqe ((equa some) (e1) (NOTENSE e1))) (2 y))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/OE_ING_PHR/PASS : ; he was prevented from leaving
   VP[PAS] --> H[SUBCAT OC_PP_ING, PFORM @p, SUBTYPE PVERB_OE, ORDER POSTNP], 
   [PRT @p], VP[ING, +PRD] : 
   3 = [SLASH NOSLASH], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  ((CP 1 2) e (uq (some (y) (entity y))) x 
                     (3 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e1) 
                                          (NOTENSE (ta e1)))) x)))))))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   3 = [SLASH X2], (lambda (Q) (Q 
            (lambda (e) (lambda (x) (lambda (wh) ((CP 1 2) e 
                        (uq (some (y) (entity y))) x 
                        (3 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e1) (NOTENSE 
                                                (ta e1)))) x wh))))))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/PP_PHR/PASS : ; the jail has never been broken out of
   VP[PAS, SLASH NOSLASH] --> H[SUBCAT PP, PFORM @pf, PRT @p, SUBTYPE PVERB], 
   [PRT @p, PREP @pf] : 
   (lambda (Q) (Q (lambda (e) (lambda (y) ((2 1) e (uq (some (x) (entity x))) 
                     y))) (lambda (e2) e2) (lambda (qu) qu))).
IDRULE VP/MOD1 : ; Adverbial modifier (AP or PP) of VP. Linearises so that
                 ; the adverbial occurs to the right: "happened in the
                 ; abbey", "happens occasionally, (may have) happened
                 ; occasionally". Only -AUX VPs can be postmodified using
                 ; this rule in order to cut down on attachment ambiguities.
   VP[AUX -, ELLIP -, COORD -] --> VP[H +, ELLIP -, COORD -], X2[+ADV] : 
   1 = [SLASH NOSLASH], 2 = [-QUA], 
      (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e x) (2 e)))) ta 
                        equa)))))) : 
   1 = [SLASH X2], 2 = [-QUA], (1 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) 
                              (lambda (wh) (and (prop e x wh) (2 e))))) ta 
                        equa)))))) : 
   1 = [SLASH NOSLASH], 2 = [+QUA], (1 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e x))) ta 
                        (lambda (qu) (equa 2)))))))) : 
   1 = [SLASH X2], 2 = [+QUA], 
      (1 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (lambda (wh) (prop e x wh)))) 
                        ta (lambda (qu) (equa 2)))))))).
IDRULE VP/MOD2 : ; allows AP (but not PP) modifiers to precede non-finite,
                 ; non-predicative VPs: "has frequently happened, may
                 ; frequently have happened, will certainly happen" etc.
   VP[-FIN, -PRD, ELLIP -, COORD -] --> A2[+ADV], VP[H +, ELLIP -, COORD -] : 
   1 = [-QUA], 2 = [SLASH NOSLASH], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e x) (1 e)))) ta 
                        equa)))))) : 
   1 = [-QUA], 2 = [SLASH X2], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) 
                              (lambda (wh) (and (prop e x wh) (1 e))))) ta 
                        equa)))))) : 
   1 = [+QUA], 2 = [SLASH NOSLASH], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e x))) ta 
                        (lambda (qu) (equa 1)))))))) : 
   1 = [+QUA], 2 = [SLASH X2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (lambda (wh) (prop e x wh)))) 
                        ta (lambda (qu) (equa 1)))))))).
IDRULE VP/NEG : ; (does) not dance. -FIN prevents 'not dances'
   VP[NEG +] --> [NEG +], H2[SUBJ -, FIN -, NEG -] : 
   2 = [SLASH NOSLASH], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (NOT (prop e x)))) ta 
                        equa)))))) : 
   2 = [SLASH X2], (2 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q 
                        (lambda (e) (lambda (x) (lambda (wh) 
                                 (NOT (prop e x wh))))) ta equa)))))).
IDRULE VP/WH1 : ; whether to go
   VP[+Q, WH NO, EVER NO] --> [SUBCAT WHETHER], 
   VP[H +, TO, AGR N2[NFORM NORM]] : 
   (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q prop (lambda (e2) (NOTENSE (ta e2))) 
                        equa)))))).
IDRULE VP/WH2 : ; what to do etc
   VP[+Q, +WH, -EVER, SLASH NOSLASH] --> N2[+Q, +WH, -EVER], 
   VP[H +, TO, SLASH N2, AGR N2[NFORM NORM]] : 
   (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e x 1))) 
                        (lambda (e2) (NOTENSE (ta e2))) equa)))))).
IDRULE VP/PRO : ; pro vps "he does" "he wouldn't" etc
   VP[+AUX, AGR N2] --> H[SUBCAT NULL, SUBTYPE NONE, PRO +] : 1.
IDRULE VP/PRO2 : ; P2[+PRO, -PRD] ("too") inside pro VP. "kim has too".
   VP[+AUX, AGR N2] --> H[SUBCAT NULL, PRO +], 
   P2[+PRO, -PRD, COORD -, PFORM NORM, SLASH NOSLASH] : 
   (1 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q (lambda (e) (lambda (x) 
                              (and (prop e x) (2 e)))) ta equa)))))).
IDRULE VP/PRO/NEG : ; pro VPs plus "not" (.. but he was not, ... kim may
                    ; not). Has to be finite.
   VP[+AUX, AGR N2, +FIN] --> H[SUBCAT NULL, PRO +], [NEG +] : 
   (1 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) (lambda 
                              (x) (NOT (prop e x)))) ta equa)))))).
IDRULE VP/PRO/SLASH : ; to terminate the [SLASH V2] introduced by
                      ; N2+/COMPAR4 and A2/COMPAR4 -- lee helps more abbots
                      ; than kim did/will/can etc. SUBCAT @s, SUBTYPE DEO
                      ; allows both special modal entries (SUBCAT MODAL_BSE,
                      ; SUBTYPE DEO) and ordinary non-modal +PRO auxs
                      ; (SUBCAT NULL, SUBTYPE @) to match - semantics
                      ; differs according to which.
   VP[+AUX, AGR N2[NFORM NORM], SLASH VP] --> 
   H[SUBCAT @s, SUBTYPE DEO, PRO +] : 
   1 = [SUBCAT NULL], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (wh e x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SUBCAT MODAL_BSE], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) 
                     (1 e x (wh (uqe (some (e1) NOTENSE e1)) x))))) 
            (lambda (e2) e2) (lambda (qu) qu))).
\end{verbatim}
{\bf ; X2[+PRD] rules}
\begin{verbatim}
IDRULE PRD1 : ; an X2[+PRD] can be an N2.
   X2[PRD +, CONJ NULL, AGR N2[NFORM NORM]] --> N2[+PRD, -DEF] : 
   1 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (BE e (1 x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (BE e (1 x wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE PRD2 : ; an X2[+PRD] can be an A2.
   X2[PRD +, CONJ NULL] --> A2[+PRD] : 
   1 = [SLASH NOSLASH, QUA -], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (BE e (1 x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SLASH X2, QUA -], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (lambda (wh) (BE e (1 x wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SLASH NOSLASH, QUA +], (lambda (Q) (Q (lambda (e) 
               (lambda (x) (BE e ((1 l1 l2 (lambda (a) (lambda (b) a))) x)))) 
            (lambda (e2) e2) (lambda (qu) qu))).
IDRULE PRD3 : ; an X2[+PRD] can be an P2.
   X2[PRD +, CONJ NULL, AGR N2[NFORM NORM]] --> P2[+PRD, PFORM NORM] : 
   1 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (BE e (1 x)))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (x) 
                  (lambda (wh) (BE e (1 x wh))))) (lambda (e2) e2) 
            (lambda (qu) qu))).
IDRULE PRD4 : ; an X2[+PRD] can be an VP.
   X2[+PRD, CONJ NULL] --> VP[+PRD] : 
   1 = [VFORM ING], (1 (lambda (prop) (lambda (ta) 
               (lambda (equa) (lambda (Q) (Q prop (lambda (e) (PROG (ta e))) 
                        equa)))))) : 1 = [VFORM EN], 1.
IDRULE PRD/MOD : ; allows AP (but not other) modifiers to precede XP[+PRD]:
                 ; "is eagerly helping", "was sometimes crazy", "is probably
                 ; in the abbey" etc.
   X2[+PRD, SLASH @s, AGR @a, COORD @c, ELLIP -] --> A2[+ADV, AFORM NONE], 
   X2[H +, +PRD, SLASH @s, AGR @a, COORD @c, ELLIP -] : 
   1 = [-QUA], 2 = [SLASH NOSLASH], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) 
                           (lambda (x) (and (prop e x) (1 e)))) ta 
                        equa)))))) : 
   1 = [-QUA], 2 = [SLASH X2], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) 
                              (lambda (wh) (and (prop e x wh) (1 e))))) ta 
                        equa)))))) : 
   1 = [+QUA], 2 = [SLASH NOSLASH], (2 (lambda (prop) 
            (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e x))) ta 
                        (lambda (qu) (equa 1)))))))) : 
   1 = [+QUA], 2 = [SLASH X2], 
      (2 (lambda (prop) (lambda (ta) (lambda (equa) (lambda (Q) 
                     (Q (lambda (e) (lambda (x) (lambda (wh) (prop e x wh)))) 
                        ta (lambda (qu) (equa 1)))))))).
\end{verbatim}
{\bf ; top category NP rules}
\begin{verbatim}
IDRULE T/NP1 : ; this recognises non-predicative NP as a TOP category (in
               ; addition to S (see idrules T1-T3)). It is useful when
               ; testing the NP rules but its effects can be by-passed if
               ; it's not wanted. To do this, change the TOP declaration so
               ; that just S is recognized.
   [T NP] --> N2[H +, POSS -, PRD -, WH NO] : 1.
IDRULE T/NP2 : ; this recognises N2[WH +, UB Q] as a TOP category.
   [T NP] --> N2[H +, POSS -, PRD -, WH +, UB Q] : 1.
\end{verbatim}
{\bf ; NP rules}
\begin{verbatim}
IDRULE N2+/PRO : ; pronouns - i, me, my, who, whose etc. PROTYPE
                 ; distinguishes those that can be postmodified from those
                 ; that can't (PROTYPE NONE) and PART distinguishes those
                 ; that can head partitives (PART OF, NO_OF, OF2) from those
                 ; that can't (PART -). The semantics differs depending on
                 ; the type and, in the case of the post-modifiable ones, on
                 ; whether they are predicative or not.
   N2[+SPEC, AFORM @a] --> H[SUBCAT NULL, PRO +, AFORM @a] : 
   1 = [PRD (-, @), PROTYPE NONE, PART -], 1 : 
   1 = [PRD (-, @), PROTYPE (COMPOUND, PMOD+, PMOD, THAT), PART -], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (type (quant (x) (exp x))))))) : 
   1 = [PRD +, PROTYPE NONE, PART -], 1 : 
   1 = [PRD +, PROTYPE (COMPOUND, PMOD), PART -], 
      (1 (lambda (type) (lambda (quant) 
               (lambda (exp) (lambda (prep) (lambda (y) 
                        (prep y (type (quant (x) (exp x)))))))))) : 
   1 = [PART (OF, OF2, NO_OF), NUM -], 
      (lambda (x) (lambda (y) (proportion x y 1))) : 
   1 = [PART (OF, OF2, NO_OF), NUM CARD], 
      (lambda (x) (lambda (y) (quantity x y 1))).
IDRULE N2+/N1PROa : ; for post-modified pronouns which have to be treated as
                    ; N1s in order to acquire their post-modifiers. "Someone
                    ; who cares", "all that glitters", "there where he
                    ; fell", "here in the abbey" etc.
   N2[+SPEC, SLASH NOSLASH] --> H1[PRO +, MOD POST] : 
   1 = [PRD -], (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (type (quant (x) (exp x))))))) : 
   1 = [PRD +], 
      (1 (lambda (type) (lambda (quant) (lambda (exp) (lambda (prep) 
                     (lambda (y) (prep y (type (quant (x) (exp x)))))))))).
IDRULE N2+/N1PROb : ; a few post-modifiable pronouns can appear with a
                    ; definite article: "the many that left early", "the few
                    ; who didn't", "the three in the abbey" etc.
   N2[+SPEC, SLASH NOSLASH] --> 
   DetN[+DEF, WH NO, UB NO, EVER NO, POSS -, AGR 
         N2[PLU @a1, COUNT @a2, QFEAT -]], 
   H1[PRO +, PRD -, MOD POST, PROTYPE PMOD+, PLU @a1, COUNT @a2] : 
   (2 (lambda (type) 
            (lambda (quant) (lambda (exp) (dd (quant (x) (exp x))))))).
IDRULE N2+/DET1a : ; the, a, this dog. A number of different specifiers
                   ; attach under N2[+SPEC] ie Det, POSS NP, A2[+QUA] - in
                   ; complementary distribution. This rule does Det and only
                   ; [PRD -]. [PRD +] must be indefinite and the semantics
                   ; is different - see N2+/DET1b.
   N2[+SPEC, PRD -] --> DetN[AGR N2, WH NO, UB NO, EVER NO], H2[-SPEC] : 
   1 = [POSS -], 2 = [SLASH NOSLASH, QFEAT -, UB (NO, Q, @)], (1 2) : 
   1 = [POSS -], 2 = [SLASH NOSLASH, QFEAT -, UB R], (lambda (z) (1 (2 z))) : 
   1 = [POSS -], 2 = [SLASH NOSLASH, QFEAT +, PLU +], 
      (2 pl (lambda (qua) (lambda (exp) (dd (qua (x) (exp x)))))) : 
   1 = [POSS -], 2 = [SLASH NOSLASH, QFEAT +, PLU -], 
      (2 sg (lambda (qua) (lambda (exp) (dd (qua (x) (exp x)))))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT -, PLU +, UB (NO, Q, @)], 
      (uq (some (x) (and (pl x) (1 x) (2 x)))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT -, PLU +, UB R], 
      (lambda (z) (uq (some (x) (and (pl x) (1 x) (2 z x))))) : 
   1 = [POSS +], 
         2 = [SLASH NOSLASH, QFEAT -, PLU -, COUNT (+, @), UB (NO, Q, @)], 
      (uq (some (x) (and (sg x) (1 x) (2 x)))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT -, PLU -, COUNT (+, @), UB R], 
      (lambda (z) (uq (some (x) (and (sg x) (1 x) (2 z x))))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT -, PLU -, COUNT -, UB (NO, Q, @)], 
      (uq (some (x) (and (ms x) (1 x) (2 x)))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT -, PLU -, COUNT -, UB R], 
      (lambda (z) (uq (some (x) (and (ms x) (1 x) (2 z x))))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT +, PLU +], 
      (2 (lambda (y) (and (pl y) (1 y))) 
         (lambda (qua) (lambda (exp) (uq (qua (x) (exp x)))))) : 
   1 = [POSS +], 2 = [SLASH NOSLASH, QFEAT +, PLU -], 
      (2 (lambda (y) (and (sg y) (1 y))) 
         (lambda (qua) (lambda (exp) (uq (qua (x) (exp x)))))) : 
   1 = [POSS -], 2 = [SLASH X2, QFEAT -, UB (NO, @)], 
      (lambda (wh) (1 (lambda (x) (2 x wh)))) : 
   1 = [POSS -], 2 = [SLASH X2, QFEAT +, PLU +], 
      (lambda (wh) (2 wh pl (lambda (qua) 
               (lambda (exp) (dd (qua (x) (exp x))))))) : 
   1 = [POSS -], 2 = [SLASH X2, QFEAT +, PLU -], 
      (lambda (wh) (2 wh sg (lambda (qua) 
               (lambda (exp) (dd (qua (x) (exp x))))))) : 
   1 = [POSS +], 2 = [SLASH X2, QFEAT -, PLU +, UB (NO, @)], 
      (lambda (wh) (uq (some (x) (and (pl x) (1 x) (2 x wh))))) : 
   1 = [POSS +], 2 = [SLASH X2, QFEAT -, PLU -, COUNT (+, @), UB (NO, @)], 
      (lambda (wh) (uq (some (x) (and (sg x) (1 x) (2 x wh))))) : 
   1 = [POSS +], 2 = [SLASH X2, QFEAT -, PLU -, COUNT -, UB (NO, @)], 
      (lambda (wh) (uq (some (x) (and (ms x) (1 x) (2 x wh))))) : 
   1 = [POSS +], 2 = [SLASH X2, QFEAT +, PLU +], 
      (lambda (wh) (2 wh (lambda (y) (and (pl y) (1 y))) 
            (lambda (qua) (lambda (exp) (uq (qua (x) (exp x))))))) : 
   1 = [POSS +], 2 = [SLASH X2, QFEAT +, PLU -], 
      (lambda (wh) (2 wh (lambda (y) (and (sg y) (1 y))) 
            (lambda (qua) (lambda (exp) (uq (qua (x) (exp x))))))).
IDRULE N2+/DET1b : ; a dog. For [PRD +] indefinites - the semantics of the
                   ; determiner is ignored and the overall semantics is a
                   ; one place relation.
   N2[+SPEC, PRD +, DEF -] --> DetN[AGR N2, WH NO, UB NO, EVER NO, POSS -], 
   H2[-SPEC] : 2 = [SLASH NOSLASH, QFEAT -], (lambda (x) (2 x)) : 
   2 = [SLASH X2, QFEAT -], (lambda (x) (lambda (wh) (2 x wh))).
IDRULE N2+/DET2 : ; FOOT features propagate from determiner - which book
   N2[+SPEC, +WH, EVER @ev, UB @ub, PRD -] --> 
   DetN[AGR N2, +WH, EVER @ev, UB @ub], H2[-SPEC, WH NO, EVER NO, UB NO] : 
   2 = [QFEAT -], (1 2) : 
   1 = [EVER (-, @)], 2 = [QFEAT +, PLU +], (2 pl (lambda (qua) 
            (lambda (exp) (dd (qua (_wh) (exp _wh)))))) : 
   1 = [EVER +], 2 = [QFEAT +, PLU +], 
      (lambda (T) (2 pl (lambda (qua) (lambda (exp) 
                  (dd (qua (_wh) (and (exp _wh) (T _wh)))))))).
IDRULE N2+/POSSNP1 : ; NP with a possessive NP in determiner position -
                     ; "fido 's kennel" "the dog 's kennel", "the dogs '
                     ; kennel" etc. In this version the N2[-SPEC] must be
                     ; [QFEAT -] (i.e. not contain another quantifier). The
                     ; possessive NP cannot have a kind interpretation (this
                     ; is done by N1/POSSMOD1) so it's marked as [KIND -].
   N2[+SPEC, DEF @d] --> N2[POSS +, KIND -, DEF @d], H2[-SPEC, QFEAT -] : 
   0 = [SLASH NOSLASH, PLU +, DEF +], 
      (dd (the (x) (and (pl x) (1 x) (2 x)))) : 
   0 = [SLASH NOSLASH, PLU +, DEF -], 
      (uq (some (x) (and (pl x) (1 x) (2 x)))) : 
   0 = [SLASH NOSLASH, PLU -, COUNT (-, @), DEF +], 
      (dd (the (x) (and (ms x) (1 x) (2 x)))) : 
   0 = [SLASH NOSLASH, PLU -, COUNT (-, @), DEF -], 
      (uq (some (x) (and (ms x) (1 x) (2 x)))) : 
   0 = [SLASH NOSLASH, PLU -, COUNT (+, @), DEF +], 
      (dd (the (x) (and (sg x) (1 x) (2 x)))) : 
   0 = [SLASH NOSLASH, PLU -, COUNT (+, @), DEF -], 
      (uq (some (x) (and (sg x) (1 x) (2 x)))) : 
   0 = [SLASH X2, PLU +, DEF +], 
      (lambda (wh) (dd (the (x) (and (pl x) (1 x) (2 x wh))))) : 
   0 = [SLASH X2, PLU +, DEF -], 
      (lambda (wh) (uq (some (x) (and (pl x) (1 x) (2 x wh))))) : 
   0 = [SLASH X2, PLU -, COUNT -, DEF +], 
      (lambda (wh) (dd (the (x) (and (ms x) (1 x) (2 x wh))))) : 
   0 = [SLASH X2, PLU -, COUNT -, DEF -], 
      (lambda (wh) (uq (some (x) (and (ms x) (1 x) (2 x wh))))) : 
   0 = [SLASH X2, PLU -, COUNT +, DEF +], 
      (lambda (wh) (dd (the (x) (and (sg x) (1 x) (2 x wh))))) : 
   0 = [SLASH X2, PLU -, COUNT +, DEF -], 
      (lambda (wh) (uq (some (x) (and (sg x) (1 x) (2 x wh))))).
IDRULE N2+/POSSNP2 : ; FOOT features propagate from possesive NP - whose
                     ; book
   N2[+SPEC, +WH, -EVER, UB @u] --> N2[+POSS, +WH, -EVER, UB @u], 
   H2[-SPEC, WH NO, EVER NO, UB NO] : 
   2 = [QFEAT -, PLU +], (1 (lambda (x) (and (pl x) (2 x)))) : 
   2 = [QFEAT -, PLU -, COUNT +], (1 (lambda (x) (and (sg x) (2 x)))) : 
   2 = [QFEAT -, PLU -, COUNT -], (1 (lambda (x) (and (ms x) (2 x)))) : 
   1 = [UB R], 2 = [QFEAT +], 
      (lambda (z) (2 (lambda (y) (and (pl y) (lambda (R) (R y z)))) 
            (lambda (qua) (lambda (exp) (dd (qua (x) (exp x))))))) : 
   1 = [UB Q], 2 = [QFEAT +], 
      (2 (lambda (z) (and (pl z) (lambda (R) (R z (pro 
                        (the (_wh) (entity _wh))))))) 
         (lambda (qua) (lambda (exp) (dd (qua (x) (exp x)))))).
IDRULE N2+/POSSNP3 : ; NP with a possessive NP in determiner position where
                     ; the N2[-SPEC] is [QFEAT +] - "fido 's two kennels"
                     ; "the dog's many kennels" etc. The N2[-SPEC] must be
                     ; [PLU +] - "*fido 's much bravery"
   N2[+SPEC, +DEF] --> N2[POSS +], H2[-SPEC, PLU +, QFEAT +] : 
   0 = [SLASH NOSLASH], 
      (2 (lambda (y) (and (pl y) (1 y))) (lambda (qua) (lambda (exp) 
               (uq (qua (x) (exp x)))))) : 
   0 = [SLASH X2], (lambda (wh) (2 wh (lambda (y) (and (pl y) (1 y))) 
            (lambda (qua) (lambda (exp) (uq (qua (x) (exp x))))))).
IDRULE N2+/QUA : ; some, all, nearly all, both books
   N2[+SPEC] --> A2[+QUA, -PRD, AGR N2], H2[-SPEC, PN -, PRD -] : 
   2 = [QFEAT -, SLASH NOSLASH, UB (NO, Q, @)], (1 2) : 
   2 = [QFEAT -, SLASH NOSLASH, UB R], (lambda (z) (1 (2 z))) : 
   2 = [QFEAT -, SLASH X2], (lambda (wh) (1 (lambda (x) (2 x wh)))) : 
   2 = [QFEAT +, PLU +, SLASH NOSLASH], 
      (2 pl (lambda (qua) (lambda (exp) (dd (qua (x) (exp x)))))) : 
   2 = [QFEAT +, PLU +, SLASH X2], 
      (lambda (wh) (2 wh pl (lambda (qua) (lambda (exp) 
                  (dd (qua (x) (exp x))))))).
IDRULE N2+/N2-a : ; a 'determinerless' N2+. Can be plural or mass (binding
                  ; of values between PLU and COUNT exludes singular count)
                  ; and the result is indefinite. If PRD is instantiated to
                  ; + (as after 'be') then the interpretation is as a
                  ; predicate rather than as a quantifier. When it is [PRD
                  ; -] the N2 is interpreted as a generalized quantifier.
                  ; Since it is [QFEAT -] (i.e. doesn't contain a quantifier
                  ; lower down) it is existentially quantified. In the [PRD
                  ; -] case the NP is ambiguous between a simple indefinite
                  ; interpretation and a 'natural kind' interpretation,
                  ; depending on whether the feature KIND gets instantiated
                  ; or not. If it is left uninstantiated (as it generally
                  ; will be) then there will be an ambiguity. If it is
                  ; instantiated in either direction then the ambiguity
                  ; disappears (see eg idrules N2+/POSSb (KIND +) and
                  ; N2+/POSSNP1 (KIND -)).
   N2[SPEC +, DEF -, PLU @pc, COUNT @pc, KIND @k] --> 
   H2[SPEC -, DEF -, KIND @k, QFEAT -] : 
   1 = [SLASH NOSLASH, PRD +], (lambda (x) (1 x)) : 
   1 = [SLASH NOSLASH, PRD (-, @), PLU +, KIND (-, @)], 
      (uq (some (x) (and (pl x) (1 x)))) : 
   1 = [SLASH NOSLASH, PRD (-, @), PLU -, KIND (-, @)], 
      (uq (some (x) (and (ms x) (1 x)))) : 
   1 = [SLASH NOSLASH, PRD (-, @), PLU +, KIND (+, @)], 
      (kind (all (x) (and (pl x) (1 x)))) : 
   1 = [SLASH NOSLASH, PRD (-, @), PLU -, KIND (+, @)], 
      (kind (all (x) (and (ms x) (1 x)))) : 
   1 = [SLASH X2, PRD +], (lambda (x) (lambda (wh) (1 x wh))) : 
   1 = [SLASH X2, PRD (-, @), PLU +, KIND (-, @)], 
      (lambda (wh) (uq (some (x) (and (pl x) (1 x wh))))) : 
   1 = [SLASH X2, PRD (-, @), PLU -, KIND (-, @)], 
      (lambda (wh) (uq (some (x) (and (ms x) (1 x))))) : 
   1 = [SLASH X2, PRD (-, @), PLU +, KIND (+, @)], 
      (lambda (wh) (kind (all (x) (and (pl x) (1 x wh))))) : 
   1 = [SLASH X2, PRD (-, @), PLU -, KIND (+, @)], 
      (lambda (wh) (kind (all (x) (and (ms x) (1 x wh))))).
IDRULE N2+/N2-b : ; a 'determinerless' N2+ which contains a quantifer lower
                  ; down i.e. the N2[-SPEC] is [QFEAT +]. No restriction on
                  ; PLU and COUNT although the only singular count
                  ; instantiation should be "one abbot". No [PRD +] or [KIND
                  ; +] version possible. The interpretation of the
                  ; quantifier comes from the daughter.
   N2[SPEC +, DEF -, PRD -, KIND -, AFORM @a] --> 
   H2[SPEC -, DEF -, QFEAT +, AFORM @a] : 
   1 = [AFORM (NONE, EST, @), SLASH NOSLASH, COUNT +, PLU -], 
      (1 sg (lambda (qua) (lambda (exp) (uq (qua (x) (exp x)))))) : 
   1 = [AFORM (NONE, EST, @), SLASH NOSLASH, COUNT +, PLU +], 
      (1 pl (lambda (qua) (lambda (exp) (uq (qua (x) (exp x)))))) : 
   1 = [AFORM (NONE, EST, @), SLASH NOSLASH, COUNT -], 
      (1 ms (lambda (qua) (lambda (exp) (uq (qua (x) (exp x)))))) : 
   1 = [AFORM (NONE, EST, @), SLASH X2, COUNT +, PLU -], 
      (lambda (wh) (1 wh sg 
            (lambda (qua) (lambda (exp) (uq (qua (x) (exp x))))))) : 
   1 = [AFORM (NONE, EST, @), SLASH X2, COUNT +, PLU +], 
      (lambda (wh) (1 wh pl 
            (lambda (qua) (lambda (exp) (uq (qua (x) (exp x))))))) : 
   1 = [AFORM (NONE, EST, @), SLASH X2, COUNT -], 
      (lambda (wh) (1 wh ms (lambda (qua) 
               (lambda (exp) (uq (qua (x) (exp x))))))) : 
   1 = [AFORM (ER, AS), SLASH NOSLASH, COUNT +, PLU +], 
      (1 (lambda (co) (lambda (exp) 
               (exp pl (lambda (qua) (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (PROPRED c)))) (x) 
                              (N x))))))))) : 
   1 = [AFORM (ER, AS), SLASH NOSLASH, COUNT -], 
      (1 (lambda (co) (lambda (exp) 
               (exp ms (lambda (qua) (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (PROPRED c)))) (x) 
                              (N x))))))))) : 
   1 = [AFORM (ER, AS), SLASH X2, COUNT +, PLU +], 
      (lambda (wh) (1 (lambda (co) 
               (lambda (exp) (exp wh pl (lambda (qua) (lambda (N) 
                           (uq (((qua co) 
                                    (lambda (c) (and (N c) (PROPRED c)))) (x) 
                                 (N x)))))))))) : 
   1 = [AFORM (ER, AS), SLASH X2, COUNT -], 
      (lambda (wh) (1 (lambda (co) (lambda (exp) 
                  (exp wh ms (lambda (qua) (lambda (N) 
                           (uq (((qua co) (lambda (c) 
                                       (and (N c) (PROPRED c)))) (x) 
                                 (N x)))))))))).
IDRULE N2+/PN : ; proper names are unmodifiable ("*kim with an umbrella")
                ; (but see N2+/APPOS) and therefore this rule rewrites an
                ; N2+ directly as a +PN lexical head. This doesn't mean that
                ; names can't occur as heads in ordinary NPs - "the kim that
                ; I know" but these are done by id rule N1/PN making them
                ; into common nouns.
   N2[+SPEC, PN +, DEF +, PRD -] --> H[SUBCAT NULL, PN @pn, ADDRESS -] : 1.
IDRULE N2+/PART1 : ; partitives with 'of' where the X2 which precedes 'of'
                   ; is pronominal - neither/each/three/which of the books.
                   ; No agreement between H2 and N2.
   N2[+SPEC, SLASH @sl, PART -] --> H2[+SPEC, +PRO, PART OF, SLASH NOSLASH], 
   [PFORM OF], N2[+SPEC, CASE ACC, PLU +, DEF +, SLASH @sl] : 
   0 = [SLASH NOSLASH], 1 = [PLU +], 
      (uq (some (x) (and (pl x) (part x 3) (1 x 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU -], 
      (uq (some (x) (and (sg x) (part x 3) (1 x 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU @], 
      (uq (some (x) (and (part x 3) (1 x 3)))) : 
   0 = [SLASH X2], 1 = [PLU +], (lambda (wh) 
         ((lambda (a) (uq (some (x) (and (pl x) (part x a) (1 x a))))) 
            (3 wh))) : 
   0 = [SLASH X2], 1 = [PLU -], (lambda (wh) ((lambda (a) (uq 
                  (some (x) (and (pl x) (part x a) (1 x a))))) (3 wh))) : 
   0 = [SLASH X2], 1 = [PLU @], 
      (lambda (wh) ((lambda (a) (uq (some (x) (and (part x a) (1 x a))))) 
            (3 wh))).
IDRULE N2+/PART1B : ; same as N2+/PART1 except WH propagates from non-head -
                    ; neither of whose books.
   N2[+SPEC, +R, +WH, -EVER, PART -] --> 
   H2[+SPEC, +PRO, PART OF, WH NO, UB NO, EVER NO], [PFORM OF], 
   N2[+SPEC, CASE ACC, PLU +, DEF +, +R, +WH, -EVER] : 
   1 = [PLU +], (lambda (_wh) 
         ((lambda (a) (uq (some (x) (and (pl x) (part x a) (1 x a))))) 
            (3 _wh))) : 
   1 = [PLU -], (lambda (_wh) ((lambda (a) (uq (some (x) (and (sg x) 
                        (part x a) (1 x a))))) (3 _wh))).
IDRULE N2+/PART2 : ; partitives without 'of' where the first X2 is
                   ; pronominal - both the books, such/what a good idea. H2
                   ; and N2 agree in PLU COUNT and DEF. No extraction (see
                   ; def rule DSLASH12) - *which books do you have both.
   N2[+SPEC, PRD -, PART -] --> 
   H2[+SPEC, +PRO, PART NO_OF, PLU @p, COUNT @c, DEF @d], 
   N2[+SPEC, CASE ACC, PLU @p, COUNT @c, DEF @d, COORD -, PRD -] : 
   1 = [PLU +], (uq (some (x) (and (pl x) (part x 2) (1 x 2)))) : 
   1 = [PLU -], (uq (some (x) (and (sg x) (part x 2) (1 x 2)))).
IDRULE N2+/PART2B : ; same as N2+/PART2 except WH propagates from non-head -
                    ; both the pictures of whom
   N2[+SPEC, +R, +WH, -EVER, PART -] --> 
   H2[+SPEC, +PRO, PART NO_OF, PLU @p, COUNT @c, DEF @d, WH NO, UB NO, 
      EVER NO], N2[+ACC, +SPEC, PLU @p, COUNT @c, DEF @d, +R, +WH, -EVER] : 
   1 = [PLU +], 
      (lambda (_wh) ((lambda (a) (uq (some (x) (and (pl x) (part x a) 
                        (1 x a))))) (2 _wh))) : 
   1 = [PLU -], (lambda (_wh) ((lambda (a) 
               (uq (some (x) (and (sg x) (part x a) (1 x a))))) (2 _wh))).
IDRULE N2+/PART3 : ; partitives where the X2 which precedes 'of' is a +QUA
                   ; AP - all/several/many/most of the books/whose
                   ; books/which. Agreement between A2 and H2 is done by
                   ; proprule AGR/NOM.
   N2[+SPEC, CASE @c, PART -, PRO -, AFORM @a] --> 
   A2[PART OF, AGR N2, +QUA, AFORM @a], [PFORM OF], 
   H2[+SPEC, CASE ACC, DEF +, PRO @p] : 
   0 = [PLU +, UB (NO, @), SLASH NOSLASH], 
      (uq (some (x) (and (pl x) (part x 3) (1 x 3)))) : 
   0 = [PLU -, COUNT (-, @), UB (NO, @), SLASH NOSLASH], 
      (uq (some (x) (and (ms x) (part x 3) (1 x 3)))) : 
   0 = [PLU -, COUNT +, UB (NO, @), SLASH NOSLASH], 
      (uq (some (x) (and (sg x) (part x 3) (1 x 3)))) : 
   0 = [PLU +, UB R, SLASH NOSLASH], 
      (lambda (_wh) ((lambda (a) (uq (some (x) (and (pl x) (part x a) 
                        (1 x a))))) (3 _wh))) : 
   0 = [PLU -, COUNT (-, @), UB R, SLASH NOSLASH], 
      (lambda (_wh) ((lambda (a) (uq 
                  (some (x) (and (ms x) (part x a) (1 x a))))) (3 _wh))) : 
   0 = [PLU -, COUNT +, UB R, SLASH NOSLASH], 
      (lambda (_wh) ((lambda (a) (uq (some (x) 
                     (and (sg x) (part x a) (1 x a))))) (3 _wh))) : 
   0 = [PLU +, UB (NO, @), SLASH X2], 
      (lambda (wh) ((lambda (a) (uq (some (x) (and (pl x) (part x a) 
                        (1 x a))))) (3 wh))) : 
   0 = [PLU -, COUNT (-, @), UB (NO, @), SLASH X2], 
      (lambda (wh) ((lambda (a) (uq 
                  (some (x) (and (ms x) (part x a) (1 x a))))) (3 wh))) : 
   0 = [PLU -, COUNT +, UB (NO, @), SLASH X2], 
      (lambda (wh) ((lambda (a) (uq (some (x) 
                     (and (sg x) (part x a) (1 x a))))) (3 wh))).
IDRULE N2+/PART3B : ; same as N2+/PART3 except WH propagates from non-head -
                    ; how many of the books
   N2[+SPEC, CASE @c, WH +, UB Q, EVER -, PART -, PRO -] --> 
   A2[PART OF, +QUA, AGR N2, WH +, UB Q, EVER -], [PFORM OF], 
   H2[+SPEC, CASE ACC, DEF +, WH NO, UB NO, EVER NO, PRO @p] : 
   0 = [PLU +], (uq (some (x) (and (pl x) (part x 3) (1 x 3)))) : 
   0 = [PLU -], (uq (some (x) (and (ms x) (part x 3) (1 x 3)))).
IDRULE N2+/PART4 : ; partitives without 'of' where the first X2 is a +QUA AP
                   ; - double/half/two-thirds the size, all/half the books.
                   ; Agreement between A2 and H2 is done by proprule
                   ; AGR/NOM. No WH version at all. No extraction (see
                   ; defrule DSLASH12) - *which books do you have half.
   N2[+SPEC, CASE @c, WH NO, UB NO, EVER NO] --> 
   A2[PART NO_OF, AGR N2, +QUA], H2[+SPEC, CASE ACC, DEF +] : 
   0 = [PLU +], (uq (some (x) (and (pl x) (part x 2) (1 x 2)))) : 
   0 = [PLU -, COUNT -], (uq (some (x) (and (ms x) (part x 2) (1 x 2)))) : 
   0 = [PLU -, COUNT (+, @)], (uq (some (x) (and (sg x) (part x 2) (1 x 2)))).
IDRULE N2+/PART5 : ; for partitives with "any" and "one". The NP after "of"
                   ; can be indefinite - "any of several people", "one of
                   ; three books".
   N2[+SPEC, SLASH @sl, WH NO, UB NO, EVER NO, PART -] --> 
   H2[+SPEC, +PRO, PART OF2, SLASH NOSLASH], [PFORM OF], 
   N2[+SPEC, CASE ACC, PLU +, SLASH @sl] : 
   0 = [SLASH NOSLASH], 1 = [PLU +], (uq 
         (some (x) (and (pl x) (part x 3) (1 x 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU -], 
      (uq (some (x) (and (sg x) (part x 3) (1 x 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU @], 
      (uq (some (x) (and (part x 3) (1 x 3)))) : 
   0 = [SLASH X2], 1 = [PLU +], (lambda (wh) 
         ((lambda (a) (uq (some (x) (and (pl x) (part x a) (1 x a))))) 
            (3 wh))) : 
   0 = [SLASH X2], 1 = [PLU -], (lambda (wh) ((lambda (a) (uq 
                  (some (x) (and (sg x) (part x a) (1 x a))))) (3 wh))) : 
   0 = [SLASH X2], 1 = [PLU @], 
      (lambda (wh) ((lambda (a) (uq (some (x) (and (part x a) (1 x a))))) 
            (3 wh))).
IDRULE N2+/PART5B : ; wh version of N2+/PART5 - "any of whose books".
   N2[+SPEC, +R, +WH, -EVER, PART -] --> 
   H2[+SPEC, +PRO, PART OF2, WH NO, UB NO, EVER NO], [PFORM OF], 
   N2[+SPEC, CASE ACC, PLU +, +R, +WH, -EVER] : 
   1 = [PLU +], (lambda (_wh) ((lambda (a) 
               (uq (some (x) (and (pl x) (part x a) (1 x a))))) (3 _wh))) : 
   1 = [PLU -], 
      (lambda (_wh) ((lambda (a) (uq (some (x) (and (sg x) (part x a) 
                        (1 x a))))) (3 _wh))).
IDRULE N2+/PART6 : ; partitives with 'of' where the X2 which precedes 'of'
                   ; is non-pronominal - a litre of milk, three lbs of
                   ; flour. No agreement between H2 and N2. The -DEF, -COUNT
                   ; restriction on the non-head might be too restrictive -
                   ; it may be that some kind of agreement between the two
                   ; NPs is needed.
   N2[+SPEC, SLASH @sl, PART -, AFORM @a] --> 
   H2[+SPEC, PART OF, SLASH NOSLASH, AFORM @a], [PFORM OF], 
   N2[+SPEC, CASE ACC, DEF -, COUNT -, SLASH @sl, KIND -] : 
   0 = [SLASH NOSLASH], 1 = [PLU +], 
      (uq (some (x) (and (pl x) (QUANTITY x 1 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU -], 
      (uq (some (x) (and (sg x) (QUANTITY x 1 3)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU @], (uq (some (x) (QUANTITY x 1 3))) : 
   0 = [SLASH X2], 1 = [PLU +], 
      (lambda (wh) (uq (some (x) (and (pl x) (QUANTITY x (1 wh) 3))))) : 
   0 = [SLASH X2], 1 = [PLU -], 
      (lambda (wh) (uq (some (x) (and (sg x) (QUANTITY x (1 wh) 3))))) : 
   0 = [SLASH X2], 1 = [PLU @], 
      (lambda (wh) (uq (some (x) (QUANTITY x (1 wh) 3)))).
IDRULE N2+/PART6B : ; like N2+/PART6 except no 'of'.
   N2[+SPEC, SLASH @sl, PART -] --> H2[+SPEC, PART NO_OF, SLASH NOSLASH], 
   N2[+SPEC, CASE ACC, DEF -, COUNT -, SLASH @sl] : 
   0 = [SLASH NOSLASH], 1 = [PLU +], 
      (uq (some (x) (and (pl x) (QUANTITY x 1 2)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU -], 
      (uq (some (x) (and (sg x) (QUANTITY x 1 2)))) : 
   0 = [SLASH NOSLASH], 1 = [PLU @], (uq (some (x) (QUANTITY x 1 2))) : 
   0 = [SLASH X2], 1 = [PLU +], 
      (lambda (wh) (uq (some (x) (and (pl x) (QUANTITY x (1 wh) 2))))) : 
   0 = [SLASH X2], 1 = [PLU -], 
      (lambda (wh) (uq (some (x) (and (sg x) (QUANTITY x (1 wh) 2))))) : 
   0 = [SLASH X2], 1 = [PLU @], 
      (lambda (wh) (uq (some (x) (QUANTITY x (1 wh) 2)))).
IDRULE N2+/ADJ1 : ; the stupid, the very stupid, the extremely stupid
   N2[+SPEC, PLU +, COUNT +, SLASH NOSLASH, PER 3, NFORM NORM] --> 
   DetN[DEF +, WH NO, UB NO, EVER NO, AGR N2[+PLU, +COUNT, QFEAT -]], 
   A2[AFORM NONE, SLASH NOSLASH, DISTR ATT, AGR N2[NFORM NORM]] : 
   (1 (lambda (x) (and (human x) (2 x)))).
IDRULE N2+/ADJ2 : ; the most stupid, the poorest (either sing or plural)
   N2[+SPEC, COUNT +, PLU @pl, SLASH NOSLASH, PER 3, NFORM NORM] --> 
   DetN[DEF +, WH NO, UB NO, EVER NO, AGR N2[QFEAT -, COUNT +, PLU @pl]], 
   A2[AFORM EST, SLASH NOSLASH, DISTR ATT, AGR N2[NFORM NORM]] : 
   (1 (lambda (x) (and (entity x) (2 x)))).
IDRULE N2+/ADJ3 : ; the more stupid, the cleverer (either sing or plural)
   N2[+SPEC, COUNT +, PLU @pl, SLASH NOSLASH, PER 3, NFORM NORM] --> 
   DetN[DEF +, WH NO, UB NO, EVER NO, AGR N2[QFEAT -, COUNT +, PLU @pl]], 
   A2[AFORM ER, SLASH NOSLASH, DISTR ATT, AGR N2[NFORM NORM]] : 
   (1 (lambda (x) (and (entity x) (2 x)))).
IDRULE N2+/ADJ4 : ; ordinals occurring without a head noun. "the first", "a
                  ; fourth".
   N2[+SPEC, PLU -, COUNT +, SLASH NOSLASH, PER 3, NFORM NORM, ADV -] --> 
   
   DetN[DEF @d, WH NO, UB NO, EVER NO, DEMON -, AGR N2[QFEAT -, PLU -, COUNT 
         +]], A2[NUM ORD, AFORM NONE, SLASH NOSLASH] : 
   (1 (lambda (x) (and (entity x) (2 x)))).
IDRULE N2+/FREEREL : ; whichever you like e, whatever book you like e
   N2[+SPEC, WH NO, UB NO, EVER NO, -PRO, -PRD] --> 
   N2[H +, +SPEC, +WH, +EVER, +R, PRO @p], S[COMP NORM, SLASH N2, -INV] : 
   (1 (lambda (x) 
            (2 (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe ((equa 
                                    some) (e1) (ta e1))) x))))))).
IDRULE N2+/FREEREL2 : ; whichever seems right
   N2[+SPEC, WH NO, UB NO, EVER NO, -PRO, -PRD] --> 
   N2[H +, +SPEC, +WH, +EVER, +R, PRO @p, PRD -], VP[+FIN, AGR N2, PRO -] : 
   2 = [PAST -], 
      (1 (lambda (x) (2 (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                           (uqe ((equa some) (e1) (PRES (ta e1)))) x))))))) : 
   2 = [PAST +], 
      (1 (lambda (x) (2 (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                           (uqe ((equa some) (e1) (PAST (ta e1)))) x))))))) : 
   2 = [PAST FUT], 
      (1 (lambda (x) (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (FUT (ta e1)))) x))))))).
IDRULE N2+/COMPAR1 : ; more bones than fido, as many bones as fido. The
                     ; interpretation is one where the object of "than" is
                     ; the subject of an unknown predicate PROPRED which
                     ; also has "bones" as an argument. This means that this
                     ; is only appropriate as an accusative NP as in "Rover
                     ; eats more bones than Fido" with the interpretation
                     ; that the number of bones that Rover eats exceeds the
                     ; number of bones that Fido "PROPREDS". (To get the
                     ; semantic content of the matrix verb down into the
                     ; semantics of the "than" PP would be too hard.)
   N2[+SPEC, +ACC] --> H2[SPEC -, AFORM @a, QFEAT +, KIND -, PRD -], 
   P2[PFORM @a, PRD -] : 
   1 = [PLU +, SLASH NOSLASH], (1 (lambda (co) (lambda (exp) 
               (exp pl (lambda (qua) 
                     (lambda (N) (uq (((qua co) (lambda (c) (and (N c) 
                                       (PROPRED 
                                          (uqe (some (e1) (NOTENSE e1))) 
                                          (2 (lambda (prep) (lambda (y) y))) 
                                          c)))) (x) (N x))))))))) : 
   1 = [PLU -, SLASH NOSLASH], 
      (1 (lambda (co) (lambda (exp) (exp ms (lambda (qua) 
                     (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (PROPRED 
                                          (uqe (some (e1) (NOTENSE e1))) 
                                          (2 (lambda (prep) (lambda (y) y))) 
                                          c)))) (x) (N x))))))))) : 
   1 = [PLU +, SLASH X2], 
      (lambda (wh) (1 (lambda (co) (lambda (exp) (exp wh pl 
                     (lambda (qua) (lambda (N) 
                           (uq (((qua co) (lambda (c) (and (N c) 
                                          (PROPRED (uqe 
                                                (some (e1) (NOTENSE e1))) 
                                             (2 (lambda (prep) 
                                                   (lambda (y) y))) c)))) (x) 
                                 (N x)))))))))) : 
   1 = [PLU -, SLASH X2], (lambda (wh) 
         (1 (lambda (co) (lambda (exp) (exp wh ms 
                     (lambda (qua) (lambda (N) (uq 
                              (((qua co) (lambda (c) (and (N c) 
                                          (PROPRED (uqe (some (e1) 
                                                   (NOTENSE e1))) 
                                             (2 (lambda (prep) 
                                                   (lambda (y) y))) c)))) (x) 
                                 (N x)))))))))).
IDRULE N2+/COMPAR2 : ; more abbots than abbeys, as many doubts as anxieties.
   N2[+SPEC, SLASH NOSLASH] --> H2[SPEC -, AFORM @a, QFEAT +, KIND -, PRD -], 
   P2[PFORM @a, PRD -, SLASH +QUA[ADV -]] : 
   1 = [PLU +], (1 (lambda (co) (lambda (exp) 
               (exp pl (lambda (qua) (lambda (N) 
                        (uq (((qua co) (lambda (c) (2 
                                       (lambda (prep) (lambda (np) np)) c))) 
                              (x) (N x))))))))) : 
   1 = [PLU -], (1 (lambda (co) 
            (lambda (exp) (exp ms (lambda (qua) (lambda (N) 
                        (uq (((qua co) (lambda (c) 
                                    (2 (lambda (prep) (lambda (np) np)) c))) 
                              (x) (N x))))))))).
IDRULE N2+/COMPAR3 : ; more bones than fido eats, many bones as fido eats
   N2[+SPEC] --> H2[SPEC -, AFORM @a, QFEAT +, KIND -, PRD -], 
   S[COMP @a, SLASH N2] : 
   1 = [PLU +], (1 (lambda (co) (lambda (exp) (exp pl (lambda (qua) 
                     (lambda (N) 
                        (uq (((qua co) (lambda (c) (and (N c) (2 c)))) (x) 
                              (N x))))))))) : 
   1 = [PLU -], (1 (lambda (co) (lambda (exp) 
               (exp ms (lambda (qua) (lambda (N) 
                        (uq (((qua co) (lambda (c) (and (N c) (2 c)))) (x) 
                              (N x))))))))).
IDRULE N2+/COMPAR4 : ; more abbots than you'd think, as many abbots as he
                     ; had supposed -- the SLASH V2 introduced here is
                     ; terminated by means of metarules STM3a and STM3b (the
                     ; [SLASH S] conditions). It can also be terminated as a
                     ; +PRO VP by idrule VP/PRO/SLASH (the [SLASH VP]
                     ; conditions) to allow examples such as "more abbots
                     ; than kim will" "as many abbots as kim can"
   N2[+SPEC] --> H2[SPEC -, AFORM @a, QFEAT +, KIND -, PRD -], 
   S[COMP @a, SLASH V2] : 
   1 = [PLU +], 2 = [SLASH S], (1 (lambda (co) (lambda (exp) 
               (exp pl (lambda (qua) 
                     (lambda (N) (uq (((qua co) (lambda (c) (and (N c) 
                                       (2 ((lambda (c2) 
                                                (PROPRED (uqe (some (e) 
                                                         (NOTENSE e))) c2)) 
                                             c))))) (x) (N x))))))))) : 
   1 = [PLU -], 2 = [SLASH S], 
      (1 (lambda (co) (lambda (exp) (exp ms (lambda (qua) 
                     (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (2 ((lambda (c2) 
                                                (PROPRED 
                                                   (uqe (some (e) (NOTENSE 
                                                            e))) c2)) c))))) 
                              (x) (N x))))))))) : 
   1 = [PLU +], 2 = [SLASH VP], 
      (1 (lambda (co) (lambda (exp) (exp pl (lambda (qua) 
                     (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (2 (lambda (prop) 
                                             (lambda (ta) 
                                                (lambda (equa) (prop 
                                                      (uqe ((equa some) (e) 
                                                            (ta e))) 
                                                      (lambda (e1) 
                                                         (lambda (x1) 
                                                            ((lambda (y1) 
                                                                  (PROVP e1 
                                                                     x1 y1)) 
                                                               c))))))))))) 
                              (x) (N x))))))))) : 
   1 = [PLU -], 2 = [SLASH VP], 
      (1 (lambda (co) (lambda (exp) (exp ms (lambda (qua) 
                     (lambda (N) (uq (((qua co) 
                                 (lambda (c) (and (N c) (2 (lambda (prop) 
                                             (lambda (ta) 
                                                (lambda (equa) (prop 
                                                      (uqe ((equa some) (e) 
                                                            (ta e))) 
                                                      (lambda (e1) 
                                                         (lambda (x1) 
                                                            ((lambda (y1) 
                                                                  (PROVP e1 
                                                                     x1 y1)) 
                                                               c))))))))))) 
                              (x) (N x))))))))).
IDRULE N2+/COMPAR5 : ; more bones than fido eats biscuits, as many bones as
                     ; fido eats biscuits.
   N2[+SPEC] --> H2[SPEC -, AFORM @a, QFEAT +, KIND -, PRD -], 
   S[COMP @a, SLASH +QUA[ADV -]] : 
   1 = [PLU +], (1 (lambda (co) (lambda (exp) (exp pl 
                  (lambda (qua) (lambda (N) 
                        (uq (((qua co) 2) (x) (N x))))))))) : 
   1 = [PLU -], (1 (lambda (co) 
            (lambda (exp) (exp ms (lambda (qua) (lambda (N) 
                        (uq (((qua co) 2) (x) (N x))))))))).
IDRULE N2+/COMPAR6 : ; rather than use a metarule, this terminates the
                     ; [SLASH [QUA +]] introduced by idrules N2+/COMPAR2 and
                     ; N2+/COMPAR5. Notice that no empty node is introduced.
                     ; The binding of values for PLU and COUNT on the
                     ; daughter make sure that only plural (PLU +, COUNT +)
                     ; or mass (PLU -, COUNT -) nouns will match (*kim eats
                     ; more apples than orange).
   N2[SLASH [QUA +, ADV -, PRD -], +SPEC, WH NO, UB NO, EVER NO] --> 
   H1[SLASH NOSLASH, PRO -, PLU @pc, COUNT @pc] : 
   1 = [PLU +], (lambda (x) (and (pl x) (1 x))) : 
   1 = [PLU -], (lambda (x) (and (ms x) (1 x))).
IDRULE N2/POSSa : ; Possessive NP which will act as a determiner - "the dog
                  ; 's (bone)", "the dogs ' (bone)" etc.
   
   N2[SPEC +, +POSS, WH NO, UB NO, EVER NO, PN @p, SLASH NOSLASH, PLU @pl, 
      DEF @d, PRD -, PART -] --> 
   N2[-POSS, PRO -, SPEC +, PN @p, PLU @pl, SLASH NOSLASH, DEF @d, KIND -, 
      BEGAP -, PRD -], N1[+POSS, COORD -, PN -, PLU @pl, SLASH NOSLASH] : 
   (lambda (x) (lambda (R) (R x 1))).
IDRULE N2/POSSb : ; Possessive NP which will act as a modifier (i.e. "women
                  ; s'" in "the women s' javelin") - the N2[+SPEC] daughter
                  ; has to be plural and have a 'kind' interpretation.
   N2[SPEC -, +POSS, WH NO, UB NO, EVER NO, PN -, SLASH NOSLASH, PLU +] --> 
   
   N2[-POSS, PRO -, SPEC +, PN -, PLU +, DEF -, SLASH NOSLASH, BEGAP -, KIND 
   +], N1[+POSS, COORD -, PN -, PLU +, SLASH NOSLASH] : 1.
IDRULE N2/POSSc : ; Possessive NP acting anaphorically - "fido 's is on the
                  ; table". Since the possessive NP 'stands in' for a full
                  ; NP, we treat it as not really being possessive (ie it is
                  ; -POSS not +POSS). This in combination with a default
                  ; rule to make daughter NPs -POSS will ensure that this
                  ; kind of NP can occur in any normal NP position but that
                  ; the other kind (+POSS) can only occur as a determiner or
                  ; modifier. The sg/pl/ms distinction in the semantics
                  ; can't really be determined without an antecedent
                  ; although sometimes syntactic context disambiguates -
                  ; "the dog 's is ../ the dog 's are ...." Where PLU gets
                  ; instantiated the semantics picks up on it.
   
   N2[SPEC +, -POSS, WH NO, UB NO, EVER NO, SLASH NOSLASH, PN -, PRO -, ADV -, 
      PART -, PRD -] --> 
   N2[-POSS, PRO -, SPEC +, PLU @pl, SLASH NOSLASH, BEGAP -], 
   N1[+POSS, COORD -, PN -, PLU @pl, SLASH NOSLASH] : 
   0 = [PLU +], (dd (the (x) (and (pl x) (lambda (R) (R x 1))))) : 
   0 = [PLU -], (dd (the (x) (and (sg x) (lambda (R) (R x 1))))) : 
   0 = [PLU -], (dd (the (x) (and (ms x) (lambda (R) (R x 1))))) : 
   0 = [PLU @], (dd (the (x) (lambda (R) (R x 1)))).
IDRULE N2+/APPOS : ; an N2 in apposition to a name - "John, my brother" - or
                   ; vice versa - "my brother, John".
   N2[+SPEC, WH NO, UB NO, EVER NO, SLASH NOSLASH, POSS -, ADV -] --> 
   N2[+SPEC, PN +, PRD -, PRO -, +DEF, BEGAP -, SLASH NOSLASH, ADV -], 
   N2[+SPEC, PN -, PRD -, PRO -, +DEF, BEGAP -, SLASH NOSLASH, ADV -] : 
   (dd (the (x) (and (sg x) (equal x 1) (equal x 2)))).
IDRULE N2+/NEG : ; not a dog. +NEG N2s will only appear in coordinate
                 ; structures.
   N2[NEG +, SPEC +, WH NO, UB NO, EVER NO, AFORM @a] --> [NEG +], 
   H2[NEG -, SPEC +, AFORM @a] : 2 = [SLASH NOSLASH, PRD -], (NOT 2) : 
   2 = [SLASH X2, PRD -], (lambda (wh) (NOT (2 wh))) : 
   2 = [SLASH NOSLASH, PRD +], (lambda (x) (NOT (2 x))) : 
   2 = [SLASH X2, PRD +], (lambda (x) (lambda (wh) (NOT (2 x wh)))).
IDRULE N2- : ; simple N2 dominating an N1 head.
   N2[-SPEC, QFEAT -] --> H1 : 1 = [SLASH NOSLASH], (lambda (x) (1 x)) : 
   1 = [SLASH X2], (lambda (x) (lambda (wh) (1 x wh))).
IDRULE N2-/QUA : ; many, too many, three, several dogs. +PRD quantifiers
                 ; attach under N2[-SPEC].
   N2[-SPEC, QFEAT +, AFORM @a] --> 
   A2[+PRD, +QUA, AGR N1, DISTR ATT, AFORM @a], H1 : 
   1 = [AFORM (NONE, EST, @)], 2 = [SLASH NOSLASH], (1 2) : 
   1 = [AFORM (NONE, EST, @)], 2 = [SLASH X2], 
      ((lambda (P1) (lambda (wh) (1 (lambda (x1) (P1 x1 wh))))) 2) : 
   1 = [AFORM ER], 2 = [SLASH NOSLASH], (lambda (Q) (Q than (1 2))) : 
   1 = [AFORM ER], 2 = [SLASH X2], 
      (lambda (Q) (Q than ((lambda (P1) (lambda (wh) 
                     (1 (lambda (x1) (P1 x1 wh))))) 2))) : 
   1 = [AFORM AS], 2 = [SLASH NOSLASH], (lambda (Q) (Q as (1 2))) : 
   1 = [AFORM AS], 2 = [SLASH X2], 
      (lambda (Q) (Q as ((lambda (P1) (lambda (wh) 
                     (1 (lambda (x1) (P1 x1 wh))))) 2))).
IDRULE N2-/QUA2 : ; FOOT features propagate from A2[+QUA] - how many books
   N2[-SPEC, +WH, -EVER, UB Q, QFEAT +] --> 
   A2[+PRD, +QUA, AGR N1, +WH, -EVER, UB Q], H1[WH NO, EVER NO, UB NO] : 
   (1 2).
IDRULE N1/POSS : ; 's, ' , s' (ie possessive morphemes)
   N1[+POSS] --> H[SUBCAT NULL, +POSS].
IDRULE N1/N : ; an N with no complements
   N1 --> H[SUBCAT NULL] : 1.
IDRULE N1/N_PHR : ; a rummage around
   N1 --> H[SUBCAT NULL, PRT @p], [PRT @p] : (CP 1 2).
IDRULE N1/PP : ; picture of kim, discussion about kim
   N1 --> H[SUBCAT PP, PFORM @pf], P2[PFORM @pf, -POSS, PRD +] : 
   2 = [SLASH NOSLASH, UB (Q, NO, @)], (lambda (x) (and (1 x) (2 x))) : 
   2 = [SLASH NOSLASH, UB R], (lambda (z) (lambda (x) (and (1 x) (2 z x)))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) (and (1 x) (2 x wh)))).
IDRULE N1/SFIN : ; fact that fido is a dog
   N1 --> H[SUBCAT SFIN], S[+FIN, that, SLASH NOSLASH] : 
   (lambda (x) (1 x (2 (lambda (prop) 
                  (lambda (ta) (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))))).
IDRULE N1/SBSE : ; requirement that fido dance
   N1 --> H[SUBCAT SBSE], S[that, BSE, SLASH NOSLASH] : 
   (lambda (x) (1 x (2 (lambda (prop) 
                  (lambda (ta) (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))))).
IDRULE N1/VPINF : ; desire to dance
   N1 --> H[SUBCAT VPINF], VP[TO, AGR N2[NFORM NORM], PRO -] : 
   2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           (pro (the (y) (animate y)))))))))) : 
   2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              (pro (the (y) (animate y))) wh)))))))).
IDRULE N1/OFN1 : ; for nouns like "kind, sort, type" which take an "of"
                 ; followed by an N1 ("kind of dog").
   N1[SLASH @sl] --> H[SUBCAT OFN1, PFORM OF], P[PFORM OF], 
   N1[PLU -, SLASH @sl] : (lambda (x) ((CP 1 2) x (kind (all (y) (3 y))))).
IDRULE N1/PRO1 : ; post-modifiable pronoun becomes an N1 (in order to match
                 ; the N1/*MOD* rules). This rule does [PROTYPE COMPOUND]
                 ; ones: "somebody, everyone, no-one, anywhere" etc.
   N1[MOD NONE, PRO +, PROTYPE COMPOUND] --> H[SUBCAT NULL] : 1.
IDRULE N1/PRO2 : ; post-modifiable pronoun becomes an N1. This rule does
                 ; [PROTYPE PMOD] ones: "all, any, either, enough, this,
                 ; those" etc.
   N1[MOD NONE, PRO +, PROTYPE PMOD] --> H[SUBCAT NULL] : 1.
IDRULE N1/PRO3 : ; post-modifiable pronoun becomes an N1. This rule does
                 ; [PROTYPE PMOD+] ones: "many, few, several, three" etc.
                 ; These are the ones which can be preceded by a determiner
                 ; - see idrule N2+/N1PROb.
   N1[MOD NONE, PRO +, PROTYPE PMOD+] --> H[SUBCAT NULL] : 1.
IDRULE N1/PRO4 : ; post-modifiable pronoun becomes an N1. This rule does
                 ; [PROTYPE THAT]: "that". "That" is in a class of its own
                 ; because unlike the other [PROTYPE PMOD] ones it can't be
                 ; followed by all types of relative (* that that kim saw,
                 ; *that kim saw etc).
   N1[MOD NONE, PRO +, PROTYPE THAT] --> H[SUBCAT NULL] : 1.
IDRULE N1/APMOD1 : ; busy man. The -PRD, DISTR ATT restriction on the A2
                   ; prevents adjectives with complements matching. The
                   ; feature MOD on the N1 cuts down on the number of parses
                   ; by making premodifiers attach lower than postmodifiers.
   N1[MOD PRE] --> A2[-PRD, DISTR ATT, -QUA], H1[MOD NONE, PRO -] : 
   2 = [SLASH NOSLASH], (lambda (x) (and (2 x) (1 x))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) (and (2 x wh) (1 x)))).
IDRULE N1/APMOD2 : ; allows for iteration of prenominal AP
   N1[MOD PRE] --> A2[-PRD, DISTR ATT, -QUA], H1[MOD PRE, PRO -] : 
   2 = [SLASH NOSLASH], (lambda (x) (and (2 x) (1 x))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) (and (2 x wh) (1 x)))).
IDRULE N1/POSSMOD1 : ; the women s' javelin, a children s' song.
   N1[MOD PRE] --> N2[POSS +, SPEC -, PN -, PLU +], 
   H1[MOD NONE, PRO -, SLASH NOSLASH] : 
   (lambda (x) (and (lambda (R) (R x 1)) (2 x))).
IDRULE N1/POSSMOD2 : ; allows for iteration as with NP/APMOD1 & 2
   N1[MOD PRE] --> N2[POSS +, SPEC -, PN -, PLU +], 
   H1[MOD PRE, PRO -, SLASH NOSLASH] : 
   (lambda (x) (and (lambda (R) (R x 1)) (2 x))).
IDRULE N1/POST_APMOD1 : ; post-nominal AP - a man taller than lee, *a man
                        ; stupid - only adjs with complements (DISTR PRD) or
                        ; comparatives can match
   N1[MOD POST] --> H1, A2[+PRD, DISTR PRD, -QUA, AGR N2] : 
   0 = [PRO (-, @), SLASH NOSLASH], (lambda (x) (and (1 x) (2 x))) : 
   0 = [PRO (-, @), SLASH X2], 
      (lambda (x) (lambda (wh) (and (1 x wh) (2 x)))) : 
   0 = [PRO +, SLASH NOSLASH, PROTYPE NONE], 
      (lambda (Q1) (1 (lambda (qua) (lambda (exp) 
                  (Q1 qua (lambda (x1) (and (exp x1) (2 x1)))))))) : 
   0 = [PRO +, PRD -, SLASH NOSLASH, PROTYPE (COMPOUND, PMOD+, PMOD)], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) (and (exp y) (2 y))))))))) : 
   0 = [PRO +, PRD +, SLASH NOSLASH, PROTYPE (COMPOUND, PMOD+, PMOD)], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant (lambda (y) (and (exp y) (2 y))) 
                           prep))))))).
IDRULE N1/POST_APMOD2 : ; special rule to allow simple APs to post-modify
                        ; [PROTYPE COMPOUND] pronouns: "someone stupid",
                        ; "nowhere special" etc.
   N1[MOD POST] --> H1[PRO +, PROTYPE COMPOUND, MOD NONE], 
   A2[-PRD, DISTR ATT, -QUA] : 
   1 = [PRD -], (1 (lambda (type) (lambda (quant) (lambda (exp) 
                  (lambda (Q2) (Q2 type quant 
                        (lambda (y) (and (exp y) (2 y))))))))) : 
   1 = [PRD +], (1 
         (lambda (type) (lambda (quant) (lambda (exp) (lambda (prep) 
                     (lambda (Q2) 
                        (Q2 type quant (lambda (y) (and (exp y) (2 y))) 
                           prep))))))).
IDRULE N1/PPMOD : ; man with the umbrella, a book of fidos
   N1[MOD POST] --> H1, P2[-GER, PFORM NORM, PRD +, MODTYPE NML, PRO -] : 
   0 = [PRO (-, @), SLASH NOSLASH], (lambda (x) (and (1 x) (2 x))) : 
   0 = [PRO (-, @), SLASH X2], 
      (lambda (x) (lambda (wh) (and (1 x wh) (2 x)))) : 
   0 = [PRO +, SLASH NOSLASH, PROTYPE NONE], 
      (lambda (Q1) (1 (lambda (qua) (lambda (exp) 
                  (Q1 qua (lambda (x1) (and (exp x1) (2 x1)))))))) : 
   0 = [PRO +, PRD -, SLASH NOSLASH, PROTYPE (COMPOUND, PMOD+, PMOD)], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) (and (exp y) (2 y))))))))) : 
   0 = [PRO +, PRD +, SLASH NOSLASH, PROTYPE (COMPOUND, PMOD+, PMOD)], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant (lambda (y) (and (exp y) (2 y))) 
                           prep))))))).
IDRULE N1/INFMOD : ; the man to ask e
   N1[MOD POST, SLASH NOSLASH] --> H1[SLASH NOSLASH, PN -], 
   VP[TO, SLASH N2[+ACC], AGR N2[NFORM NORM]] : 
   1 = [PRO (-, @)], (lambda (x) (and (1 x) 
            (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           (pro (the (z) (entity z))) x))))))) : 
   1 = [PRO +, PROTYPE NONE], 
      (lambda (Q1) (1 (lambda (qua) (lambda (exp) (Q1 qua 
                     (lambda (x1) (and (exp x1) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e1) 
                                                (NOTENSE (ta e1)))) 
                                          (pro (the (z) (entity z))) 
                                          x1)))))))))))) : 
   1 = [PRO +, PRD -, PROTYPE (COMPOUND, PMOD+, PMOD)], 
      (1 (lambda (type) (lambda (quant) 
               (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) (and (exp y) 
                              (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) (prop 
                                             (uqe ((equa some) (e1) 
                                                   (NOTENSE (ta e1)))) 
                                             (pro (the (z) (entity z))) 
                                             y))))))))))))).
IDRULE N1/VPMOD1 : ; abbot helping lee, someone helping lee.
   N1[MOD POST] --> H1, VP[PRD +, VFORM ING, FIN -, AGR N2[NFORM NORM]] : 
   1 = [PRO (-, @), SLASH NOSLASH], 
      (lambda (x) (and (1 x) (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop 
                           (uqe ((equa some) (e1) (NOTENSE (PROG (ta e1))))) 
                           x))))))) : 
   1 = [PRO (-, @), SLASH X2], (lambda (x) (lambda (wh) 
            (and (1 x wh) (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe 
                                 ((equa some) (e1) (NOTENSE (PROG (ta e1))))) 
                              x)))))))) : 
   1 = [PRO +, PRD -, PROTYPE (COMPOUND, PMOD+, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) 
                           (and (exp y) (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          (prop (uqe ((equa some) (e1) 
                                                   (NOTENSE (PROG (ta e1))))) 
                                             y))))))))))))) : 
   1 = [PRO +, PRD +, PROTYPE (COMPOUND, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant 
                           (lambda (y) (and (exp y) (2 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) (prop (uqe 
                                                      ((equa some) (e1) 
                                                      (NOTENSE 
                                                         (PROG (ta e1))))) 
                                                y))))))) prep))))))).
IDRULE N1/VPMOD2 : ; abbot abandoned by kim, someone abandoned by kim.
   N1[MOD POST] --> H1, VP[PRD +, VFORM EN, FIN -, AGR N2[NFORM NORM]] : 
   1 = [PRO (-, @), SLASH NOSLASH], 
      (lambda (x) (and (1 x) (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop 
                           (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           x))))))) : 
   1 = [PRO (-, @), SLASH X2], (lambda (x) (lambda (wh) 
            (and (1 x wh) (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe 
                                 ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x)))))))) : 
   1 = [PRO +, PRD -, PROTYPE (COMPOUND, PMOD+, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) 
                           (and (exp y) (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          (prop (uqe ((equa some) (e1) 
                                                   (NOTENSE (ta e1)))) 
                                             y))))))))))))) : 
   1 = [PRO +, PRD +, PROTYPE (COMPOUND, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant 
                           (lambda (y) (and (exp y) (2 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) (prop (uqe 
                                                      ((equa some) (e1) 
                                                      (NOTENSE (ta e1)))) 
                                                y))))))) prep))))))).
IDRULE N1/VPMOD3 : ; person to help kim, someone to help kim.
   N1[MOD POST] --> H1, VP[VFORM TO, FIN -, AGR N2[NFORM NORM]] : 
   1 = [PRO (-, @), SLASH NOSLASH], 
      (lambda (x) (and (1 x) (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop 
                           (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           x))))))) : 
   1 = [PRO (-, @), SLASH X2], (lambda (x) (lambda (wh) 
            (and (1 x wh) (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe 
                                 ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x)))))))) : 
   1 = [PRO +, PRD -, PROTYPE (COMPOUND, PMOD+, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) 
                           (and (exp y) (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          (prop (uqe ((equa some) (e1) 
                                                   (NOTENSE (ta e1)))) 
                                             y))))))))))))) : 
   1 = [PRO +, PRD +, PROTYPE (COMPOUND, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant 
                           (lambda (y) (and (exp y) (2 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) (prop (uqe 
                                                      ((equa some) (e1) 
                                                      (NOTENSE (ta e1)))) 
                                                y))))))) prep))))))).
IDRULE N1/RELMOD1 : ; sheep who/that attacks fido, sheep who/that fido
                    ; attacks. The N1 defaults to [DEMON -] so a separate
                    ; rule is needed for demonstrative pronouns.
   N1[MOD POST] --> H1[WH NO, UB NO, EVER NO], S[+R, -EVER, WH @wh] : 
   1 = [PRO (-, @), SLASH NOSLASH], 
      (lambda (x) (and (1 x) (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e1) (ta e1))) 
                           x))))))) : 
   1 = [PRO (-, @), SLASH X2], (lambda (x) (lambda (wh) 
            (and (1 x wh) (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe 
                                 ((equa some) (e1) (ta e1))) x)))))))) : 
   1 = [PRO +, PRD -, PROTYPE (COMPOUND, PMOD+, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) 
                           (and (exp y) (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          (prop (uqe ((equa some) (e1) 
                                                   (ta e1))) y))))))))))))) : 
   1 = [PRO +, PRD +, PROTYPE (COMPOUND, PMOD), SLASH NOSLASH], 
      (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (prep) (lambda (Q2) 
                        (Q2 type quant 
                           (lambda (y) (and (exp y) (2 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) (prop (uqe 
                                                      ((equa some) (e1) 
                                                      (ta e1))) y))))))) 
                           prep))))))).
IDRULE N1/RELMOD2 : ; demonstrative pronouns can be postmodified by a
                    ; relative clause (except "that" places restrictions).
                    ; This rule picks out all demonstrative post-modifiable
                    ; pronouns ([DEMON +, PROTYPE PMOD]) but excludes "that"
                    ; (PROTYPE THAT).
   N1[PRO +, MOD POST, DEMON +, PROTYPE PMOD, SLASH NOSLASH] --> 
   H1[WH NO, UB NO, EVER NO], S[+R, -EVER, WH @wh] : 
   1 = [PRD -], (1 (lambda (type) 
            (lambda (quant) (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) 
                           (and (exp y) (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          (prop (uqe ((equa some) (e1) 
                                                   (ta e1))) y))))))))))))) : 
   1 = [PRD +], 
      (1 (lambda (type) (lambda (quant) (lambda (exp) (lambda (prep) 
                     (lambda (Q2) 
                        (Q2 type quant (lambda (y) (and (exp y) (2 (lambda 
                                       (prop) 
                                       (lambda (ta) (lambda (equa) (prop 
                                                (uqe ((equa some) (e1) 
                                                      (ta e1))) y))))))) 
                           prep))))))).
IDRULE N1/RELMOD3 : ; relative clause modifies "that" - "that which kim
                    ; abandoned". The relative clause has to be [WH +].
   N1[PRO +, MOD POST, DEMON +, PROTYPE THAT, SLASH NOSLASH] --> 
   H1[WH NO, UB NO, EVER NO], S[+R, -EVER, WH +] : 
   (1 (lambda (type) (lambda (quant) 
               (lambda (exp) (lambda (Q2) (Q2 type quant 
                        (lambda (y) (and (exp y) 
                              (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) (prop 
                                             (uqe ((equa some) (e1) (ta e1))) 
                                             y))))))))))))).
IDRULE N1/PN : ; for interpreting names as if they were common nouns ("this
               ; lee", "the kim I know").
   
   N1[PN -, PRD -, COUNT +, PLU @pl, PRO -, WH NO, UB NO, EVER NO, SLASH 
         NOSLASH, NFORM NORM, PER 3, DEF +, PART -] --> 
   N[PN @pn, ADDRESS -, PLU @pl, SUBCAT NULL] : (lambda (x) (equal x 1)).
IDRULE N/NUMBER1 : ; A2[NUM CARD] (i.e cardinal numbers) can be pronouns
                   ; (postmodifiable and able to occur with a determiner -
                   ; [PROTYPE PMOD+] - "three", "nearly three" "three which
                   ; were broken" "the three which were broken").
   
   N[-POSS, -DEF, PLU @pl, +PRO, +COUNT, -PRD, CARD, NFORM NORM, PER 3, PN -, 
      AFORM NONE, SUBCAT NULL, WH NO, UB NO, EVER NO, PROTYPE PMOD+] --> 
   A2[PRD +, ADV -, PART -, QUA +, NUM CARD, AGR [N +, V -, PLU @pl], 
      SLASH NOSLASH] : 
   0 = [PLU +], (lambda (Q) (Q uq (1 P Q (lambda (qua) (lambda (exp) qua))) 
            (lambda (x) (and (pl x) (entity x))))) : 
   0 = [PLU -], (lambda (Q) (Q uq (1 P Q (lambda (qua) (lambda (exp) qua))) 
            (lambda (x) (and (sg x) (entity x))))).
IDRULE N/NUMBER2 : ; A2[NUM CARD] (i.e. cardinal numbers) can be [SUBCAT
                   ; NULL, PART OF] pronouns in partitives e.g. "three of
                   ; the books".
   
   N[-POSS, -DEF, PLU @pl, +PRO, +COUNT, CARD, NFORM NORM, PER 3, PN -, PART 
         OF, AFORM NONE, SUBCAT NULL, WH NO, UB NO, EVER NO] --> 
   A2[PRD +, ADV -, PART -, QUA +, NUM CARD, AGR [N +, V -, PLU @pl], 
      SLASH NOSLASH] : (1 P Q (lambda (qua) (lambda (exp) qua))).
IDRULE N/COMPOUND1 : ; bank account
   N[PN -] --> N[SUBCAT NULL, COORD -, NUM -, PN -, POSS -, PART -, PLU -], 
   H[SUBCAT NULL, COORD -] : (compound 1 2).
IDRULE N/COMPOUND2 : ; cold drink. NB The inclusion of rules N/COMPOUND2,
                     ; N/COMPOUND3 and A/COMPOUND can lead to a lot of
                     ; spurious ambiguity. It may be better to comment them
                     ; out.
   N[PN -] --> 
   A[SUBCAT NULL, COORD -, NUM -, QUA -, ADV -, DISTR ATT, AFORM NONE], 
   H[SUBCAT NULL, COORD -] : (compound 1 2).
IDRULE N/COMPOUND3 : ; after care, through road. NB The inclusion of rules
                     ; N/COMPOUND2, N/COMPOUND3 and A/COMPOUND can lead to a
                     ; lot of spurious ambiguity. It may be better to
                     ; comment them out.
   N[SUBCAT NULL, PN -] --> P[SUBCAT NP, PFORM NORM, PRO -, COORD -], 
   H[SUBCAT NULL, COORD -] : (compound 1 2).
IDRULE N/FRACTION : ; a fraction can be a pronoun (with a partitive
                    ; meaning). NB this doesn't allow for premodification -
                    ; almost two thirds.
   
   N[-POSS, -DEF, +PRO, -PRD, NFORM NORM, PER 3, PN -, NUM -, AFORM NONE, 
      SUBCAT NULL, WH NO, UB NO, EVER NO, PROTYPE PMOD+] --> 
   [FRACT +, PLU @p] : 
   (lambda (Q) (Q uq some ((lambda (y) (lambda (x) (and (part x y) 
                        (proportion x y (NN 1))))) 
               (uq (some (x2) (entity x2)))))).
\end{verbatim}
{\bf ; AP rules}
\begin{verbatim}
IDRULE A2/ADVMOD1 : ; exceptionally clever, nearly all.
   A2 --> ( A2[+ADV, -PRD, -QUA] ), H1 : 0 = [GRADE -, ADV +], 2 : 
   0 = [GRADE -, ADV -, QUA -], (lambda (x) (2 x)) : 
   0 = [GRADE -, ADV -, QUA +, PRD +, PART (-, @)], 2 : 
   0 = [GRADE -, ADV -, QUA +, PRD -, PART (-, @)], 
      (2 (lambda (qua) (lambda (exp) 
               (lambda (P) (uq (qua (x) (exp x P))))))) : 
   0 = [GRADE -, ADV -, QUA +, PART (OF, NO_OF)], 
      (lambda (x) (lambda (y) (proportion x y 2))) : 
   0 = [GRADE -, ADV +], (1 2) : 
   0 = [GRADE -, ADV -, QUA -], (lambda (x) (and (2 x) (degree 1))) : 
   0 = [GRADE -, ADV -, QUA +, PRD +, PART (-, @)], 
      (lambda (P) (lambda (Q) (lambda (T) 
               (2 P Q (lambda (qua) (lambda (exp) (T (1 qua) exp))))))) : 
   0 = [GRADE -, ADV -, QUA +, PRD -, PART (-, @)], 
      (2 (lambda (qua) (lambda (exp) 
               (lambda (P) (uq ((1 qua) (x) (exp x P))))))) : 
   0 = [GRADE -, ADV -, QUA +, PART (OF, NO_OF)], 
      (lambda (x) (lambda (y) (proportion x y (1 2)))) : 
   0 = [GRADE +, ADV +, QUA -, AFORM EST], (2 degree) : 
   0 = [GRADE +, ADV +, QUA -, AFORM NONE], 2 : 
   0 = [GRADE +, ADV +, QUA -, AFORM (ER, AS)], 
      (2 (lambda (dword) (degree (dword 
                  (lambda (d) ((lambda (e) (and (PROPRED e) 
                              (2 (lambda (dword2) (degree d)) e))) 
                        (uqe (some (e2) (NOTENSE e2))))))))) : 
   0 = [GRADE +, ADV +, QUA +, AFORM (EST, NONE)], 2 : 
   0 = [GRADE +, ADV +, QUA +, AFORM (ER, AS)], 
      (2 (lambda (dword) (degree (dword 
                  (lambda (d) (PROPRED (uqe ((2 (lambda (dword2) (degree d))) 
                              (e) (NOTENSE e))))))))) : 
   0 = [GRADE +, ADV -, QUA -, AFORM (EST, NONE)], 
      (lambda (x) (2 (lambda (dword) (degree dword)) x)) : 
   0 = [GRADE +, ADV -, QUA -, AFORM (ER, AS)], 
      (lambda (x) (2 (lambda (dword) 
               (degree (dword (lambda (d) (BE (uqe (some (e) (NOTENSE e))) 
                           (2 (lambda (dword) (degree d)) 
                              (pro (the (z1) (entity z1))))))))) x)) : 
   0 = [GRADE +, ADV -, QUA +, PRD +, PART (-, @)], 2 : 
   0 = [GRADE +, ADV -, QUA +, PART (OF, NO_OF)], 
      (lambda (x) (lambda (y) (proportion x y 2))) : 
   0 = [GRADE +, ADV +, QUA -, AFORM (EST, NONE)], 
      (2 (lambda (dword) (degree 1))) : 
   0 = [GRADE +, ADV +, QUA +, AFORM (EST, NONE)], 
      (2 (lambda (dword) (degree 1))) : 
   0 = [GRADE +, ADV -, QUA -, AFORM (EST, NONE)], 
      (lambda (x) (2 (lambda (dword) (degree 1)) x)) : 
   0 = [GRADE +, ADV -, QUA +, PRD +, PART (-, @)], 
      (lambda (P) (lambda (Q) (lambda (T) 
               (2 P Q (lambda (qua) (lambda (exp) (T (1 qua) exp))))))) : 
   0 = [GRADE +, ADV -, QUA +, PART (OF, NO_OF)], 
      (lambda (x) (lambda (y) (proportion x y (1 2)))).
IDRULE A2/ADVMOD2 : ; how exceptionally clever. FOOT features propagate from
                    ; ADVP.
   A2[+WH, EVER @ev, UB Q] --> A2[+ADV, -PRD, -QUA, +WH, EVER @ev, UB Q], 
   H1[WH NO, EVER NO, UB NO] : (lambda (x) (and (2 x) (degree 1))).
IDRULE A2/NOT : ; not all, not many. Restricted to quantifying adjectives at
                ; the moment because of *a not clever man. The head must be
                ; -NEG (*not few).
   A2[+QUA, WH NO, UB NO, EVER NO, NUM -] --> [NEG +], H1[-NEG] : 
   0 = [PRD -, PART (-, @)], 
      (2 (lambda (qua) (lambda (exp) (lambda (P) (uq ((NOT qua) (x) 
                        (exp x P))))))) : 
   0 = [PRD +, PART (-, @)], (lambda (P) 
         (lambda (Q) (lambda (T) (2 P Q (lambda (qua) 
                     (lambda (exp) (T (NOT qua) exp))))))) : 
   0 = [PART (OF, NO_OF)], 
      (lambda (x) (lambda (y) (proportion x y (NOT 2)))) : 0 = [ADV +], (1 2).
IDRULE A2/NEG : ; not happy. This kind of +NEG A2 will only appear in
                ; coordinate structures eg fido is happy but not clever
   A2[NEG +] --> [NEG +], H2[NEG -] : 
   2 = [SLASH NOSLASH], (lambda (x) (NOT (2 x))) : 
   2 = [SLASH X2], (lambda (x) (lambda (wh) (NOT (2 x wh)))).
IDRULE A2/COMPAR1 : ; taller than lee, more stupid than lee.
   A2[+PRD, DISTR PRD] --> H1[AFORM @a, DISTR @x], P2[PFORM @a, PRD -] : 
   1 = [ADV -], 
      (1 (lambda (dword) (degree (dword (lambda (d) (BE (uqe (some (e) 
                              (NOTENSE e))) 
                        (1 (lambda (dword2) (degree d)) (2 
                              (lambda (prep) (lambda (np) np)))))))))) : 
   1 = [ADV +, QUA -], 
      (1 (lambda (dword) (degree (dword (lambda (d) ((lambda (e) 
                           (and (PROPRED e 
                                 (2 (lambda (prep) (lambda (np) np)))) 
                              (1 (lambda (dword2) (degree d)) e))) 
                        (uqe (some (e) (NOTENSE e))))))))) : 
   1 = [ADV +, QUA +], 
      (1 (lambda (dword) (degree (dword (lambda (d) (PROPRED (uqe 
                           ((1 (lambda (dword2) (degree d))) (e) 
                              (NOTENSE e))) 
                        (2 (lambda (prep) (lambda (np) np))))))))).
IDRULE A2/COMPAR2 : ; more stupid than happy, as crazy as eager
   A2[+PRD] --> H1[QUA -, AFORM @a, ADV @ad], 
   A2[QUA -, PFORM @a, ADV @ad, SLASH +QUA[ADV -]] : 
   1 = [ADV -], (lambda (x) (1 
            (lambda (dword) (degree (dword (lambda (d) (BE (uqe 
                              (some (e) (NOTENSE e))) (2 x d)))))) x)) : 
   1 = [ADV +], 
      (lambda (x) (1 (lambda (dword) (degree (dword (lambda (d) (2 x d))))) 
            x)).
IDRULE A2/COMPAR3a : ; taller than lee is, as stupid as lee is
   A2[+PRD, ADV -] --> H1[AFORM @a], S[COMP @a, SLASH A2] : 
   (lambda (x) (1 (lambda (dword) 
               (degree (dword (lambda (d) (2 (lambda (x2) (1 
                                 (lambda (dword2) (degree d)) x2))))))) x)).
IDRULE A2/COMPAR3b : ; more eagerly than kim helps. Like A2/COMPAR3a except
                     ; that the missing AP in the 'than' clause is an adverb
                     ; and isn't overtly extracted.
   A2[+PRD, ADV +] --> H1[AFORM @a], S[COMP @a, SLASH NOSLASH] : 
   0 = [QUA -], (lambda (x) 
         (1 (lambda (dword) (degree (dword (lambda (d) (2 (lambda (prop) 
                              (lambda (ta) 
                                 (lambda (equa) ((lambda (e) (and (prop e) 
                                             (1 (lambda (dword2) (degree d)) 
                                                e))) 
                                       (uqe ((equa some) (e2) (ta 
                                                e2)))))))))))) x)) : 
   0 = [QUA +], 
      (1 (lambda (dword) (degree (dword (lambda (d) (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((1 (lambda (dword2) 
                                                (degree d))) (e) 
                                          (ta e))))))))))))).
IDRULE A2/COMPAR4a : ; more crazy than you thought, as eagerly as he
                     ; claimed, more often than kim said. SLASH S terminated
                     ; by STM3a and STM3b.
   A2[+PRD] --> H1[AFORM @a], S[COMP @a, SLASH S] : 
   0 = [ADV -], (lambda (x) (1 
            (lambda (dword) (degree (dword (lambda (d) (2 (BE 
                              (uqe (some (e) (NOTENSE e))) 
                              (1 (lambda (dword) (degree d)) x))))))) x)) : 
   0 = [ADV +, QUA -], 
      (lambda (x) (1 (lambda (dword) (degree (dword (lambda (d) 
                        (2 ((lambda (e) 
                                 (and (PROPRED e) (1 (lambda (dword) (degree 
                                             d)) e))) 
                              (uqe (some (e2) (NOTENSE e2))))))))) x)) : 
   0 = [ADV +, QUA +], 
      (1 (lambda (dword) (degree (dword (lambda (d) (2 (PROPRED 
                           (uqe ((1 (lambda (dword) (degree d))) (e) 
                                 (NOTENSE e)))))))))).
IDRULE A2/COMPAR4b : ; more quickly than kim can, as often as he did. [SLASH
                     ; VP] terminated by VP/PRO/SLASH. This has to be a
                     ; separate rule from A2/COMPAR4a because this should
                     ; only work when the A2 is [ADV +] (*kim is busier than
                     ; lee can).
   A2[+PRD, +ADV] --> H1[AFORM @a], S[COMP @a, SLASH VP] : 
   0 = [QUA -], (lambda (x) 
         (1 (lambda (dword) (degree (dword (lambda (d) (2 (lambda (prop) 
                              (lambda (ta) 
                                 (lambda (equa) ((lambda (e) (and (prop e 
                                                PROVP) 
                                             (1 (lambda (dword) (degree d)) 
                                                e))) 
                                       (uqe ((equa some) (e2) (ta 
                                                e2)))))))))))) x)) : 
   0 = [QUA +], 
      (1 (lambda (dword) (degree (dword (lambda (d) (2 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((1 (lambda (dword) 
                                                (degree d))) (e) (ta e))) 
                                    PROVP)))))))))).
IDRULE A2/COMPAR5 : ; taller than lee is short, as crazy as kim is stupid
   A2[+PRD, ADV -] --> H1[AFORM @a], S[COMP @a, SLASH [QUA +, ADV -]] : 
   (lambda (x) (1 (lambda (dword) (degree (dword (lambda (d) (2 d))))) x)).
IDRULE A2/COMPAR6 : ; rather than use a metarule, this terminates the SLASH
                    ; +QUA introduced by idrules A2/COMPAR5 and A2/COMPAR2.
                    ; Notice that no empty node is introduced.
   A2[SLASH [QUA +, ADV -, PRD -], WH NO, UB NO, EVER NO, QUA -] --> 
   H1[AFORM NONE, SLASH NOSLASH, GRADE +] : 
   1 = [QUA -, ADV -], (lambda (x) (lambda (wh) 
            (1 (lambda (dword) (degree wh)) x))) : 
   1 = [QUA -, ADV +], (lambda (x) (lambda (wh) (1 x wh))) : 
   1 = [QUA +], (lambda (x) (lambda (wh) (1 x wh))).
IDRULE A1/A : ; an A with no complements.
   A1 --> H[SUBCAT NULL] : 1 = [GRADE -], 1 : 
   1 = [QUA -, GRADE +, AFORM ER], (lambda (deg) 
         (lambda (x) (1 x (deg (more than))))) : 
   1 = [QUA -, GRADE +, ADV -, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 x (deg unknown)))) : 
   1 = [QUA -, GRADE +, ADV -, AFORM EST], 
      (lambda (deg) (lambda (x) (1 x (deg most)))) : 
   1 = [QUA -, GRADE +, ADV +, AFORM (NONE, EST)], 1 : 
   1 = [QUA +, GRADE +], 1.
IDRULE A1/A_PHR : ; full up
   A1 --> H[SUBCAT NULL, PRT @p], [PRT @p] : 1 = [GRADE -], (CP 1 2) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) ((CP 1 2) x (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], 
      (lambda (deg) (lambda (x) ((CP 1 2) x (deg (more than))))).
IDRULE A1/PP : ; anxious about everything. The semantics happens to give the
               ; right translation whether the PP is [SLASH NOSLASH] or
               ; [SLASH X2] so there is no need for the usual conditions.
   A1 --> H[SUBCAT PP, PFORM @pf], P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], (lambda (x) 
         (2 (lambda (prep) (lambda (y) ((CP 1 prep) x y))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (2 (lambda (prep) (lambda (y) 
                     ((CP 1 prep) x y (deg unknown))))))) : 
   1 = [GRADE +, AFORM ER], 
      (lambda (deg) (lambda (x) (2 (lambda (prep) (lambda (y) 
                     ((CP 1 prep) x y (deg (more than)))))))).
IDRULE A1/PP_PHR : ; made up of, shot through with. The semantics happens to
                   ; give the right translation whether the PP is [SLASH
                   ; NOSLASH] or [SLASH X2] so there is no need for the
                   ; usual conditions.
   A1 --> H[SUBCAT PP, PFORM @pf, PRT @p], [PRT @p], P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], 
      (lambda (x) (3 (lambda (prep) (lambda (y) ((CP 1 2 prep) x y))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (3 (lambda (prep) (lambda (y) 
                     ((CP 1 2 prep) x y (deg unknown))))))) : 
   1 = [GRADE +, AFORM ER], 
      (lambda (deg) (lambda (x) (3 (lambda (prep) (lambda (y) 
                     ((CP 1 2 prep) x y (deg (more than)))))))).
IDRULE A1/LOC : ; situated by the abbey
   A1 --> H[SUBCAT LOC], P2[+LOC, PFORM NORM, PRD +] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) (and (1 x) (2 x))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (and (1 x) (2 x wh)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (and (1 x (deg unknown)) (2 x)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (and (1 x (deg unknown)) (2 x wh))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (and (1 x (deg (more than))) (2 x)))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (and (1 x (deg (more than))) (2 x wh))))).
IDRULE A1/PP_PP : ; accountable to us for his actions. The semantics happens
                  ; to give the right translation whether the first PP is
                  ; [SLASH NOSLASH] or [SLASH X2] so there is no need for
                  ; the usual conditions.
   A1[SLASH @s] --> H[SUBCAT PP_PP, PFORM @pf], 
   P2[PRD -, PFORM @pf, SLASH @s], P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], (lambda (x) 
         (2 (lambda (prep) (lambda (y) (3 (lambda (prep2) 
                        (lambda (y2) ((CP 1 prep prep2) x y y2)))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (2 (lambda (prep) (lambda (y) 
                     (3 (lambda (prep2) 
                           (lambda (y2) ((CP 1 prep prep2) x y y2 
                                 (deg unknown)))))))))) : 
   1 = [GRADE +, AFORM ER], 
      (lambda (deg) (lambda (x) (2 (lambda (prep) (lambda (y) 
                     (3 (lambda (prep2) 
                           (lambda (y2) ((CP 1 prep prep2) x y y2 
                                 (deg (more than))))))))))).
IDRULE A1/SFIN1A : ; aware that he might not apologize
   A1 --> H[SUBCAT SFIN, SUBTYPE NONE], S[+FIN, COMP THAT] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e3) (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/SFIN1B : ; aware he might not apologize
   A1 --> H[SUBCAT SFIN, SUBTYPE NONE], S[+FIN, COMP NORM] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e3) (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/SFIN2A : ; that he could help was convenient
   A1[AGR S[+FIN]] --> H[SUBCAT SFIN, SUBTYPE EXTRAP] : 
   1 = [GRADE -], (lambda (x) (1 x)) : 
   1 = [GRADE +, AFORM NONE], (lambda (deg) 
         (lambda (x) (1 x (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) 
         (lambda (x) (1 x (deg (more than))))).
IDRULE A1/SFIN2B : ; it was convenient that he could help
   A1[AGR N2[NFORM IT]] --> H[SUBCAT SFIN, SUBTYPE EXTRAP], S[FIN +] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/PP_SFINA : ; that he wouldn't apologize was clear to me. No
                     ; extraction because of [AGR S].
   A1[AGR S[+FIN]] --> H[SUBCAT PP_SFIN, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], (lambda (x) (1 x (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 x (2 (lambda (prep) (lambda (y) y))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 x (2 (lambda (prep) (lambda (y) y))) (deg (more than))))).
IDRULE A1/PP_SFINB : ; it was clear to me that he wouldn't apologize
   A1[AGR N2[NFORM IT]] --> H[SUBCAT PP_SFIN, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -], S[+FIN] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) 
         (1 (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))) 
            (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y)) wh)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3)))))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (3 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3)))))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg (more than)))))).
IDRULE A1/SBSE1 : ; eager/fearful that you answer
   A1 --> H[SUBCAT SBSE, SUBTYPE NONE], S[COMP THAT, BSE] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e3) (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/SBSE2A : ; that you apologize is necessary
   A1[AGR S[-FIN, BSE]] --> H[SUBCAT SBSE, SUBTYPE EXTRAP] : 
   1 = [GRADE -], (lambda (x) (1 x)) : 
   1 = [GRADE +, AFORM NONE], (lambda (deg) 
         (lambda (x) (1 x (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) 
         (lambda (x) (1 x (deg (more than))))).
IDRULE A1/SBSE2B : ; it is necessary that you apologize
   A1[AGR N2[NFORM IT]] --> H[SUBCAT SBSE, SUBTYPE EXTRAP], 
   S[COMP THAT, BSE] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) (1 (2 (lambda (prop) 
                  (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) (ta 
                                    e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/SINF1 : ; he is eager for us to help
   A1 --> H[SUBCAT SINF, SUBTYPE NONE], S[COMP FOR] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e3) (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/SINF2A : ; for him to apologize is inessential
   A1[AGR S[-FIN, VFORM TO]] --> H[SUBCAT SINF, SUBTYPE EXTRAP] : 
   1 = [GRADE -], (lambda (x) (1 x)) : 
   1 = [GRADE +, AFORM NONE], (lambda (deg) 
         (lambda (x) (1 x (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) 
         (lambda (x) (1 x (deg (more than))))).
IDRULE A1/SINF2B : ; it is inessential for him to apologize
   A1[AGR N2[NFORM IT]] --> H[SUBCAT SINF, SUBTYPE EXTRAP], 
   S[TO, COMP FOR, -FIN] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) (1 (2 
               (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) (ta e3))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/VPINF1A : ; to apologize is normal (arbitrary control)
   A1[AGR VP[-FIN]] --> H[SUBCAT VPINF, SUBTYPE EXTRAP] : 
   1 = [GRADE -], (lambda (x) 
         (1 (x (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                           (pro (the (z) (entity z)))))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 (x (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (pro (the (z) (entity z)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 (x (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e3) 
                                    (NOTENSE (ta e3)))) 
                              (pro (the (z) (entity z)))))))) 
               (deg (more than))))).
IDRULE A1/VPINF1B : ; it is normal to apologize (arbitrary control) (extrap)
   A1[AGR N2[NFORM IT]] --> H[SUBCAT VPINF, SUBTYPE EXTRAP], 
   VP[TO, -FIN, AGR N2[NFORM NORM]] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) 
         (1 (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (NOTENSE (ta e3)))) 
                           (pro (the (z) (entity z)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (pro (the (z) (entity z))) wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (pro (the (z) (entity z)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (pro (the (z) (entity z))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (pro (the (z) (entity z)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (pro (the (z) (entity z))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/VPINF2 : ; for "silly" type adjectives - it is silly of you to do
                   ; that. Variants of such adjs are generated by the
                   ; morphology system
   A1[AGR N2[NFORM IT]] --> H[SUBCAT VPINF, SUBTYPE SILLY], 
   P2[PFORM OF, PRD -], VP[TO, AGR N2[NFORM NORM]] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 (2 (lambda (prep) (lambda (y) y))) 
            (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (NOTENSE (ta e3)))) 
                           (2 (lambda (prep) (lambda (y) y)))))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prep) (lambda (y) y)) wh) 
               (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe ((equa some) (e3) 
                                    (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)) wh))))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 (lambda (prep) (lambda (y) y))) 
               (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe ((equa some) (e3) 
                                    (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y))) 
                              (deg unknown))))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prep) (lambda (y) y)) wh) 
                  (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (2 (lambda (prep) (lambda (y) y)) wh) 
                                 (deg unknown)))))))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 (lambda (prep) (lambda (y) y))) 
               (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe ((equa some) (e3) 
                                    (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y))) 
                              (deg (more than)))))))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prep) (lambda (y) y)) wh) 
                  (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (2 (lambda (prep) (lambda (y) y)) wh) 
                                 (deg (more than))))))))))).
IDRULE A1/VPINF3A : ; for "ready" type adjectives - we are ready to eat
                    ; dinner.
   A1[AGR N2] --> H[SUBCAT VPINF, SUBTYPE READY], 
   VP[TO, AGR N2[NFORM NORM]] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) 
         (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (NOTENSE (ta e3)))) x))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) x 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              x))))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) x wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              x))))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) x wh))))) 
                  (deg (more than)))))).
IDRULE A1/VPINF3B : ; for "ready" type adjectives - the dinner is ready to
                    ; eat e. (different from tough adjs because 'an easy
                    ; food to cook e' vs '* a ready food to cook e')
   A1[AGR N2, SLASH NOSLASH] --> H[SUBCAT VPINF, SUBTYPE READY], 
   VP[TO, SLASH N2[+ACC], AGR N2[NFORM NORM]] : 
   1 = [GRADE -], (lambda (x) (1 x 
            (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           (pro (the (z) (entity z))) x))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              (pro (the (z) (entity z))) x))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 x (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e1) 
                                    (NOTENSE (ta e1)))) 
                              (pro (the (z) (entity z))) x))))) 
               (deg (more than))))).
IDRULE A1/VPINF3C : ; for "ready" type adjectives - the dinner is ready for
                    ; us to eat e.
   A1[SLASH NOSLASH] --> H[SUBCAT VPINF, SUBTYPE READY], 
   S[COMP FOR, SLASH N2[+ACC]] : 
   1 = [GRADE -], (lambda (x) (1 x (2 (lambda (prop) 
                  (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (ta e1))) x))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (ta e1))) x))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 x (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e1) (ta e1))) 
                              x))))) (deg (more than))))).
IDRULE A1/SR_INF : ; he is certain to help
   A1 --> H[SUBCAT SC_INF, SUBTYPE RAIS], VP[TO] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e1) 
                                 (NOTENSE (ta e1)))) x))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) x 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (2 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg (more than)))))).
IDRULE A1/SE_INF : ; eager to help
   A1 --> H[SUBCAT SC_INF, SUBTYPE EQUI], VP[TO] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e1) (NOTENSE (ta e1)))) 
                           x))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], (lambda (x) 
         (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop 
                              (uqe ((equa some) (e1) (NOTENSE (ta e1)))) x 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg (more than)))))).
IDRULE A1/SE_ING : ; busy helping them
   A1 --> H[SUBCAT SC_ING, SUBTYPE EQUI], VP[ING, +PRD] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (2 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e1) (NOTENSE (ta e1)))) 
                           x))))))) : 
   1 = [GRADE -], 2 = [SLASH X2], (lambda (x) 
         (lambda (wh) (1 x (2 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop 
                              (uqe ((equa some) (e1) (NOTENSE (ta e1)))) x 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (2 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg (more than)))))).
IDRULE A1/SE_AP : ; scared silly
   A1 --> H[SUBCAT SC_AP, SUBTYPE EQUI], A2 : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], 
      (lambda (x) (1 x (BE (uqe (some (e1) (NOTENSE e1))) (2 x)))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (BE (uqe (some (e1) (NOTENSE e1))) 
                  (2 x wh))))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (BE (uqe (some (e1) (NOTENSE e1))) (2 x)) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (BE (uqe (some (e1) (NOTENSE e1))) (2 x wh)) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (BE (uqe (some (e1) (NOTENSE e1))) (2 x)) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (BE (uqe (some (e1) (NOTENSE e1))) (2 x wh)) 
                  (deg (more than)))))).
IDRULE A1/TOUGH1 : ; easy to amuse e
   A1[AGR N2, SLASH NOSLASH] --> H[SUBCAT VPINF, SUBTYPE TOUGH], 
   VP[TO, SLASH N2[+ACC], AGR N2[NFORM NORM]] : 
   1 = [GRADE -], (lambda (x) (1 (2 
               (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                           (pro (the (z) (entity z))) x))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              (pro (the (z) (entity z))) x))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e1) 
                                    (NOTENSE (ta e1)))) 
                              (pro (the (z) (entity z))) x))))) 
               (deg (more than))))).
IDRULE A1/TOUGH2 : ; easy for us to amuse e
   A1[SLASH NOSLASH] --> H[SUBCAT VPINF, SUBTYPE TOUGH], 
   S[COMP FOR, SLASH N2[+ACC]] : 
   1 = [GRADE -], (lambda (x) (1 (2 (lambda (prop) 
                  (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e1) (ta e1))) x))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (ta e1))) x))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e1) (ta e1))) 
                              x))))) (deg (more than))))).
IDRULE A1/PPING : ; confident of having been appreciated
   A1 --> H[SUBCAT PPING, SUBTYPE EQUI, PFORM @pf], P[PFORM @pf], VP[GER] : 
   1 = [GRADE -], 3 = [SLASH NOSLASH], 
      (lambda (x) (1 x (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e1) (NOTENSE (ta e1)))) 
                           x))))))) : 
   1 = [GRADE -], 3 = [SLASH X2], (lambda (x) 
         (lambda (wh) (1 x (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop 
                              (uqe ((equa some) (e1) (NOTENSE (ta e1)))) x 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 3 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 3 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 3 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (NOTENSE (ta e1)))) 
                              x))))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 3 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (NOTENSE (ta e1)))) x wh))))) 
                  (deg (more than)))))).
IDRULE A1/PPSING : ; confident of him having being appreciated
   A1 --> H[SUBCAT PPSING, PFORM @pf], P[PFORM @pf], S[COMP NORM, GER] : 
   1 = [GRADE -], 3 = [SLASH NOSLASH], 
      (lambda (x) (1 x (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe 
                              ((equa some) (e1) (ta e1)))))))))) : 
   1 = [GRADE -], 3 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 x (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (ta e1))) 
                              wh)))))))) : 
   1 = [GRADE +, AFORM NONE], 3 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (ta e1)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 3 = [SLASH X2], (lambda (deg) 
         (lambda (x) (lambda (wh) 
               (1 x (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e1) (ta e1))) wh))))) 
                  (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 3 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 x 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e1) (ta e1)))))))) 
               (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 3 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 x (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e1) 
                                       (ta e1))) wh))))) 
                  (deg (more than)))))).
IDRULE A1/WHSA : ; it is not clear whether we should go, it is clear what we
                 ; should do. No conditions in the semantics because the
                 ; rule defaults to [SLASH NOSLASH] (no extraction out of a
                 ; wh complement).
   A1[AGR N2[NFORM IT]] --> H[SUBCAT WHS, SUBTYPE EXTRAP], S[+Q] : 
   1 = [GRADE -], 
      (lambda (x) (1 (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                        (prop (uqe ((equa some) (e3) (ta e3)))))))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 (2 (lambda (prop) (lambda (ta) 
                        (lambda (equa) (prop (uqe ((equa some) (e3) 
                                    (ta e3)))))))) (deg (more than))))).
IDRULE A1/WHSB : ; whether we should help/ what we should do is not clear
   A1[AGR S[+Q]] --> H[SUBCAT WHS, SUBTYPE EXTRAP] : 
   1 = [GRADE -], (lambda (x) (1 x)) : 
   1 = [GRADE +, AFORM NONE], (lambda (deg) 
         (lambda (x) (1 x (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) 
         (lambda (x) (1 x (deg (more than))))).
IDRULE A1/PP_VPINF1A : ; to apologize is typical of him. No extraction
                       ; because of [AGR VP].
   A1[AGR VP[-FIN]] --> H[SUBCAT PP_VPINF, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], (lambda (VP) (1 (VP (lambda (prop) (lambda (ta) 
                     (lambda (equa) 
                        (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                           (2 (lambda (prep) (lambda (y) y)))))))) 
            (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE +, AFORM NONE], (lambda (deg) 
         (lambda (VP) (1 (VP (lambda (prop) 
                     (lambda (ta) (lambda (equa) (prop (uqe 
                                 ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], 
      (lambda (deg) (lambda (VP) (1 (VP (lambda (prop) (lambda (ta) 
                        (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg (more than))))).
IDRULE A1/PP_VPINF1B : ; it is typical of him to apologize
   A1[AGR N2[NFORM IT]] --> H[SUBCAT PP_VPINF, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -], VP[TO, -FIN] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) 
         (1 (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (NOTENSE (ta e3)))) 
                           (2 (lambda (prep) (lambda (y) y)))))))) 
            (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)) wh)))))) 
               (2 (lambda (prep) (lambda (y) y)) wh)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (2 (lambda (prep) (lambda (y) y)) wh)))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (3 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (NOTENSE (ta e3)))) 
                              (2 (lambda (prep) (lambda (y) y)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (NOTENSE (ta e3)))) 
                                 (2 (lambda (prep) (lambda (y) y)) wh)))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg (more than)))))).
IDRULE A1/PP_WHSA : ; it is not clear to me whether we should go, it is
                    ; clear to me what we should do
   A1[AGR N2[NFORM IT]] --> H[SUBCAT PP_WHS, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -], S[+Q] : 
   1 = [GRADE -], 2 = [SLASH NOSLASH], (lambda (x) 
         (1 (3 (lambda (prop) (lambda (ta) 
                     (lambda (equa) (prop (uqe ((equa some) (e3) 
                                 (ta e3)))))))) 
            (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE -], 2 = [SLASH X2], 
      (lambda (x) (lambda (wh) (1 (3 (lambda (prop) 
                     (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y)) wh)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 
               (3 (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg unknown)))) : 
   1 = [GRADE +, AFORM NONE], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3)))))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg unknown))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH NOSLASH], 
      (lambda (deg) (lambda (x) (1 (3 
                  (lambda (prop) (lambda (ta) (lambda (equa) 
                           (prop (uqe ((equa some) (e3) (ta e3)))))))) 
               (2 (lambda (prep) (lambda (y) y))) (deg (more than))))) : 
   1 = [GRADE +, AFORM ER], 2 = [SLASH X2], 
      (lambda (deg) (lambda (x) (lambda (wh) 
               (1 (3 (lambda (prop) (lambda (ta) 
                           (lambda (equa) (prop (uqe ((equa some) (e3) 
                                       (ta e3)))))))) 
                  (2 (lambda (prep) (lambda (y) y)) wh) (deg (more than)))))).
IDRULE A1/PP_WHSB : ; whether we should help/ what we should do is not clear
                    ; to me. No extraction because of [AGR S].
   A1[AGR S[+Q]] --> H[SUBCAT PP_WHS, SUBTYPE EXTRAP, PFORM @pf], 
   P2[PFORM @pf, PRD -] : 
   1 = [GRADE -], (lambda (x) (1 x (2 (lambda (prep) (lambda (y) y))))) : 
   1 = [GRADE +, AFORM NONE], 
      (lambda (deg) (lambda (x) (1 x (2 (lambda (prep) (lambda (y) y))) 
               (deg unknown)))) : 
   1 = [GRADE +, AFORM ER], (lambda (deg) (lambda (x) 
            (1 x (2 (lambda (prep) (lambda (y) y))) (deg (more than))))).
IDRULE A1/DEGMOD1 : ; so clever, so obviously, more stupid. All [QUA -,
                    ; GRADE +] adjectives and adverbs can take a degree
                    ; modifier. The head daughter is [AFORM NONE] to prevent
                    ; 'so taller', 'more taller'.
   A1[-QUA, WH @w, UB @u, EVER @e, DISTR @d] --> 
   DetA[WH @w, UB @u, EVER @e, DISTR @d], H1[AFORM NONE, GRADE +] : 
   0 = [ADV -], (lambda (deg) (lambda (x) (2 (lambda (olddeg) (deg 1)) x))) : 
   0 = [ADV +], (lambda (deg) (lambda (x) (2 x (deg 1)))).
IDRULE A1/DEGMOD2 : ; so many, too many. The only +QUA adjectives that can
                    ; take a degree modifier are the +PRD, -NUM ones. This
                    ; rule also does +QUA adverbs.
   A1[+QUA, +PRD, -NUM, WH @W, UB @u, EVER @e] --> 
   DetA[WH @W, UB @u, EVER @e], H1[AFORM NONE, GRADE +] : 
   2 = [ADV -, PART -], 1 = [AFORM (EST, ER, NONE)], 
      (lambda (P) (lambda (Q) (lambda (T) 
               (2 P Q (lambda (qua) (lambda (prop) (T (1 qua) prop))))))) : 
   2 = [ADV -, PART -], 1 = [AFORM AS], 
      (lambda (P) (lambda (Q) (lambda (T) (2 P Q 
                  (lambda (qua) (lambda (prop) (T (as qua) prop))))))) : 
   2 = [ADV -, PART OF], (1 2) : 2 = [ADV +], (lambda (deg) (2 (deg 1))).
IDRULE A1/DEGMOD3 : ; the third longest book
   A1[-QUA, AFORM EST, WH NO, UB NO, EVER NO] --> DetA[NUM ORD, AFORM NONE], 
   H1[AFORM EST, GRADE +] : 
   (lambda (deg) (lambda (x) (2 (lambda (olddeg) (deg (1 olddeg))) x))).
IDRULE A1/DEGMOD4 : ; the first hundred/second three people
   A1[NUM CARD, WH NO, UB NO, EVER NO] --> DetA[NUM ORD], H1 : 
   (lambda (P) (lambda (Q) 
            (lambda (T) (2 P Q (lambda (t1) (lambda (t2) (T (1 t1) t2))))))).
IDRULE A/NUMBER1 : ; numbers can be quantifying adjectives (the three books)
   
   A[+PRD, -ADV, -NEG, -DEF, +QUA, CARD, AGR +N[+PLU, +COUNT, V -, NFORM 
      NORM], AFORM NONE, SUBCAT NULL, SUBTYPE NONE, PART -] --> 
   [CN1 @x, CN2 @y, AND @z, CN4 +] : 
   (lambda (P) (lambda (Q) (lambda (T) (T (NN 1) 
                  (lambda (x) (and (Q x) (P x))))))).
IDRULE A/NUMBER2 : ; "one" as a quantifying adjective.
   
   A[+PRD, -ADV, -NEG, -DEF, +QUA, CARD, AGR +N[-PLU, +COUNT, V -, NFORM 
      NORM], AFORM NONE, SUBCAT NULL, SUBTYPE NONE, PART -] --> [CN3 ONE] : 
   (lambda (P) 
         (lambda (Q) (lambda (T) (T (NN 1) (lambda (x) (and (Q x) (P x))))))).
IDRULE A/FRACTION : ; a fraction can be the quantifier in a partitive (nine
                    ; tenths of the people/wine).
   
   A[-PRD, -ADV, -NEG, -DEF, +QUA, -NUM, AGR N2[NFORM NORM], SUBCAT NULL, 
      PART OF, AFORM NONE, SUBTYPE NONE] --> [FRACT +, PLU @p] : (NN 1).
IDRULE A/COMPOUND : ; age aware, ice cold, sugar free. NB The inclusion of
                    ; rules N/COMPOUND2, N/COMPOUND3 and A/COMPOUND can lead
                    ; to a lot of spurious ambiguity. It may be better to
                    ; comment them out.
   A[ADV -, AFORM NONE] --> 
   N[SUBCAT NULL, COORD -, -NUM, PN -, POSS -, PART -, PLU -], 
   H[SUBCAT NULL, COORD -, -NUM, DISTR ATT] : (compound 1 2).
IDRULE A2/THAN/AS : ; than happy (as in "more contented than happy").
   A2[PFORM @p] --> P[SUBCAT NP, PFORM @p], H2 : 2.
\end{verbatim}
{\bf ; coordination rules}
\begin{verbatim}
; The CONJ rules expand a category as a coordinator followed 
; by the same category. The COORD rules expand the top category of a 
; coordination as conjunct daughters of the same category. In most cases 
; these conjuncts are not heads since not all head features ought to be 
; propagated. The rules for coordinated NPs are complicated in a not 
; entirely successful attempt to get person and number features correctly 
; distributed. The PRD and MOD rules allow for the coordination 
; of unlike categories - these coordinations will only appear in restricted 
; environments. The grammar contains a rather complicated 
; treatment of the semantics of coordinated VPs and Ss in order for separate 
; events to be associated with each conjunct and in order for tense and 
; aspect and quantifier information to spread down into each event. The 
; feature ELLIP plays a crucial role here: an [ELLIP +] constituent is one 
; which is waiting to receive tense/aspect/quantifier information from 
; higher up. An [ELLIP -] one doesn't need that information. The VP/COORD* 
; rules are [ELLIP -] and the rules ELL/VP/COORD* are [ELLIP +] versions. 
; Other rules with names starting with ELL are [ELLIP +] versions of 
; non-coordination rules in the main part of the grammar which are [ELLIP 
; -]. The only real reason for separating [ELLIP +] and [ELLIP -] versions 
; is that the semantic conditions are already so complex that doing 
; everything with a single rule would be incomprehensible. 

IDRULE CONJ/N : N[CONJ @con, PN -] --> [SUBCAT @con, CONJN +], H : 2.
IDRULE CONJ/N1 : N1[CONJ @con] --> [SUBCAT @con, CONJN +], H1 : 2.
IDRULE CONJ/N2 : 
   N2[CONJ @con, SPEC @s, QFEAT @qf, NEG @n, DEF @df, AFORM @af] --> 
   [SUBCAT @con, CONJN +], 
   H2[SPEC @s, QFEAT @qf, NEG @n, DEF @df, AFORM @af] : 2.
IDRULE CONJ/P : P[CONJ @con, NEG @n] --> [SUBCAT @con, CONJN +], H[NEG @n] : 
   2.
IDRULE CONJ/P2 : P2[CONJ @con, NEG @n] --> [SUBCAT @con, CONJN +], 
   H2[NEG @n] : 2.
IDRULE CONJ/A : A[CONJ @con] --> [SUBCAT @con, CONJN +], H : 2.
IDRULE CONJ/A1 : A1[CONJ @con] --> [SUBCAT @con, CONJN +], H1 : 2.
IDRULE CONJ/A2 : A2[CONJ @con] --> [SUBCAT @con, CONJN +], H2 : 2.
IDRULE CONJ/V : V[CONJ @con] --> [SUBCAT @con, CONJN +], H : 2.
IDRULE CONJ/VP : VP[CONJ @con] --> [SUBCAT @con, CONJN +], H2[-SUBJ] : 2.
IDRULE CONJ/S : S[CONJ @con, UDC @u] --> [SUBCAT @con, CONJN +], 
   S[H +, UDC @u] : 2.
IDRULE CONJ/MOD1 : X2[+ADV, CONJ @con, WH @a, UB @b, EVER @c, QUA @q] --> 
   [SUBCAT @con, CONJN +], A2[+ADV, WH @a, UB @b, EVER @c, QUA @q] : 2.
IDRULE CONJ/MOD2 : 
   X2[+ADV, CONJ @con, WH @a, UB @b, EVER @c, PRD +, QUA -, LOC @l] --> 
   [SUBCAT @con, CONJN +], 
   P2[PFORM NORM, WH @a, UB @b, EVER @c, PRD +, GERUND @g, LOC @l] : 2.
IDRULE CONJ/PRD : 
   X2[+PRD, SLASH @s, AGR @a, COORD @c, ELLIP @e, CONJ @con] --> 
   [SUBCAT @con, CONJN +], 
   X2[H +, +PRD, SLASH @s, AGR @a, COORD @c, ELLIP @e] : 2.
IDRULE N/COORD1 : N[PLU +, PN -, PRO -, COORD +] --> ( N[CONJ NULL] )+, 
   ( N[CONJ AND] )+ : (AND 1+).
IDRULE N/COORD2A : N[PLU @pl, PN -, PRO -, COORD +] --> 
   ( N[CONJ NULL, PLU @pl] )+, ( N[CONJ OR, PLU @pl] )+ : (OR 1+).
IDRULE N/COORD2B : N[PLU +, PN -, PRO -, COORD +] --> N[CONJ NULL, PLU +], 
   N[CONJ OR, PLU -] : (OR 1 2).
IDRULE N/COORD2C : N[PLU +, PN -, PRO -, COORD +] --> N[CONJ NULL, PLU -], 
   N[CONJ OR, PLU +] : (OR 1 2).
IDRULE N1/COORD1 : N1[PLU +, COORD +] --> ( N1[CONJ NULL] )+, 
   ( N1[CONJ AND] )+ : 0 = [SLASH NOSLASH], (lambda (x) (AND (1+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (AND (1+ x wh)))).
IDRULE N1/COORD2A : N1[COORD +] --> ( N1[CONJ NULL, PLU -] )+, 
   ( N1[CONJ OR, PLU -] )+ : 0 = [SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))).
IDRULE N1/COORD2B : N1[PLU +, COORD +] --> N1[CONJ NULL, PLU +], 
   N1[CONJ OR, PLU -] : 0 = [SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))).
IDRULE N1/COORD2C : N1[PLU +, COORD +] --> N1[CONJ NULL, PLU -], 
   N1[CONJ OR, PLU +] : 0 = [SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))).
IDRULE N1/COORD2D : N1[PLU +, COORD +] --> ( N1[CONJ NULL, PLU +] )+, 
   ( N1[CONJ OR, PLU +] )+ : 0 = [SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))).
IDRULE N2/COORD1 : N2[PLU +, COORD +] --> ( N2[CONJ NULL] )+, 
   ( N2[CONJ AND] )+ : 0 = [SPEC +, PRD -, SLASH NOSLASH], (AND 1+) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (AND (1+ x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (AND (1+ x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (AND (1+ Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (AND (1+ wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1+ x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1+ x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (AND (1+ wh Q T))))).
IDRULE N2/COORD2 : N2[PLU +, COORD +] --> N2[CONJ BOTH], N2[CONJ AND] : 
   0 = [SPEC +, PRD -, SLASH NOSLASH], (AND 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (AND (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (AND (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (AND (1 wh Q T) (2 wh Q T))))).
IDRULE N2/COORD3A : N2[COORD +] --> ( N2[CONJ NULL, PLU -] )+, 
   ( N2[CONJ OR, PLU -] )+ : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1+) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1+ Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1+ wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1+ wh Q T))))).
IDRULE N2/COORD3B : N2[PLU +, COORD +] --> N2[CONJ NULL, PLU +], 
   N2[CONJ OR, PLU -] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1 wh Q T) (2 wh Q T))))).
IDRULE N2/COORD3C : N2[PLU +, COORD +] --> N2[CONJ NULL, PLU -], 
   N2[CONJ OR, PLU +] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1 wh Q T) (2 wh Q T))))).
IDRULE N2/COORD3D : N2[PLU +, COORD +] --> ( N2[CONJ NULL, PLU +] )+, 
   ( N2[CONJ OR, PLU +] )+ : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1+) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1+ Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1+ wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1+ wh Q T))))).
IDRULE N2/COORD4A : N2[PLU @pl, COORD +] --> N2[CONJ NEITHER, PLU @pl], 
   ( N2[CONJ NOR, PLU @pl] )+ : 
   0 = [SPEC +, PRD -, SLASH NOSLASH], (NOT (OR 1 2+)) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (NOT (OR (1 x) (2+ x)))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], 
      (lambda (x) (NOT (OR (1 x) (2+ x)))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (NOT (OR (1 Q T) (2+ Q T))))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (NOT (OR (1 wh) (2+ wh)))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2+ x wh))))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2+ x wh))))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (NOT (OR (1 wh Q T) 
                     (2+ wh Q T)))))).
IDRULE N2/COORD4B : N2[PLU +, COORD +] --> N2[CONJ NEITHER, PLU +], 
   N2[CONJ NOR, PLU -] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (NOT (OR 1 2)) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (NOT (OR (1 x) (2 x)))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], 
      (lambda (x) (NOT (OR (1 x) (2 x)))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (NOT (OR (1 Q T) (2 Q T))))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (NOT (OR (1 wh) (2 wh)))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2 x wh))))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2 x wh))))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (NOT (OR (1 wh Q T) 
                     (2 wh Q T)))))).
IDRULE N2/COORD4C : N2[PLU +, COORD +] --> N2[CONJ NEITHER, PLU -], 
   N2[CONJ NOR, PLU +] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (NOT (OR 1 2)) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (NOT (OR (1 x) (2 x)))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], 
      (lambda (x) (NOT (OR (1 x) (2 x)))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (NOT (OR (1 Q T) (2 Q T))))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (NOT (OR (1 wh) (2 wh)))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2 x wh))))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2 x wh))))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (NOT (OR (1 wh Q T) 
                     (2 wh Q T)))))).
IDRULE N2/COORD5A : N2[PLU @pl, COORD +] --> N2[CONJ EITHER, PLU @pl], 
   ( N2[CONJ OR, PLU @pl] )+ : 
   0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1 2+) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2+ x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1 x) (2+ x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1 Q T) (2+ Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1 wh) (2+ wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2+ x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2+ x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1 wh Q T) (2+ wh Q T))))).
IDRULE N2/COORD5B : N2[PLU +, COORD +] --> N2[CONJ EITHER, PLU +], 
   N2[CONJ OR, PLU -] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1 wh Q T) (2 wh Q T))))).
IDRULE N2/COORD5C : N2[PLU +, COORD +] --> N2[CONJ EITHER, PLU -], 
   N2[CONJ OR, PLU +] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (OR 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (OR (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (OR (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (OR (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (OR (1 wh Q T) (2 wh Q T))))).
IDRULE N2/COORD6 : N2[PLU @plur, COORD +] --> N2[CONJ NULL], 
   N2[CONJ BUT, PLU @plur] : 0 = [SPEC +, PRD -, SLASH NOSLASH], (AND 1 2) : 
   0 = [SPEC +, PRD +, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT -, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SPEC -, QFEAT +, SLASH NOSLASH], 
      (lambda (Q) (lambda (T) (AND (1 Q T) (2 Q T)))) : 
   0 = [SPEC +, PRD -, SLASH X2], (lambda (wh) (AND (1 wh) (2 wh))) : 
   0 = [SPEC +, PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT -, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [SPEC -, QFEAT +, SLASH X2], 
      (lambda (wh) (lambda (Q) (lambda (T) (AND (1 wh Q T) (2 wh Q T))))).
IDRULE P/COORD1 : P[COORD +] --> ( P[CONJ NULL] )+, ( P[CONJ AND] )+ : 
   (AND 1+).
IDRULE P/COORD2 : P[COORD +] --> ( P[CONJ NULL] )+, ( P[CONJ OR] )+ : (OR 1+).
IDRULE P/COORD3 : P[COORD +] --> P[CONJ BOTH], P[CONJ AND] : (AND 1 2).
IDRULE P/COORD4 : P[COORD +] --> P[CONJ NEITHER], ( P[CONJ NOR] )+ : 
   (NOT (OR 1 2+)).
IDRULE P/COORD5 : P[COORD +] --> P[CONJ EITHER], ( P[CONJ OR] )+ : (OR 1 2+).
IDRULE P/COORD6 : P[COORD +] --> P[CONJ NULL], P[CONJ BUT] : (AND 1 2).
IDRULE P2/COORD1 : P2[COORD +] --> ( P2[CONJ NULL] )+, ( P2[CONJ AND] )+ : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (AND (1+ x))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (AND (1+ Q))) : 
   0 = [PRD +, SLASH X2], (lambda (x) (lambda (wh) (AND (1+ x wh)))) : 
   0 = [PRD -, SLASH X2], (lambda (Q) (lambda (wh) (AND (1+ Q wh)))).
IDRULE P2/COORD2 : P2[COORD +] --> ( P2[CONJ NULL] )+, ( P2[CONJ OR] )+ : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (OR (1+ Q))) : 
   0 = [PRD +, SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [PRD -, SLASH X2], (lambda (Q) (lambda (wh) (OR (1+ Q wh)))).
IDRULE P2/COORD3 : P2[COORD +] --> P2[CONJ BOTH], P2[CONJ AND] : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (AND (1 Q) (2 Q))) : 
   0 = [PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [PRD -, SLASH X2], (lambda (Q) (lambda (wh) (AND (1 Q wh) (2 Q wh)))).
IDRULE P2/COORD4 : P2[COORD +] --> P2[CONJ NEITHER], ( P2[CONJ NOR] )+ : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (NOT (OR (1 x) (2+ x)))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (NOT (OR (1 Q) (2+ Q)))) : 
   0 = [PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2+ x wh))))) : 
   0 = [PRD -, SLASH X2], 
      (lambda (Q) (lambda (wh) (NOT (OR (1 Q wh) (2+ Q wh))))).
IDRULE P2/COORD5 : P2[COORD +] --> P2[CONJ EITHER], ( P2[CONJ OR] )+ : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (OR (1 x) (2+ x))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (OR (1 Q) (2+ Q))) : 
   0 = [PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (OR (1 x wh) (2+ x wh)))) : 
   0 = [PRD -, SLASH X2], (lambda (Q) (lambda (wh) (OR (1 Q wh) (2+ Q wh)))).
IDRULE P2/COORD6 : P2[COORD +] --> P2[CONJ NULL], P2[CONJ BUT] : 
   0 = [PRD +, SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [PRD -, SLASH NOSLASH], (lambda (Q) (AND (1 Q) (2 Q))) : 
   0 = [PRD +, SLASH X2], 
      (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))) : 
   0 = [PRD -, SLASH X2], (lambda (Q) (lambda (wh) (AND (1 Q wh) (2 Q wh)))).
IDRULE A/COORD1 : A[COORD +] --> ( H[CONJ NULL] )+, ( H[CONJ AND] )+ : 
   (AND 1+).
IDRULE A/COORD2 : A[COORD +] --> ( H[CONJ NULL] )+, ( H[CONJ OR] )+ : (OR 1+).
IDRULE A/COORD3 : A[COORD +] --> H[CONJ BOTH], H[CONJ AND] : (AND 1 2).
IDRULE A/COORD4 : A[COORD +] --> H[CONJ NEITHER], ( H[CONJ NOR] )+ : 
   (NOT (OR 1 2+)).
IDRULE A/COORD5 : A[COORD +] --> H[CONJ EITHER], ( H[CONJ OR] )+ : (OR 1 2+).
IDRULE A/COORD6 : A[COORD +] --> H[CONJ NULL], H[CONJ BUT] : (AND 1 2).
IDRULE A1/COORD1 : A1[COORD +] --> ( A1[CONJ NULL] )+, ( A1[CONJ AND] )+ : 
   0 = [SLASH NOSLASH, GRADE -], (lambda (x) (AND (1+ x))) : 
   0 = [SLASH X2, GRADE -], (lambda (x) (lambda (wh) (AND (1+ x wh)))) : 
   0 = [SLASH NOSLASH, GRADE +], 
      (lambda (deg) (lambda (x) (AND (1+ deg x)))) : 
   0 = [SLASH X2, GRADE +], (lambda (deg) 
         (lambda (x) (lambda (wh) (AND (1+ deg x wh))))).
IDRULE A1/COORD2 : A1[COORD +] --> ( A1[CONJ NULL] )+, ( A1[CONJ OR] )+ : 
   0 = [SLASH NOSLASH, GRADE -], (lambda (x) (OR (1+ x))) : 
   0 = [SLASH X2, GRADE -], (lambda (x) (lambda (wh) (OR (1+ x wh)))) : 
   0 = [SLASH NOSLASH, GRADE +], 
      (lambda (deg) (lambda (x) (OR (1+ deg x)))) : 
   0 = [SLASH X2, GRADE +], (lambda (deg) 
         (lambda (x) (lambda (wh) (OR (1+ deg x wh))))).
IDRULE A2/COORD1 : A2[COORD +] --> ( A2[CONJ NULL] )+, ( A2[CONJ AND] )+ : 
   0 = [SLASH NOSLASH], (lambda (x) (AND (1+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (AND (1+ x wh)))).
IDRULE A2/COORD2 : A2[COORD +] --> ( A2[CONJ NULL] )+, ( A2[CONJ OR] )+ : 
   0 = [SLASH NOSLASH], (lambda (x) (OR (1+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1+ x wh)))).
IDRULE A2/COORD3 : A2[COORD +] --> A2[CONJ BOTH], A2[CONJ AND] : 
   0 = [SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))).
IDRULE A2/COORD4 : A2[COORD +] --> A2[CONJ NEITHER], ( A2[CONJ NOR] )+ : 
   0 = [SLASH NOSLASH], (lambda (x) (NOT (OR (1 x) (2+ x)))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (NOT (OR (1 x wh) (2+ x wh))))).
IDRULE A2/COORD5 : A2[COORD +] --> A2[CONJ EITHER], ( A2[CONJ OR] )+ : 
   0 = [SLASH NOSLASH], (lambda (x) (OR (1 x) (2+ x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (OR (1 x wh) (2+ x wh)))).
IDRULE A2/COORD6 : A2[COORD +] --> A2[CONJ NULL], A2[CONJ BUT] : 
   0 = [SLASH NOSLASH], (lambda (x) (AND (1 x) (2 x))) : 
   0 = [SLASH X2], (lambda (x) (lambda (wh) (AND (1 x wh) (2 x wh)))).
IDRULE V/COORD1 : V[COORD +] --> ( H[CONJ NULL] )+, ( H[CONJ AND] )+ : 
   (AND 1+).
IDRULE V/COORD2 : V[COORD +] --> ( H[CONJ NULL] )+, ( H[CONJ OR] )+ : (OR 1+).
IDRULE V/COORD3 : V[COORD +] --> H[CONJ BOTH], H[CONJ AND] : (AND 1 2).
IDRULE V/COORD4 : V[COORD +] --> H[CONJ NEITHER], ( H[CONJ NOR] )+ : 
   (NOT (OR 1 2+)).
IDRULE V/COORD5 : V[COORD +] --> H[CONJ EITHER], ( H[CONJ OR] )+ : (OR 1 2+).
IDRULE V/COORD6 : V[COORD +] --> H[CONJ NULL], H[CONJ BUT] : (AND 1 2).
IDRULE VP/COORD1 : VP[COORD +, ELLIP -] --> ( VP[CONJ NULL] )+, 
   ( VP[CONJ AND] )+ : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], (lambda (F) 
         (F (lambda (lose) 
               (lambda (x) (AND (1+ (lambda (prop) (lambda (ta) (lambda 
                                 (equa) 
                                 (prop (uqe ((equa some) (e) (NOTENSE (ta 
                                                e)))) x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PRES (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PAST (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (AND (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e) 
                                             (NOTENSE (ta e)))) x wh))))))))) 
            lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], (lambda (F) (F (lambda (lose) 
               (lambda (x) (lambda (wh) 
                     (AND (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop 
                                       (uqe ((equa some) (e) (PRES (ta e)))) 
                                       x wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop 
                                       (uqe ((equa some) (e) (PAST (ta e)))) 
                                       x wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop 
                                       (uqe ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))))))) lta lequa)).
IDRULE VP/COORD2 : VP[COORD +, ELLIP -] --> ( VP[CONJ NULL] )+, 
   ( VP[CONJ OR] )+ : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], (lambda (F) 
         (F (lambda (lose) 
               (lambda (x) (OR (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop 
                                    (uqe ((equa some) (e) (NOTENSE (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PRES (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PAST (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1+ (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (OR (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e) 
                                             (NOTENSE (ta e)))) x wh))))))))) 
            lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], (lambda (F) (F (lambda (lose) 
               (lambda (x) (lambda (wh) 
                     (OR (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (OR (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (OR (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))))))) lta lequa)).
IDRULE VP/COORD3 : VP[COORD +, ELLIP -] --> VP[CONJ BOTH], VP[CONJ AND] : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) 
               (lambda (x) (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop 
                                    (uqe ((equa some) (e) (NOTENSE (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) 
                                          (NOTENSE (ta e)))) x)))))))) lta 
            lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (F) (F (lambda (lose) 
               (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e) (PRES (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PRES (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PAST (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PAST (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) x))))) 
                     (2 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e) 
                                             (NOTENSE (ta e)))) x wh))))) 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (NOTENSE (ta e)))) 
                                       x wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))))))) lta lequa)).
IDRULE VP/COORD4 : VP[COORD +, ELLIP -] --> VP[CONJ NEITHER], 
   ( VP[CONJ NOR] )+ : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], (lambda (F) 
         (F (lambda (lose) 
               (lambda (x) (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) 
                                    (prop (uqe ((equa some) (e) (NOTENSE 
                                                (ta e)))) x))))) 
                        (2+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (NOTENSE (ta e)))) 
                                       x))))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop 
                                       (uqe ((equa some) (e) (PRES (ta e)))) 
                                       x))))) 
                        (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) 
                                       x))))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop 
                                       (uqe ((equa some) (e) (PAST (ta e)))) 
                                       x))))) 
                        (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) 
                                       x))))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop 
                                       (uqe ((equa some) (e) (FUT (ta e)))) 
                                       x))))) 
                        (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) 
                                       x))))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (NOT (OR (1 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) 
                                       (prop (uqe ((equa some) (e) 
                                                (NOTENSE (ta e)))) x wh))))) 
                           (2+ 
                              (lambda (prop) (lambda (ta) (lambda (equa) 
                                          (prop 
                                          (uqe ((equa some) (e) (NOTENSE 
                                                   (ta e)))) x wh)))))))))) 
            lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], (lambda (F) (F (lambda (lose) 
               (lambda (x) (lambda (wh) 
                     (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (PRES (ta e)))) x wh))))) 
                           (2+ (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (PRES (ta e)))) x 
                                          wh)))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (NOT (OR (1 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (PAST (ta e)))) x wh))))) 
                           (2+ (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (PAST (ta e)))) x 
                                          wh)))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (NOT (OR (1 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (FUT (ta e)))) x wh))))) 
                           (2+ (lambda (prop) 
                                 (lambda (ta) (lambda (equa) (prop 
                                          (uqe ((equa some) (e) 
                                                (FUT (ta e)))) x wh)))))))))) 
            lta lequa)).
IDRULE VP/COORD5 : VP[COORD +, ELLIP -] --> VP[CONJ EITHER], 
   ( VP[CONJ OR] )+ : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], (lambda (F) 
         (F (lambda (lose) 
               (lambda (x) (OR (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop 
                                    (uqe ((equa some) (e) (NOTENSE (ta e)))) 
                                    x))))) 
                     (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe 
                                       ((equa some) (e) (NOTENSE (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PRES (ta e)))) 
                                    x))))) 
                     (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PRES (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PAST (ta e)))) 
                                    x))))) 
                     (2+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PAST (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (OR (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) x))))) 
                     (2+ 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (OR (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e) 
                                             (NOTENSE (ta e)))) x wh))))) 
                        (2+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (NOTENSE (ta e)))) 
                                       x wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (OR (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))) 
                        (2+ (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (OR (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))) 
                        (2+ (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (OR (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))) 
                        (2+ (lambda (prop) (lambda (ta) 
                                 (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))))))) lta lequa)).
IDRULE VP/COORD6 : VP[COORD +, ELLIP -] --> VP[CONJ NULL], VP[CONJ BUT] : 
   1 = [SLASH NOSLASH, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) 
               (lambda (x) (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop 
                                    (uqe ((equa some) (e) (NOTENSE (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) 
                                          (NOTENSE (ta e)))) x)))))))) lta 
            lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (F) (F (lambda (lose) 
               (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) (lambda (equa) (prop 
                                    (uqe ((equa some) (e) (PRES (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PRES (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (PAST (ta e)))) 
                                    x))))) 
                     (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (PAST (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (FUT (ta e)))) x))))) 
                     (2 
                        (lambda (prop) (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) 
                                    x)))))))) lta lequa)) : 
   1 = [SLASH X2, VFORM (EN, BSE, ING, TO)], 
      (lambda (F) (F (lambda (lose) (lambda (x) 
                  (lambda (wh) (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    (prop (uqe ((equa some) (e) 
                                             (NOTENSE (ta e)))) x wh))))) 
                        (2 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (NOTENSE (ta e)))) 
                                       x wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PRES (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (PAST (ta e)))) x 
                                       wh))))))))) lta lequa)) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (F) (F (lambda (lose) (lambda (x) (lambda (wh) 
                     (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))) 
                        (2 (lambda (prop) (lambda (ta) (lambda (equa) 
                                    (prop (uqe 
                                          ((equa some) (e) (FUT (ta e)))) x 
                                       wh))))))))) lta lequa)).
IDRULE S/COORD1 : S[COORD +] --> ( S[CONJ NULL] )+, ( S[CONJ AND] )+ : 
   0 = [SLASH NOSLASH, ELLIP -, UB (Q, NO, @)], 
      (lambda (F) (F (lambda (lose) (AND 
                  (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e) (ta e)))))))))) lta 
            lequa)) : 
   0 = [SLASH NOSLASH, ELLIP -, UB R], (lambda (F) (F (lambda (lose) 
               (lambda (wh) 
                  (AND (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (ta e))) 
                                    wh)))))))) lta lequa)) : 
   0 = [SLASH X2, ELLIP -], 
      (lambda (F) (F (lambda (lose) (lambda (wh) (AND (1+ 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh)))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP +, UB (Q, NO, @)], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (AND (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    ((mod prop) (uqe ((equa qu) (e) 
                                             (ta e)))))))))) lta lequa)))) : 
   0 = [SLASH NOSLASH, ELLIP +, UB R], 
      (lambda (mod) (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (wh) (AND 
                           (1+ (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))) : 
   0 = [SLASH X2, ELLIP +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (wh) (AND 
                           (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                       ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))).
IDRULE S/COORD2 : S[COORD +] --> ( S[CONJ NULL] )+, ( S[CONJ OR] )+ : 
   0 = [SLASH NOSLASH, ELLIP -, UB (Q, NO, @)], 
      (lambda (F) (F (lambda (lose) (OR 
                  (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e) (ta e)))))))))) lta 
            lequa)) : 
   0 = [SLASH NOSLASH, ELLIP -, UB R], (lambda (F) (F (lambda (lose) 
               (lambda (wh) 
                  (OR (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                 (prop (uqe ((equa some) (e) (ta e))) 
                                    wh)))))))) lta lequa)) : 
   0 = [SLASH X2, ELLIP -], 
      (lambda (F) (F (lambda (lose) (lambda (wh) (OR (1+ 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh)))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP +, UB (Q, NO, @)], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (OR (1+ (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    ((mod prop) (uqe ((equa qu) (e) 
                                             (ta e)))))))))) lta lequa)))) : 
   0 = [SLASH NOSLASH, ELLIP +, UB R], 
      (lambda (mod) (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (wh) (OR 
                           (1+ (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))) : 
   0 = [SLASH X2, ELLIP +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (wh) (OR 
                           (1+ (lambda (prop) (lambda (ta) (lambda (equa) 
                                       ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))).
IDRULE S/COORD3 : S[COORD +] --> S[CONJ NULL], S[CONJ BUT] : 
   0 = [SLASH NOSLASH, ELLIP -, UB (Q, NO, @)], 
      (lambda (F) (F (lambda (lose) (AND 
                  (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e) (ta e)))))))) 
                  (2 (lambda (prop) 
                        (lambda (ta) (lambda (equa) (prop (uqe ((equa some) 
                                       (e) (ta e)))))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP -, UB R], 
      (lambda (F) (F (lambda (lose) (lambda (wh) 
                  (AND (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (ta e))) wh))))) 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (ta e))) 
                                    wh)))))))) lta lequa)) : 
   0 = [SLASH X2, ELLIP -], 
      (lambda (F) (F (lambda (lose) (lambda (wh) (AND (1 
                        (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh))))) 
                     (2 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh)))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP +, UB (Q, NO, @)], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (AND (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    ((mod prop) (uqe ((equa qu) (e) 
                                             (ta e)))))))) 
                        (2 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) ((mod prop) 
                                       (uqe ((equa qu) (e) (ta e)))))))))) 
                  lta lequa)))) : 
   0 = [SLASH NOSLASH, ELLIP +, UB R], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (wh) (AND (1 (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) (ta e))) 
                                          wh))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))) : 
   0 = [SLASH X2, ELLIP +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (wh) (AND 
                           (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                                       ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))).
IDRULE S/COORD4 : S[COORD +] --> S[CONJ EITHER], ( S[CONJ OR] )+ : 
   0 = [SLASH NOSLASH, ELLIP -, UB (Q, NO, @)], 
      (lambda (F) (F (lambda (lose) (OR 
                  (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                              (prop (uqe ((equa some) (e) (ta e)))))))) 
                  (2 (lambda (prop) 
                        (lambda (ta) (lambda (equa) (prop (uqe ((equa some) 
                                       (e) (ta e)))))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP -, UB R], 
      (lambda (F) (F (lambda (lose) (lambda (wh) 
                  (OR (1 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe 
                                       ((equa some) (e) (ta e))) wh))))) 
                     (2 (lambda (prop) 
                           (lambda (ta) (lambda (equa) (prop (uqe 
                                          ((equa some) (e) (ta e))) 
                                    wh)))))))) lta lequa)) : 
   0 = [SLASH X2, ELLIP -], 
      (lambda (F) (F (lambda (lose) (lambda (wh) (OR (1 (lambda (prop) 
                           (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh))))) 
                     (2 (lambda (prop) (lambda (ta) 
                              (lambda (equa) (prop (uqe ((equa some) (e) 
                                          (ta e))) wh)))))))) lta lequa)) : 
   0 = [SLASH NOSLASH, ELLIP +, UB (Q, NO, @)], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (OR (1 (lambda (prop) 
                              (lambda (ta) (lambda (equa) 
                                    ((mod prop) (uqe ((equa qu) (e) 
                                             (ta e)))))))) 
                        (2 (lambda (prop) (lambda (ta) 
                                 (lambda (equa) ((mod prop) 
                                       (uqe ((equa qu) (e) (ta e)))))))))) 
                  lta lequa)))) : 
   0 = [SLASH NOSLASH, ELLIP +, UB R], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (wh) (OR (1 (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) (ta e))) 
                                          wh))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))) : 
   0 = [SLASH X2, ELLIP +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (wh) (OR 
                           (1 (lambda (prop) (lambda (ta) (lambda (equa) 
                                       ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (ta e))) 
                                          wh)))))))) lta lequa)))).
IDRULE PRD/COORD1 : [PRD +, BAR 2, COORD +] --> ( X2[PRD +, CONJ NULL] )+, 
   ( X2[PRD +, CONJ AND] )+ : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (AND (1+ (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (tasp (ta e)))) x)))))))) 
                     lta lequa))))) : 
   0 = [SLASH X2], (lambda (mod) (lambda (qu) 
            (lambda (tasp) (lambda (F) (F (lambda (lose) 
                        (lambda (x) (lambda (wh) 
                              (AND (1+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))).
IDRULE PRD/COORD2 : [PRD +, BAR 2, COORD +] --> ( X2[PRD +, CONJ NULL] )+, 
   ( X2[PRD +, CONJ OR] )+ : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (OR (1+ (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (tasp (ta e)))) x)))))))) 
                     lta lequa))))) : 
   0 = [SLASH X2], (lambda (mod) (lambda (qu) 
            (lambda (tasp) (lambda (F) (F (lambda (lose) 
                        (lambda (x) (lambda (wh) 
                              (OR (1+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))).
IDRULE PRD/COORD3 : [PRD +, BAR 2, COORD +] --> ( X2[PRD +, CONJ EITHER] )+, 
   ( X2[PRD +, CONJ OR] )+ : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (OR (1+ (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (tasp (ta e)))) x)))))))) 
                     lta lequa))))) : 
   0 = [SLASH X2], (lambda (mod) (lambda (qu) 
            (lambda (tasp) (lambda (F) (F (lambda (lose) 
                        (lambda (x) (lambda (wh) 
                              (OR (1+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))).
IDRULE PRD/COORD4 : [PRD +, BAR 2, COORD +] --> ( X2[PRD +, CONJ NEITHER] )+, 
   ( X2[PRD +, CONJ NOR] )+ : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (NOT (OR (1+ (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) ((mod prop) 
                                                (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) 
                                                x))))))))) lta lequa))))) : 
   0 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) (F (lambda (lose) 
                        (lambda (x) 
                           (lambda (wh) (NOT (OR (1+ (lambda (prop) (lambda 
                                             (ta) 
                                             (lambda (equa) ((mod prop) (uqe 
                                                      ((equa qu) (e) 
                                                         (tasp (ta e)))) x 
                                                   wh)))))))))) lta 
                     lequa))))).
IDRULE PRD/COORD5 : [PRD +, BAR 2, COORD +] --> X2[PRD +, CONJ NULL], 
   X2[PRD +, CONJ BUT] : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (AND (1 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (tasp (ta e)))) x))))) 
                              (2 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   0 = [SLASH X2], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F (lambda (lose) 
                        (lambda (x) (lambda (wh) (AND (1 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) ((mod prop) 
                                                (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))) 
                                 (2 (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))).
IDRULE PRD/COORD6 : [PRD +, BAR 2, COORD +] --> X2[PRD +, CONJ BOTH], 
   X2[PRD +, CONJ AND] : 
   0 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F 
                     (lambda (lose) (lambda (x) (AND (1 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (tasp (ta e)))) x))))) 
                              (2 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   0 = [SLASH X2], (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F (lambda (lose) 
                        (lambda (x) (lambda (wh) (AND (1 (lambda (prop) 
                                       (lambda (ta) 
                                          (lambda (equa) ((mod prop) 
                                                (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))) 
                                 (2 (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))).
IDRULE ELL/PRD/COORD : ; in the garden picking flowers - semantically like a
                       ; coordination of P2 and VP. P2 must be +PRD, +LOC,
                       ; PFORM NORM. VP must be +PRD.
   
   X2[PRD +, CONJ NULL, AGR N2[NFORM NORM], SLASH NOSLASH, COORD +, ELLIP +] 
   --> P2[PRD +, NEG -, LOC +, PFORM NORM, SLASH NOSLASH], 
   VP[ING, PRD +, SLASH NOSLASH] : 
   (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (AND ((mod (lambda (e) (lambda (x) (BE e (1 x))))) 
                                 (uqe (qu (e) (tasp e))) x) 
                              (2 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (tasp (PROG e)))) 
                                             x)))))))) lta lequa))))).
IDRULE MOD/COORD1 : [ADV +, BAR 2, COORD +] --> ( X2[+ADV, CONJ NULL] )+, 
   ( X2[+ADV, CONJ AND] )+ : (lambda (e) (AND (1+ e))).
IDRULE MOD/COORD2 : [ADV +, BAR 2, COORD +] --> ( X2[+ADV, CONJ NULL] )+, 
   ( X2[+ADV, CONJ OR] )+ : (lambda (e) (OR (1+ e))).
IDRULE MOD/COORD3 : [ADV +, BAR 2, COORD +] --> ( X2[+ADV, CONJ EITHER] )+, 
   ( X2[+ADV, CONJ OR] )+ : (lambda (e) (OR (1+ e))).
IDRULE MOD/COORD4 : [ADV +, BAR 2, COORD +] --> ( X2[+ADV, CONJ NEITHER] )+, 
   ( X2[+ADV, CONJ NOR] )+ : (lambda (e) (NOT (OR (1+ e)))).
IDRULE MOD/COORD5 : [ADV +, BAR 2, COORD +] --> X2[+ADV, CONJ NULL], 
   X2[+ADV, CONJ BUT] : (lambda (e) (AND (1 e) (2 e))).
IDRULE MOD/COORD6 : [ADV +, BAR 2, COORD +] --> X2[+ADV, CONJ BOTH], 
   X2[+ADV, CONJ AND] : (lambda (e) (AND (1 e) (2 e))).
IDRULE ELL/VP/COORD1 : VP[COORD +, ELLIP +] --> ( VP[CONJ NULL] )+, 
   ( VP[CONJ AND] )+ : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], (lambda (mod) (lambda (qu) 
            (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) (AND (1+ (lambda 
                                    (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PRES (ta e)))) x)))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PAST (ta e)))) x)))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (AND (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) (FUT (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (AND (1+ (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x 
                                                wh))))))))) lta lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          ((mod prop) (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          ((mod prop) (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) 
                                          ((mod prop) (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x 
                                             wh))))))))) lta lequa)))).
IDRULE ELL/VP/COORD2 : VP[COORD +, ELLIP +] --> ( VP[CONJ NULL] )+, 
   ( VP[CONJ OR] )+ : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], (lambda (mod) (lambda (qu) 
            (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) (OR (1+ (lambda 
                                    (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (OR (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PRES (ta e)))) x)))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (OR (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PAST (ta e)))) x)))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (OR (1+ (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) (FUT (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (OR (1+ (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x 
                                                wh))))))))) lta lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x 
                                             wh))))))))) lta lequa)))).
IDRULE ELL/VP/COORD3 : VP[COORD +, ELLIP +] --> VP[CONJ BOTH], VP[CONJ AND] : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) 
                           (AND (1 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x))))) 
                              (2 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND (1 (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PRES (ta e)))) x))))) 
                           (2 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PRES (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (AND 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (AND (1 (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x wh))))) 
                                 (2 
                                    (lambda (prop) (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x 
                                                wh))))))))) lta lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x 
                                             wh))))))))) lta lequa)))).
IDRULE ELL/VP/COORD4 : VP[COORD +, ELLIP +] --> VP[CONJ NEITHER], 
   ( VP[CONJ NOR] )+ : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], (lambda (mod) (lambda (qu) 
            (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) (NOT (OR (1 
                                    (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x))))) 
                                 (2+ (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x))))))))) 
                     lta lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (NOT (OR (1 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (PRES (ta e)))) x))))) 
                              (2+ (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (PRES (ta 
                                                   e)))) x))))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (NOT (OR (1 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                   (PAST (ta e)))) x))))) 
                              (2+ (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (PAST (ta 
                                                   e)))) x))))))))) lta 
                  lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT (OR (1 (lambda (prop) 
                                    (lambda (ta) 
                                       (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) (FUT (ta e)))) 
                                             x))))) 
                              (2+ (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x))))))))) 
                  lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], (lambda (mod) 
         (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (NOT (OR (1 (lambda (prop) 
                                          (lambda (ta) 
                                             (lambda (equa) ((mod prop) 
                                                   (uqe ((equa qu) (e) 
                                                         (tasp (ta e)))) x 
                                                   wh))))) 
                                    (2+ (lambda (prop) (lambda (ta) 
                                             (lambda (equa) 
                                                ((mod prop) (uqe ((equa qu) 
                                                         (e) (tasp (ta e)))) 
                                                   x wh)))))))))) lta 
                     lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) (NOT 
                              (OR (1 (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (PRES (ta e)))) x 
                                                wh))))) 
                                 (2+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (PRES (ta e)))) x 
                                                wh)))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (PAST (ta e)))) x 
                                                wh))))) 
                                 (2+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (PAST (ta e)))) x 
                                                wh)))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (NOT (OR (1 (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (FUT (ta e)))) x 
                                                wh))))) 
                                 (2+ (lambda (prop) (lambda (ta) 
                                          (lambda (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (FUT (ta e)))) x 
                                                wh)))))))))) lta lequa)))).
IDRULE ELL/VP/COORD5 : VP[COORD +, ELLIP +] --> VP[CONJ EITHER], 
   ( VP[CONJ OR] )+ : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], (lambda (mod) (lambda (qu) 
            (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) (OR (1 (lambda 
                                    (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x))))) 
                              (2+ (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (OR (1 (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PRES (ta e)))) x))))) 
                           (2+ (lambda (prop) 
                                 (lambda (ta) (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PRES (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (OR 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x))))) 
                           (2+ (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (OR 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x))))) 
                           (2+ (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (OR (1 (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x wh))))) 
                                 (2+ 
                                    (lambda (prop) (lambda (ta) (lambda 
                                                (equa) 
                                             ((mod prop) (uqe ((equa qu) (e) 
                                                      (tasp (ta e)))) x 
                                                wh))))))))) lta lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x wh))))) 
                              (2+ 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x wh))))) 
                              (2+ 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (OR (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x wh))))) 
                              (2+ 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x 
                                             wh))))))))) lta lequa)))).
IDRULE ELL/VP/COORD6 : VP[COORD +, ELLIP +] --> VP[CONJ NULL], VP[CONJ BUT] : 
   1 = [SLASH NOSLASH, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) 
               (lambda (F) (F (lambda (lose) (lambda (x) 
                           (AND (1 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x))))) 
                              (2 (lambda (prop) 
                                    (lambda (ta) (lambda (equa) ((mod prop) 
                                             (uqe 
                                                ((equa qu) (e) (tasp (ta 
                                                   e)))) x)))))))) lta 
                     lequa))))) : 
   1 = [SLASH NOSLASH, FIN +, PAST -], (lambda (mod) 
         (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND (1 (lambda (prop) 
                                 (lambda (ta) 
                                    (lambda (equa) ((mod prop) (uqe 
                                                ((equa qu) (e) 
                                                (PRES (ta e)))) x))))) 
                           (2 (lambda (prop) 
                                 (lambda (ta) (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PRES (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F 
                  (lambda (lose) (lambda (x) (AND 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (PAST (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH NOSLASH, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (AND 
                           (1 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x))))) 
                           (2 (lambda (prop) (lambda (ta) 
                                    (lambda (equa) ((mod prop) 
                                          (uqe ((equa qu) (e) (FUT (ta e)))) 
                                          x)))))))) lta lequa)))) : 
   1 = [SLASH X2, VFORM (BSE, EN)], 
      (lambda (mod) (lambda (qu) (lambda (tasp) (lambda (F) 
                  (F (lambda (lose) (lambda (x) 
                           (lambda (wh) (AND (1 (lambda (prop) 
                                       (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x wh))))) 
                                 (2 
                                    (lambda (prop) (lambda (ta) (lambda (equa) 
                                             ((mod prop) 
                                                (uqe ((equa qu) (e) (tasp 
                                                         (ta e)))) x 
                                                wh))))))))) lta lequa))))) : 
   1 = [SLASH X2, FIN +, PAST -], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PRES (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST +], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (PAST (ta e)))) x 
                                             wh))))))))) lta lequa)))) : 
   1 = [SLASH X2, FIN +, PAST FUT], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (AND (1 (lambda (prop) (lambda (ta) 
                                       (lambda (equa) ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x wh))))) 
                              (2 
                                 (lambda (prop) (lambda (ta) (lambda (equa) 
                                                ((mod prop) 
                                             (uqe ((equa qu) (e) 
                                                   (FUT (ta e)))) x 
                                             wh))))))))) lta lequa)))).
IDRULE ELL/S1a : ; [ELLIP +] version of S1a.
   S[COMP NORM, -INV, +FIN, ELLIP @e, COORD +, UDC -] --> N2[+NOM, -PRD], 
   H2[-SUBJ, AGR N2, ELLIP +, COORD +] : 
   2 = [SLASH NOSLASH], 1 = [UB (Q, NO, @)], 0 = [ELLIP -], 
      (2 (lambda (prop1) prop1) some 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (prop e 1)) ta equa)))))) : 
   2 = [SLASH NOSLASH], 1 = [UB R], 0 = [ELLIP -], 
      (2 (lambda (prop1) prop1) some 
         (lambda (prop) (lambda (ta) (lambda (equa) 
                  (lambda (Q) (Q (lambda (e) (lambda (x) (prop e (1 x)))) ta 
                        equa)))))) : 
   2 = [SLASH X2], 0 = [ELLIP -], (2 (lambda (prop1) prop1) some 
         (lambda (prop) 
            (lambda (ta) (lambda (equa) (lambda (Q) (Q (lambda (e) 
                           (lambda (wh) (prop e 1 wh))) ta equa)))))) : 
   2 = [SLASH NOSLASH], 1 = [UB (NO, @)], 0 = [ELLIP +], 
      (lambda (mod) (lambda (qu) 
            (2 mod qu (lambda (prop) (lambda (ta) (lambda (equa) 
                        (lambda (Q) (Q (lambda (e) (prop e 1)) ta 
                              equa)))))))).
IDRULE ELL/S1b : ; [ELLIP +] version of S1b.
   S[COMP NORM, -INV, +FIN] --> N2[+NOM, -PRD], A2[+ADV, -QUA], 
   H2[-SUBJ, AGR N2, COORD +, ELLIP +] : 
   3 = [SLASH NOSLASH], 1 = [UB (Q, NO, @)], 
      ((3 (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) (2 e))))) 
            some) 
         (lambda (prop1) (lambda (ta1) (lambda (equa1) (lambda (Q) (Q 
                        (lambda (e1) (prop1 e1 1)) lta lequa)))))) : 
   3 = [SLASH NOSLASH], 1 = [UB R], 
      ((3 (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) (2 e))))) 
            some) 
         (lambda (prop1) (lambda (ta1) (lambda (equa1) (lambda (Q) (Q 
                        (lambda (e1) (lambda (x1) (prop1 e1 (1 x1)))) lta 
                        lequa)))))) : 
   3 = [SLASH X2], ((3 (lambda (prop) (lambda (e) 
                  (lambda (x) (lambda (wh) (and (prop e x wh) (2 e)))))) 
            some) 
         (lambda (prop1) (lambda (ta1) (lambda (equa1) (lambda (Q) (Q 
                        (lambda (e1) (lambda (wh1) (prop1 e1 1 wh1))) lta 
                        lequa)))))).
IDRULE ELL/S1c : ; [ELLIP +] version of S1c.
   S[COMP NORM, -INV, +FIN] --> N2[+NOM, -PRD], A2[+ADV, +QUA], 
   H2[-SUBJ, AGR N2, ELLIP +, COORD +] : 
   3 = [SLASH NOSLASH], 1 = [UB (Q, NO, @)], 
      ((3 (lambda (prop) prop) 2) (lambda (prop1) 
            (lambda (ta1) (lambda (equa1) 
                  (lambda (Q) (Q (lambda (e1) (prop1 e1 1)) lta lequa)))))) : 
   3 = [SLASH NOSLASH], 1 = [UB R], 
      ((3 (lambda (prop) prop) 2) (lambda (prop1) 
            (lambda (ta1) (lambda (equa1) 
                  (lambda (Q) (Q (lambda (e1) (lambda (x1) 
                              (prop1 e1 (1 x1)))) lta lequa)))))) : 
   3 = [SLASH X2], 
      ((3 (lambda (prop) prop) 2) (lambda (prop1) (lambda (ta1) (lambda 
                  (equa1) 
                  (lambda (Q) (Q (lambda (e1) (lambda (wh1) (prop1 e1 1 
                                 wh1))) lta lequa)))))).
IDRULE ELL/S/ADVBLa1 : ; [ELLIP +] version of S/ADVBLa1
   S[WH @a, UB @b, EVER @c, UDC +] --> ADVP[WH @a, UB @b, EVER @c], 
   S[H +, INV -, ELLIP +, COORD +] : 
   0 = [UB (NO, Q, @), SLASH NOSLASH], 1 = [QUA -], 
      (2 (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) (1 e))))) 
         some) : 
   0 = [UB (NO, @), SLASH X2], 1 = [QUA -], (2 (lambda (prop) (lambda (e) 
               (lambda (x) (lambda (wh) (and (prop e x wh) (1 e)))))) some) : 
   0 = [UB (NO, Q, @)], 1 = [QUA +], (2 (lambda (prop) prop) 1).
IDRULE ELL/S/ADVBLa2 : ; [ELLIP +] version of S/ADVBLa2
   S[WH +, UB Q, EVER @c, UDC +] --> ADVP[WH +, UB Q, EVER @c], 
   S[H +, INV +, SLASH NOSLASH, ELLIP +, COORD +] : 
   1 = [QUA -], (2 (lambda (prop) (lambda (e) (and (prop e) (1 e)))) some) : 
   1 = [QUA +], (2 (lambda (prop) prop) 1).
IDRULE ELL/VP/TO : ; [ELLIP +] version of VP/TO
   VP[+AUX, VFORM TO, -FIN, ELLIP @e, COORD +] --> H[SUBCAT TO], 
   VP[BSE, ELLIP +, COORD +] : 
   0 = [ELLIP +], (lambda (mod) (lambda (qu) (2 mod qu NOTENSE))) : 
   0 = [ELLIP -], (2 (lambda (prop) prop) some NOTENSE).
IDRULE ELL/VP/DO1 : ; [ELLIP +] version of VP/DO1
   VP[+AUX, +FIN, VFORM NOT, ELLIP +, COORD +] --> H[SUBCAT DO], 
   VP[AUX -, BSE, ELLIP +, COORD +] : 
   1 = [NEG -, PAST -], (lambda (mod) (lambda (qu) (2 mod qu PRES))) : 
   1 = [NEG -, PAST +], (lambda (mod) (lambda (qu) (2 mod qu PAST))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               PRES))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT (2 mod qu PRES 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               PAST))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT (2 mod qu PAST 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu PRES))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu PRES (lambda (f1) 
                                    (lambda (f2) (lambda (f3) f1))) lose1 x 
                                 wh))))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu PAST))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu PAST (lambda (f1) 
                                    (lambda (f2) (lambda (f3) f1))) lose1 x 
                                 wh))))) lta lequa)))).
IDRULE ELL/VP/HAVE : ; [ELLIP +] version of VP/HAVE
   VP[+AUX, ELLIP @e, COORD +] --> H[SUBCAT HAVE], 
   VP[EN, PRD -, ELLIP +, COORD +] : 
   1 = [FIN -], 0 = [ELLIP +], (lambda (mod) 
         (lambda (qu) (lambda (tasp) (2 mod qu 
                  (lambda (e) (tasp (PERF e))))))) : 
   1 = [FIN -], 0 = [ELLIP -], 
      (2 (lambda (prop) prop) some (lambda (e) (NOTENSE (PERF e)))) : 
   1 = [NEG -, PAST -], 
      (lambda (mod) (lambda (qu) (2 mod qu (lambda (e2) (PRES 
                     (PERF e2)))))) : 
   1 = [NEG -, PAST +], (lambda (mod) (lambda (qu) 
            (2 mod qu (lambda (e2) (PAST (PERF e2)))))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               (lambda (e2) (PRES (PERF e2)))))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT 
                           (2 mod qu (lambda (e2) (PRES (PERF e2))) 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               (lambda (e2) (PAST (PERF e2)))))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT 
                           (2 mod qu (lambda (e2) (PAST (PERF e2))) 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu 
               (lambda (e2) (PRES (PERF e2)))))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu (lambda (e2) (PRES (PERF e2))) 
                                 (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                                 lose1 x wh))))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu 
               (lambda (e2) (PAST (PERF e2)))))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu (lambda (e2) (PAST (PERF e2))) 
                                 (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                                 lose1 x wh))))) lta lequa)))).
IDRULE ELL/VP/WILL : ; [ELLIP +] version of VP/WILL
   VP[+AUX, +FIN, VFORM NOT, ELLIP +, COORD +] --> H[SUBCAT FUT], 
   VP[BSE, ELLIP +, COORD +] : 
   1 = [NEG -], (lambda (mod) (lambda (qu) (2 mod qu FUT))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               FUT))) : 
   1 = [NEG +], 2 = [SLASH NOSLASH], (lambda (mod) (lambda (qu) 
            (lambda (F) (F 
                  (lambda (lose) (lambda (x) (NOT (2 mod qu FUT (lambda (f1) 
                                 (lambda (f2) (lambda (f3) f1))) lose1 x)))) 
                  lta lequa)))) : 
   1 = [NEG +], 2 = [SLASH X2], (lambda (mod) (lambda (qu) 
            (2 (lambda (prop) (mod 
                     (lambda (e) (lambda (x) (lambda (wh) (NOT (prop e x 
                                    wh))))))) qu FUT))) : 
   1 = [NEG +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) (F (lambda (lose) 
                     (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu FUT (lambda (f1) (lambda (f2) 
                                       (lambda (f3) f1))) lose1 x wh))))) lta 
                  lequa)))).
IDRULE ELL/VP/BE_PRD : ; [ELLIP +] version of VP/BE_PRD
   VP[+AUX, ELLIP @e, COORD +, SLASH @s, AGR @a] --> H[SUBCAT BE], 
   X2[+PRD, ELLIP +, COORD +, SLASH @s, AGR @a] : 
   1 = [FIN -], 0 = [ELLIP +], 2 : 
   1 = [FIN -], 0 = [ELLIP -], (2 (lambda (prop) prop) some NOTENSE) : 
   1 = [NEG -, PAST -], (lambda (mod) (lambda (qu) (2 mod qu PRES))) : 
   1 = [NEG -, PAST +], (lambda (mod) (lambda (qu) (2 mod qu PAST))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               PRES))) : 
   1 = [NEG +, PAST -], 2 = [SLASH NOSLASH], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT (2 mod qu PRES 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) (NOT (prop e x)))))) qu 
               PAST))) : 
   1 = [NEG +, PAST +], 2 = [SLASH NOSLASH], (lambda (mod) 
         (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (NOT (2 mod qu PAST 
                              (lambda (f1) (lambda (f2) (lambda (f3) f1))) 
                              lose1 x)))) lta lequa)))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu PRES))) : 
   1 = [NEG +, PAST -], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu PRES (lambda (f1) 
                                    (lambda (f2) (lambda (f3) f1))) lose1 x 
                                 wh))))) lta lequa)))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (mod (lambda (e) (lambda (x) 
                           (lambda (wh) (NOT (prop e x wh))))))) qu PAST))) : 
   1 = [NEG +, PAST +], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (lambda (F) 
               (F (lambda (lose) (lambda (x) (lambda (wh) 
                           (NOT (2 mod qu PAST (lambda (f1) 
                                    (lambda (f2) (lambda (f3) f1))) lose1 x 
                                 wh))))) lta lequa)))).
IDRULE ELL/VP/MOD1 : ; [ELLIP +] version of VP/MOD1
   VP[-AUX, ELLIP @e, COORD +] --> VP[H +, ELLIP +, COORD +], 
   X2[+ADV, +PRD] : 
   1 = [SLASH NOSLASH], 2 = [-QUA], 0 = [ELLIP +], (lambda (mod) 
         (lambda (qu) (1 
               (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) 
                           (2 e))))) qu))) : 
   1 = [SLASH X2], 2 = [-QUA], 0 = [ELLIP +], 
      (lambda (mod) (lambda (qu) (1 (lambda (prop) 
                  (lambda (e) (lambda (x) (lambda (wh) 
                           (and (prop e x wh) (2 e)))))) qu))) : 
   2 = [+QUA], 0 = [ELLIP +], (lambda (mod) (lambda (qu) (1 mod 2))) : 
   1 = [SLASH NOSLASH], 2 = [-QUA], 0 = [ELLIP -], 
      (1 (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) (2 e))))) 
         some) : 
   1 = [SLASH X2], 2 = [-QUA], 0 = [ELLIP -], (1 (lambda (prop) (lambda (e) 
               (lambda (x) (lambda (wh) (and (prop e x wh) (2 e)))))) some) : 
   2 = [+QUA], 0 = [ELLIP -], (1 (lambda (prop) prop) 2).
IDRULE ELL/VP/MOD2 : ; [ELLIP +] version of VP/MOD2
   VP[-FIN, -PRD, ELLIP @e, COORD +] --> A2[+ADV], 
   VP[H +, ELLIP +, COORD +] : 
   1 = [-QUA], 2 = [SLASH NOSLASH], 0 = [ELLIP +], 
      (lambda (mod) (lambda (qu) (2 
               (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) 
                           (1 e))))) qu))) : 
   1 = [-QUA], 2 = [SLASH X2], 0 = [ELLIP +], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (lambda (e) (lambda (x) (lambda (wh) 
                           (and (prop e x wh) (1 e)))))) qu))) : 
   1 = [+QUA], 0 = [ELLIP +], (lambda (mod) (lambda (qu) (2 mod 1))) : 
   1 = [-QUA], 2 = [SLASH NOSLASH], 0 = [ELLIP -], 
      (2 (lambda (prop) (lambda (e) (lambda (x) (and (prop e x) (1 e))))) 
         some) : 
   1 = [-QUA], 2 = [SLASH X2], 0 = [ELLIP -], (2 (lambda (prop) (lambda (e) 
               (lambda (x) (lambda (wh) (and (prop e x wh) (1 e)))))) some) : 
   1 = [+QUA], 0 = [ELLIP -], (2 (lambda (prop) prop) 1).
IDRULE ELL/PRD/MOD : ; [ELLIP +] version of PRD/MOD
   X2[+PRD, NEG @n, SLASH @s, AGR @a, COORD +, ELLIP +] --> A2[+ADV], 
   X2[H +, +PRD, NEG @n, SLASH @s, AGR @a, COORD +, ELLIP +] : 
   1 = [-QUA], 2 = [SLASH NOSLASH], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) 
                  (lambda (e) (lambda (x) (and (prop e x) (1 e))))) qu))) : 
   1 = [-QUA], 2 = [SLASH X2], 
      (lambda (mod) (lambda (qu) (2 (lambda (prop) (lambda (e) 
                     (lambda (x) (lambda (wh) (and (prop e x wh) (1 e)))))) 
               qu))) : 1 = [+QUA], (lambda (mod) (lambda (qu) (2 mod 1))).
\end{verbatim}
{\bf ; PS rules}
\begin{verbatim}
PSRULE P/NEG : ; not in. (+NEG Ps will only be able to appear in conjoined
               ; Ps - 'not in but under the desk' - see defrules P/NEG*.)
               ; This is a psrule because otherwise it would linearise the
               ; wrong way.
   P[NEG +, SUBCAT @x] --> [NEG +] H[NEG -, SUBCAT @x] : (NOT 2).
PSRULE VP/NP_NP_PHRA/PASS : ; given the book back (by lee). This is a psrule
                            ; in order to prevent metarules MSLASH3b and
                            ; MSLASH4b from applying to it.
   VP[PAS, AGR N2[NFORM NORM], SLASH @s] --> H[SUBCAT NP_NP, PRT @p] 
   N2[SLASH NOSLASH] [PRT @p] ( P2[PFORM BY, SLASH @s, PRD -] ) : 
   4 = [SLASH NOSLASH], 
      (lambda (Q) (Q (lambda (e) (lambda (y) ((CP 1 3) e (4 (lambda (prep) 
                           (lambda (x) x))) 2 y))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   4 = [SLASH X2], (lambda (Q) (Q (lambda (e) (lambda (y) 
                  (lambda (wh) ((CP 1 3) e 
                        (4 (lambda (prep) (lambda (x) x)) wh) 2 y)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   (lambda (Q) (Q (lambda (e) (lambda (y) 
                  ((CP 1 3) e (uq (some (x1) (entity x1))) 2 y))) 
            (lambda (e2) e2) (lambda (qu) qu))).
PSRULE PRT/PREP : ; a fix for some phrasal prepositional verbs - it proved
                  ; too difficult to linearise them properly.
   [PRT @1, PREP @2] --> [PRT @1] P[PFORM @2] : (lambda (verb) (CP verb 1 2)).
PSRULE V/PRO/SO1 : ; (kim) does so (*will so, *must so).
   V[+AUX, +PRO, SUBCAT NULL, NEG -, -INV] --> 
   H[-PRO, SUBCAT DO, NEG -, -INV] [SO +, NEG -, CONEG -] : 
   (lambda (Q) (Q (lambda (e) (lambda (x) (PROVP e x))) (lambda (e2) e2) 
            (lambda (qu) qu))).
PSRULE V/PRO/SO2 : ; (kim) didn't either. (won't either, mustn't either)
   V[+AUX, +PRO, SUBCAT NULL, NEG +, -INV] --> 
   H[-PRO, SUBCAT @s, SUBTYPE @ss, NEG +, -INV] [SO +, NEG -, CONEG +] : 
   1 = [SUBCAT (DO, BE, FUT)], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (NPROVP e x)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE NONE], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((1 (lambda (epi) (lambda (deo) epi))) 
                     (NOT (NPROVP e x))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE (NONE, DEO)], 
      (lambda (Q) (Q (lambda (e) 
               (lambda (x) ((1 (lambda (epi) (lambda (deo) deo))) e x 
                     (NOT (PROVP (uqe (some (e2) (NOTENSE e2))) x))))) 
            (lambda (e3) e3) (lambda (qu) qu))) : 
   1 = [SUBCAT HAVE], (lambda (Q) 
         (Q (lambda (e) (lambda (x) (NOT (NPROVP e x)))) 
            (lambda (e2) (PERF e2)) (lambda (qu) qu))).
PSRULE V/PRO/SO3 : ; so has, neither has etc. Inverted +PRO verb. Have to
                   ; use the non-pro entry in order to get NPROVP/PROVP
                   ; distinction.
   V[+AUX, +PRO, +INV, SUBCAT NULL, NEG @n, AGR N2[NFORM NORM]] --> 
   [SO +, NEG @n, CONEG -] H[-PRO, -INV, SUBCAT @s, SUBTYPE @ss, -NEG] : 
   1 = [NEG -], 2 = [SUBCAT (DO, BE, FUT)], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (PROVP e x))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE NONE], 
      (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((2 (lambda (epi) (lambda (deo) epi))) 
                     (PROVP e x)))) (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE (NONE, DEO)], 
      (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((2 (lambda (epi) (lambda (deo) deo))) e 
                     x (PROVP (uqe (some (e2) (NOTENSE e2))) x)))) 
            (lambda (e3) e3) (lambda (qu) qu))) : 
   1 = [NEG -], 2 = [SUBCAT HAVE], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (PROVP e x))) 
            (lambda (e2) (PERF e2)) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SUBCAT (DO, BE, FUT)], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (NPROVP e x)))) 
            (lambda (e2) e2) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE NONE], 
      (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((2 (lambda (epi) (lambda (deo) epi))) 
                     (NOT (NPROVP e x))))) (lambda (e2) e2) 
            (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SUBCAT (MODAL_BSE, MODAL_INF), SUBTYPE (NONE, DEO)], 
      (lambda (Q) 
         (Q (lambda (e) (lambda (x) ((2 (lambda (epi) (lambda (deo) deo))) e 
                     x (NOT (PROVP (uqe (some (e2) (NOTENSE e2))) x))))) 
            (lambda (e3) e3) (lambda (qu) qu))) : 
   1 = [NEG +], 2 = [SUBCAT HAVE], 
      (lambda (Q) (Q (lambda (e) (lambda (x) (NOT (NPROVP e x)))) 
            (lambda (e2) (PERF e2)) (lambda (qu) qu))).
PSRULE N/NAME1 : ; rules for complex names. This one does egs like sandy
                 ; jones, s jones, sandy lee, sandy l jones.
   N[PN @pn, PLU -, COUNT +, NFORM NORM, SUBCAT NULL, POSS -, ADDRESS -] --> 
   N[PN +, SUBCAT NULL, ADDRESS -] ( N[PN +, SUBCAT NULL, ADDRESS -] ) 
   N[PN +, SUBCAT NULL, ADDRESS -] : (and 3 (first-name 1)) : 
   (and 3 (first-name 1) (second-name 2)).
PSRULE N/NAME2A : ; mr jones, mr jones esq
   N[-PLU, COUNT +, PN -, -POSS, SUBCAT NULL, ADDRESS -] --> 
   N[ADDRESS +, SUBCAT NULL] N[+PN, SUBCAT NULL, ADDRESS -] 
   ( N[ADDRESS +, SUBCAT NULL] ) : (and 2 (title 1)) : 
   (and 2 (title 1) (title 3)).
PSRULE N/NAME2B : ; sandy jones jnr
   N[-PLU, COUNT +, PN -, -POSS, SUBCAT NULL, ADDRESS -] --> 
   N[+PN, SUBCAT NULL, ADDRESS -] N[ADDRESS +, SUBCAT NULL] : 
   (and 1 (title 2)).
PSRULE NUM1 : ; rules for numbers. This one - thirty three
   [CN1 @x, CN2 SMALL] --> [CN1 TY, CN2 SMALL] [CN1 TEN, CN2 SMALL] : (+ 1 2).
PSRULE NUM2 : ; twenty one, thirty one, forty one ...
   [CN1 @x, CN2 SMALL] --> [CN1 TY, CN2 SMALL] [CN3 ONE] : (+ 1 2).
PSRULE NUM3 : ; three hundred, thirty thousand
   [CN1 @x, CN2 BIG, AND -, CN4 +] --> [CN1 @y, CN2 @z, AND @w, CN4 +] 
   [CN1 @x, CN2 BIG, AND -, CN4 -] : (* 1 2).
PSRULE NUM4 : ; three hundred and thirty three
   [CN1 @x, CN2 BIG, AND +, CN4 +] --> [CN1 @x, CN2 BIG, AND -, CN4 +] 
   [SUBCAT AND, CONJN +] [CN1 @y, CN2 SMALL] : (+ 1 3).
PSRULE NUM5 : ; three hundred and one
   [CN1 @x, CN2 BIG, AND +, CN4 +] --> [CN1 @x, CN2 BIG, AND -, CN4 +] 
   [SUBCAT AND, CONJN +] [CN3 ONE] : (+ 1 3).
PSRULE NUM6 : ; three thousand three hundred
   [CN1 THOU, CN2 BIG, AND +, CN4 +] --> [CN1 THOU, CN2 BIG, AND -, CN4 +] 
   [CN1 @z, CN2 BIG, CN4 +] : (+ 1 2).
PSRULE NUM7 : ; a hundred, a thousand, one hundred, one thousand ..
   [CN1 @x, CN2 BIG, AND -, CN4 +] --> [CN3 @y] 
   [CN1 @x, CN2 BIG, AND -, CN4 -] : (* 1 2).
PSRULE NUM8 : ; a range of numbers: 'two to four' '3-7'.
   [CN1 @a, CN2 -, AND @b] --> [CN1 @c, CN2 @d, AND @e, CN4 +] P[RANGEOP IN] 
   [CN1 @f, CN2 @g, AND @h, CN4 +] : (RANGE (NN 1) (NN 3)).
PSRULE NUM9 : ; an open ended numerical range with one endpoint: 'over
              ; three', 'less than four'.
   [CN1 @a, CN2 -, AND @b] --> P[RANGEOP PRE] 
   [CN1 @c, CN2 @d, AND @e, CN4 +] : (RANGE 1 (NN 2)).
PSRULE FRACT1 : ; a quarter, one tenth
   [FRACT +, PLU -] --> [CN3 @cn] [FRACT -, PLU -] : (/ 1 2).
PSRULE FRACT2 : ; three quarters, nine tenths
   [FRACT +, PLU +] --> [CN1 @a, CN2 @b, CN4 @c] [FRACT -, PLU +] : (/ 1 2).
PSRULE NEG/DETA : ; not too, not so etc.
   DetA[AFORM @a, WH NO, UB NO, EVER NO] --> [NEG +] 
   DetA[AFORM @a, WH NO, UB NO, EVER NO] : (1 2).
PSRULE GROUP : ; [GROUP +] nouns don't get used by the grammar and if the
               ; flag is on there is a warning every time a word with a
               ; [GROUP +] entry is looked up. This is useful but also
               ; annoying. This rule will cause the warning to disappear for
               ; these words but won't actually build a category that can be
               ; used by the rest of the grammar. If you want the warning
               ; back delete this rule.
   N[GROUP +] --> H[GROUP +].
PSRULE PREMOD : ; same as psrule GROUP except this time for [PREMOD +] nouns
                ; which exist in the lexicon but aren't used by the grammar.
   N[PREMOD +] --> H[PREMOD +].
\end{verbatim}
